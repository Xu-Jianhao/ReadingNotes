第一章、UNIX基础知识
    1、 程序和进程
        1\  程序
            程序(program)是一个存储在磁盘上某个目录中的可执行文件,内核使用exec函数(7个exec
            函数之一),将程序读入到内存,并执行程序.
        2\  进程
            程序的执行实例被称为进程.

    2、 出错处理
        打印出错信息的函数
        1)  #include <string.h>
            char *strerror(int errnum);
            
            返回值: 指向错误信息字符串的指针

        2） #include <stdio.h>
            void perror(const char *msg);
            
            perror 函数基于errno的当前值,在标准错误上产生一条出错信息
            它首先输出由msg指向的字符串,然后是一个冒号一个空格,接着是对用于errno值的错误信息

    3、 用户标识
        1\  用户ID
            通常每个用户有一个唯一的用户ID
            用户ID为0的用户为root用户或超级用户superuser
            如果一个进程具有超级用户特权,则大多数文件权限检查都不在进行

        2\  组ID
            对于磁盘上的每个文件,文件系统都存储该文件所有者的用户ID和组ID,存储这两个值需要4个字节
            如果使用完整的ASCII登录名和组名,则需要更多的磁盘空间,另外,在检验权限期间,比较字符串较之
            比较整型数更消耗时间.

        3\  附属组ID
            允许一个用户至多属于16个其他的组

    4、 信号(signal)
        信号用于通知进程发生了某种情况,进程有以下3种处理信号的方式
        1)  忽略信号,有些信号表示硬件异常,例如除以0或访问进程地址空间以外的存储单元等,
            因为这些异常产生的后果不确定,所以不推荐使用这种处理方式
        2)  按系统默认方式处理,大多数信号的默认处理方式是终止该进程
        3)  提供一个函数,信号发生时调用该函数,这被称为捕捉该信号

    5、 时间值
        1\  日历时间
            time_t
        2\  进程时间(CPU时间)
            clock_t
            UNIX系统为一个进程维护了3个进程时间值:
            时钟时间        -   墙上时钟时间,它是进程运行的时间总量
            用户CPU时间     -   是执行用户指令所用的时间量
            系统CPU时间     -   是为该进程执行内核程序所经历的时间
            time 命令查看进程时间

    6、 系统调用和库函数
        1)  所有的操作系统都提供多种服务的入口点,由此程序向内核请求服务.各种版本的UNIX实现都提供
            良好定义、数量有限、直接进入内核的入口点,这些入口点被称为系统调用.

第二章、    UNIX标准及实现
    1、 sysconf、pathconf和fpathconf 函数   -   获取系统的运行时限制值
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        #include <unistd.h>
        long sysconf(int name);
        long pathconf(const char *pathname, int name);
        log  fpathconf(int fd, int name);
                                    3个函数返回值:成功返回相应值,出错,返回-1
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        后面两个函数的差别是:一个用路径名作为其参数,另一个则取文件描述符做为参数.
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        sysconf(int name) name的可传入值:
                限制名                  说明                        name参数
            ARG_MAX         exec函数的参数最大长度(字节)            _SC_ARG_MAX
            ATEXIT_MAX      可用atexit函数登记的最大函数个数        _SC_ATEXIT_MAX
            CHILD_MAX       每个实际用户ID的最大进程数              _SC_CHILD_MAX
            时钟滴答/秒     每秒时钟的滴答数                        _SC_CLK_TCK
            COLL_WEIGHTS_MAX在本地定义文件中可以赋予LC_COLLATE
                            顺序关键字项的最大权重数                _SC_COLL_WEIGHTS_MAX
            DELAYTIMER_MAX  定时器最大超限运行次数                  _SC_DELAYTIMER_MAX
            HOST_NAME_MAX   gethostname函数返回的主机名最大长度     _SC_HOST_NAME_MAX
            IOC_MAX         readv或writev函数可以使用最多的
                            iovec结构的个数                         _SC_IOV_MAX

            LINE_MAX        实用程序输入行的最大长度                _SC_LINE_MAX
            LOGIN_NAME_MAX  登录名的最大长度                        _SC_LOGIN_NAME_MAX
            NGROUPS_MAX     每个进程同时添加的最大进程组ID数        _SC_NGROUPS_MAX
            OPEN_MAX        每个进程最大打开的文件数                _SC_OPEN_MAX
            PAGESIZE        系统存储页长度(字节数)                  _SC_PAGESIZE
            PAGE_SIZE       系统存储页长度(字节数)                  _SC_PAGE_SIZE
            RE_DUP_MAX      regexec和regcomp允许的正则重复次数      _SC_RE_DUP_MAX
            RTSIG_MAX       为应用程序预留的实时信号的最大个数      _SC_RTSIG_MAX
            SEM_NSEMS_MAX   一个进程可使用的信号量最大个数          _SC_SEM_NSEMS_MAX
            SEM_VALUE_MAX   信号量的最大值                          _SC_SEM_VALUE_MAX
            SIGQUEUE_MAX    一个进程可排队信号的最大个数            _SC_SIGQUEUE_MAX
            STREAM_MAX      一个_SC_STREAM_MAX进程在任意给定时刻    _SC_STREAM_MAX
                            标准I/O流的最大个数,如果定义,必须与
                            FOPEN_MAX的值相同

            SYMLOOP_MAX     在解析路径名时,可遍历的符号链接数       _SC_SYMLOOP_MAX
            TIMER_MAX       每个进程的最大定时器个数                _SC_TIMER_MAX
            TTY_NAME_MAX    终端设备名长度,包括终止null字符         _SC_TTY_NAME_MAX
            TZNAME_MAX      时区名中的最大字节数                    _SC_TZNAME_MAX
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        pathconf() 和 fpathconf() 的限制及name参数:
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
                限制名              说明                                name参数
            FILESIZEBITS    以带符号整型值表示在指定目录中允许的    _PC_FILESIZEBITS
                            普通文件最大长度所需的最小位(bit)数     

            LINK_MAX        文件链接计数的最大值                    _PC_LINK_MAX
            MAX_CANON       终端规范输入队列的最大字节数            _PC_MAX_CANON
            MAX_INPUT       终端输入队列可用空间的字节数            _PC_MAX_INPUT
            NAME_MAX        文件名的最大字节数(不包括null)          _PC_NAME_MAX
            PATH_MAX        相对路径名的最大字节数,包括null         _PC_PATH_MAX
            PIPI_BUF        能原子的写到管道的最大字节数            _PC_PIPE_BUF
            SYMLINK_MAX     符号链接的字节数                        _PC_SYMLINK_MAX
            _POSIX_TIMESTAMP_RESOLUTION
                            文件时间戳的纳秒精度                    _PC_TIMESTAMP_RESOLUTION
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

    2、 基本系统数据类型
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
            类型                说明
        clock_t         时钟滴答计数器(进程时间)
        comp_t          压缩的时钟滴答
        dev_t           设备号(主和次)
        fd_set          文件描述符集
        fpos_t          文件位置
        gid_t           数值组ID
        ino_t           i节点编号
        mode_t          文件类型,文件创建模式
        nlink_t         目录项的链接计数
        off_t           文件长度和偏移量(带符号的)(lseek)
        pid_t           进程ID和进程组ID(带符号的)
        pthread_t       线程ID
        ptrdiff_t       两个指针相减的结果
        rlim_t          资源限制
        sig_atomic_t    能原子性的访问的数据类型
        sigset_t        信号集
        size_t          对象(如字符串)长度(不带符号的)
        ssize_t         返回字节计数的函数(不带符号的)(read write)
        time_t          日历时间的秒计数器
        uid_t           数值用户ID
        wchar_t         能表示所有不同的字符码
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

第三章、    文件I/O

    1、 函数open 和 openat
        调用open 或 openat 函数可以打开或创建一个文件

        #include <fcntl.h>
        int open(const char *path, int oflag, ... /* mode_t mode */);
        int openat(int fd, const char *path, int oflag, ... /* mode_t mode */);
        
        两个函数的返回值:
            成功,返回文件描述符
            失败,返回-1
        参数详解:
            path    -   要打开或者创建的文件名字
            oflag   -   用来说明函数的多个选项(文件的打开模式)
            fd      -   fd 参数把open和openat区别开,共有三种可能性:
                        1)  path参数指定的是绝对路径名,在这种情况下,fd参数被忽略,openat = open
                        2)  path是相对路径名,fd参数指出相对路径名在文件系统中的开始地址,fd参数是通过
                            打开相对路径名所在的目录来获取
                        3)  path指定相对路径名,fd参数具有特殊值AT_FDCWD,在这种情况下,路径名在当前工作
                            目录中获取,openat 函数在操作上与open 函数类似

            oflag 的可选值: (用下列一个或多个常量进行"或"运算来构成oflag参数)
                O_RDONLY    -   只读打开
                O_WRONLY    -   只写打开
                O_RDWR      -   读、写打开
                O_EXEC      -   只执行打开
                O_SEARCH    -   只搜索打开(应用于目录)  -   常量的目的在于在目录打开时验证它的搜索权限

                在以上5个常量中必须指定一个且只能指定一个,一下常量可选:

                O_APPEND    -   每次写时都追加到文件的末尾
                O_CLOEXEC   -   把FD_CLOEXEC常量设置为文件描述符标志
                O_CREAT     -   若此文件不存在则创建,使用此选项时,open函数需同时说明第3个参数mode
                                (openat函数需说明第4个参数mode),用mode指定该新文件的访问权限位
                O_DIRECTORY -   如果path引用的不是目录,则出错
                O_EXCL      -   如果同时指定了O_CREAT,而文件已经存在,则出错.用此可以测试一个文件是否
                                存在,如果不存在,则创建此文件,这使测试和创建两者成一个原子操作
                O_NOCTTY    -   如果path引用的是终端设备,则不将该设备分配作为此进程的控制终端
                O_NOFLLOW   -   如果path引用的是一个符号链接,则出错
                O_NONBLOCK  -   如果path引用的是一个FIFO、一个块特殊文件或一个字特殊文件,则此选项为
                                文件的本次打开操作和后续的I/O操作设置非阻塞方式
                O_SYNC      -   使每次write等待物理I/O操作完成,包括由该write操作引起的文件属性
                                更新所需的I/O
                O_TRUNC     -   如果此文件存在,而且为只写或读-写成功打开,则将其长度截断为0
                O_TTY_INIT  -   如果打开一个还未打开的终端设备,设置非标准termios参数值,使其符合
                                Single UNIX Specification.
                O_DSYNC     -   使每次write要等待物理I/O操作完成,但是如果该写操作并不影响读取
                                刚写入的数据,则不需要等待文件属性被更新 -   (与O_SYNC有区别)
                O_RSYNC     -   使每一个以文件描述符作为参数进行的read操作等待,直至所有对文件同一
                                部分挂起的写操作都完成

            openat() 函数希望解决的问题:
                1)  让线程可以使用相对路径名打开目录中的文件,而不再只能打开当前工作目录,在同一进程中
                    的所有线程共享相同的当前工作目录,因此很难让同一个进程的多个不同线程在同一时间工作
                    在不同的目录中
                2)  可以避免time-of-check-to-time-of-use(TOCTTOU)错误
                    TOCTTOU错误的基本思想是: 如果有两个基于文件的函数调用,其中第二个调用依赖于第一个
                    调用的结果,那么程序是脆弱的,因为两个调用并不是原子操作,在两个函数调用之间文件可能
                    改变了,这样也就造成了第一个调用的结果就不再有效,使得程序最终的结果是错误的.

    2、 create 函数 -   创建一个新文件
        
        #include <fcntl.h>
        int creat(const char *path, mode_t mode);

        此函数等效于 open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);
        返回值:
            成功,返回为只写打开的文件描述符
            失败,返回-1

        create的局限性在于创建的文件返回的文件描述符是以只写的方式打开的,如果对此文件有读的需求就
        必须通过open函数。

    3、 colse 函数  -   关闭一个打开的文件

        #include <unistd.h>
        int close(int fd);

        返回值:
            成功,返回0
            失败,返回-1

        关闭一个文件时,还会释放该进程加在该文件上的所有记录锁

    4、 lseek   函数    -   设置文件偏移量
        
        #include <unistd.h>
        off_t lseek(int fd, off_t offset, int whence);

        注:
            按系统默认的情况,当打开一个文件时,除非指定O_APPEND选项,否则该偏移量被设置为0
            如果文件描述符指向的是一个管道、FIFO或网络套接字时,lseek返回-1,并将errno设置为ESPIPE
        返回值:
            成功,返回新的文件偏移量
            失败,返回-1
        参数:
            若whence是 SEEK_SET, 则将该文件的偏移量设置为距文件开始处offset 个字节
            若whence是 SEEK_CUR, 则将该文件的偏移量设置为其当前值加offset,offset可为正值或负值
            若whence是 SEEK_END, 则将该文件的偏移量设置为文件长度加offset,offset可为正值或负值

            文件偏移量可大于文件的当前长度,这种情况下,对该文件的下一次写将加长该文件,并在文件中构成一个
        空洞,位于文件中但是没有写过的字节都被读为0.
            文件中的空洞并不要求在磁盘上占用存储区,具体处理方式与文件系统的实现有关,当定位超出文件尾端
        之后写时,对于新写的数据需要分配磁盘块,但是对于原文件尾端和新开始写位置之间部分不需要分配磁盘块

        od -c [filename]    -   查看文件的实际内容, -c 标志表示以字符方式打印文件内容

    5、 read 函数   -   从打开的文件中读数据

        #include <unistd.h>
        ssize_t read(int fd, void *buf, size_t nbytes);

        返回值:
            成功,读到的字节数,若已到文件末尾,返回0
            失败,返回-1
        有多种情况可能使实际读到的字节数少于预计读的字节数:
            1)  读普通文件时,在读到要求字节数之前已到达文件末尾
            2)  当从终端设备读时,通常一次最多读一行(可改变)
            3)  当从网络读时,网络中的缓冲机制可能造成返回值小于所要求读的字节数
            4)  当从管道或FIFO读时,如若管道包含的字节少于所需的数量,那么read返回实际可用字节数
            5)  当从某些面向记录的设备(如磁带)读时,一次最多返回一个记录
            6)  当一信号造成终端,而已经读了部分数据量时

    6、 write 函数  -   向打开的文件中写数据

        #include <unistd.h>
        ssize_t write(int fd, const void *buf, size_t nbytes);

        返回值:
            成功,返回已经写入的字节数
            失败,返回-1

        其返回值通常与参数nbytes的值相同,否则表示出错,write出错的一个常见原因是磁盘已经写满,或者
        超过一个给定进程的文件长度限制

    7、 进程之间文件共享机制
        1\  内核使用3种数据结构表示打开的文件,它们之间的关系决定了在文件共享方面一个进程对另一个进程
            可能产生的影响
            1)  每个进程在进程表中都有一个记录项,记录项中包含一张打开文件描述符表,每个文件描述符占用
                一项,与每个文件描述符相关联的是:
                a.  文件描述符标志(close_on_exec)
                b.  指向一个文件表项的指针
            2)  内核为所有打开的文件维持一张文件表,每个文件表项包含:
                a.  文件状态标志(读、写、添写、同步和非阻塞等)
                b.  当前文件偏移量
                c.  指向该文件v(i)节点表项的指针
            3)  每个打开的文件(或设备)都有一个v节点(v-node)结构,v节点包含了文件类型和对此文件进行各种
                操作函数的指针,对于大多数文件,v节点还包含了该文件的i节点(i-node, 索引节点).
                这些信息是在打开文件时从磁盘上读入内存的,所以文件的所有相关信息都是随时可用的,例如
                i节点包含了文件的所有者、文件长度、指向文件实际数据块在磁盘上所在位置的指针等
                (Linux 没有使用v节点,而是使用了通用的i节点结构)
        
        当两个独立进程各自打开同一文件时,两个进程各自的进程表项纪录的文件描述符会各自指向一个记录打开
        文件的文件表项,文件表项参上2),但是各自的文件表项纪录的v节点指针指向同一个v节点表项
        *即每个进程都有它自己对该文件的当前偏移量
            a.  在完成每个write后,在文件表项中的当前文件偏移量即增加所写入的字节数,如果这导致当前
                文件偏移量超出了当前文件长度,则将i节点表项中的当前文件长度设置为当前文件偏移量
            b.  如果用O_APPEND标志打开了一个文件,则相应标志也被设置到文件表项的文件状态标志中
                每次对这种具有追加写标志的文件执行写操作时,文件表项中的当前文件偏移量首先会被设置为
                i节点表项中的文件长度,这就使得每次写入的数据都追加到文件的当前尾端处
            c.  若一个文件用lseek定位到文件当前的尾端,则文件表项中的当前文件偏移量被设置为i节点表项
                中的当前文件长度
            d.  lseek函数只修改文件表项中的当前文件偏移量,不进行任何I/O操作

    8、 原子操作    -   在一个原子操作中,不允许发生内核切换进程
        1\  pread 和 pwrite 函数    -   原子性的定位(lseek)并执行I/O

            #include <unistd.h>
            ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);

            返回值:
                成功,读取到的字节数,若已到文件末尾,返回0
                失败,返回-1

            ssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset);

            返回值:
                成功,返回已经写入的字节数
                失败,返回-1

            注: 调用pread(pwrite)相当于调用lseek后调用read(write),但是pread又与这种顺序调用
                有下列重要区别:
                a.  调用pread时,无法中断其定位和读操作
                b.  不更新当前文件的偏移量

        2\  创建文件时 open(pathname, O_RDWR | O_CREAT, MODE) 为一个原子操作
            1)  先判断文件是否存在
            2） 不存在就创建并打开

    9、 dup 和 dup2 函数    -   复制一个现有的文件描述符
        
        #include <unistd.h>
        int dup(int fd);
        int dup2(int fd, int fd2);

        两个函数的返回值:
            成功,返回新的文件描述符
            失败,返回-1

        注:
            由dup返回的新文件描述符一定是当前可用文件描述符中的最小数值.
            对于dup2,可用fd2参数指定新文件描述符的值,如果fd2已经打开,则先将其关闭.
            如若fd等于fd2，则dup2返回fd2,而不关闭它,否则fd2的FD_CLOEXEC文件描述符标志就被清除,
            这样fd2在进程调用exec时是打开状态
            **这些函数返回的新文件描述符与参数fd共享同一个文件表项,所以他们共享同一文件状态标志(读、写
            追加等)以及同一文件偏移量

        每一个文件描述符都有它自己的一套文件描述符标志,新描述符的执行时关闭(close-on-exec)标志总是
        由dup函数清除.

        复制一个文件描述符的另一种方法是使用fcntl函数,实际上:
        调用
            dup(fd);
        等效于
            fcntl(fd, F_DUPFD, 0);
        调用
            dup2(fd, fd2);
        等效于
            close(fd2);
            fcntl(fd, F_DUPFD, fd2);
        在后一种情况下,dup2并不完全等同于close加上fcntl,它们之间的区别如下:
            a.  dup2是一个原子操作,而close和fcntl包括两个函数的调用,有可能在close和fcntl之间调用
                了信号捕捉函数,它可能修改文件描述符,如果不同的线程改变了文件描述符的话也会出现相同问题
            b.  dup2和fcntl有一些不同的errno

    10、    sync、fsync 和 fdatasync 函数   -   保证磁盘上实际文件系统与缓冲区中内容的一致性
    
            传统UNIX系统实现在内核中设有缓冲区高速缓存或页高速缓存,大多数磁盘I/O都是通过缓冲区进行.
        当我们向文件写入数据时,内核通常先将数据复制到缓冲区中,然后排入队列,晚些时候在写入磁盘,这种方式
        称为延时写(delayed write).
            通常当内核需要重用缓冲区来存放其他磁盘块数据时,他会把所有延迟写的数据写入到磁盘.

        #include <unistd.h>
        int fsync(int fd);
        int fdatasync(int fd);

        返回值:
            成功,返回0
            失败,返回-1

        void sync(void);

        注:
            sync 只是将所有修改过的块缓冲区排入到写队列,然后就返回,它并不等待实际写磁盘操作结束
            通常,称为update的系统守护进程周期性的调用(默认间隔30秒)sync函数,命令sync也是调用sync函数

            fsync函数只对由文件描述符fd指定的一个文件起作用,并且等待写磁盘操作结束才返回,可用于数据库
            这样的应用程序

            fdatasync函数类似fsync,但它只影响文件的数据部分,除数据外,fsync还会同步更新文件属性

    11、    fcntl 函数  -   可以改变已经打开文件的属性

        #include <fcntl.h>
        int fcntl(int fd, int cmd, ... /* int arg */);

        返回值:
            成功,则依赖于cmd
            失败,返回-1

        注:
            fcntl函数有以下5种功能:
            1)  复制一个已有的描述符(cmd = F_DUPFD 或 F_DUPFD_CLOEXEC)
            2)  获取/设置文件描述符标志(cmd = F_GETFD 或 F_SETFD)
            3)  获取/设置文件状态标志(cmd = F_GETFL 或 F_SETFL)
            4)  获取/设置异步I/O所有权(cmd = F_GETOWN 或 F_SETOWN)
            5)  获取/设置纪录锁(cmd = F_GETLK、F_SETLK 或 F_SETLKW)

        F_DUPFD -   复制文件描述符fd,新文件描述符作为函数值返回.返回尚未打开的描述符中大于或等于第3
                    个参数值中的最小值
        F_DUPFD_CLOEXEC -   复制文件描述符,设置与新描述符关联的FD_CLOEXEC文件描述符标志的值

        F_GETFD -   对应于fd的文件描述符标志作为函数值返回,当前只定义了一个文件描述符标志FD_CLOEXEC
        F_SETFD -   对于fd设置文件描述符标志,新标志值按第3个参数设置 0 在exec时不关闭,1 在exec时关闭

        F_GETFL -   对应fd的文件状态标志作为函数值返回,例如 O_RDONLY O_RDWR 等
                    获取方式要用屏蔽字O_ACCMODE取得位访问方式,然后结果与5个值比较
        F_SETFL -   将文件状态设置为第3个参数的值,可以更改的标志: O_APPEND O_NONBLOCK O_SYNC O_RSYNC
                                                                O_FSYNC 和 O_ASYNC

        F_GETOWN    -   获取当前接受SIGIO 和 SIGURG信号的进程ID或进程组ID
        F_SETOWN    -   设置接受SIGNO 和 SIGURG信号的进程ID或进程组ID,正的arg值指定一个进程ID
                                                                      负的arg绝对值指定一个进程组ID

第四章、    文件和目录
    
    1、 stat、fstat、fstatat 和 lstat 函数

        #include <sys/stat.h>
        int stat(const char *restrict pathname, struct stat *restrict buf);
        int fstat(int fd, struct stat *buf);
        int lstat(const char *restrict pathname, struct stat *restrict buf);
        int fstatat(int fd, const char *restrict pathname, struct stat *restrict bug, int flag);

        4个函数的返回值:
            成功,返回0
            失败,返回-1

        函数说明:
            stat    -   传入pathname, 函数返回与此文件有关的信息结构
            fstat   -   传入一个已打开的文件描述符,返回该文件的有关信息
            lstat   -   类似stat,但是当传入文件是一个符号链接时,lstat返回该符号链接的有关信息
            fstatat -   返回相对于当前打开目录的路径名文件统计信息
                        flag参数控制是否追踪一个符号链接,当AT_SYMLINK_NOFOLLOW标志被设置时,
                        fstatat不会追踪符号链接,直接返回符号链接本身的信息,否则在默认情况下,返回的
                        是符号链接所指向实际文件的信息.
                        fd参数的值为AT_FDCWD时,并且pathname是一个相对路径名,fstatat会计算相对于当前
                        目录的pathname参数;如果pathname是一个绝对路径,fd参数就会被忽略

                        buf参数是一个指针,它指向一个我们提供的结构
                        struct stat {
                            mode_t          st_mode;    /* file type & mode (permissions) */
                            ino_t           st_ino;     /* i_node number (serial number) */
                            dev_t           st_dev;     /* device number (file system) */
                            dev_t           st_rdev;    /* device number for special files(特殊文件) */
                            nlink_t         st_nlink;   /* number of links (链接数)*/
                            uid_t           st_uid;     /* user ID of owner */
                            gid_t           st_gid;     /* group ID of owner */
                            off_t           st_size;    /* size in bytes, for regular files
                                                            (常规文件的字节大小) */
                            struct timespec st_atime;   /* time of last access(使用) */
                            struct timespec st_mtime;   /* time of last modification(修改) */
                            struct timespec st_ctime;   /* time of last file status change(属性) */
                            blksize_t       st_blksize; /* best I/O block size(最佳I/O块大小) */
                            blkcnt_t        st_blocks;  /* number of disk blocks allocated
                                                            (分配的磁盘块数)*/
                        };
                        struct timespec {
                            time_t  tv_sec;     /* 秒 */
                            long    tv_nsec;    /* 纳秒 */
                        };

    2、 文件类型
        1)  普通文件(regular file)      -   包含文本或二进制数据的文件
        2)  目录文件(directory file)
        3)  块特殊文件(block special file)  -   这种类型的文件提供对设备(如磁盘)带缓冲的访问,
                                                每次以固定长度单位访问
        4)  字符特殊文件(character speaial file)    -   这种类型的文件提供对设备不带缓冲的访问,
                                                        每次访问长度可变.系统中所有的设备要么是
                                                        字符特殊文件,要么是块特殊文件
        5)  FIFO                    -   这种类型的文件用于进程间通信,也叫命名管道
        6)  套接字(socket)          -   这种类型的文件用于进程间的网络通信,也可用于本地
        7)  符号链接(symbolic link) -   这种类型的文件指向另一个文件   

        文件类型的信息包含在stat结构的st_mode成员中,可以用以下宏来确定文件类型,参数是st_mode:
            S_ISREG()   -   普通文件
            S_ISDIR()   -   目录文件
            S_ISCHR()   -   字符特殊文件
            S_ISBLK()   -   块特殊文件
            S_ISFIFO()  -   管道或FIFO
            S_ISLNK()   -   符号链接
            S_ISSOCK()  -   套接字

        IPC -   进程通信
        确定IPC对象类型的宏,参数是指向stat结构的指针:
            S_TYPEISMQ()    -   消息队列
            S_TYPEISSEM()   -   信号量
            S_TYPEISSHM()   -   共享存储对象

    3、 umask 函数      -   为进程设置文件模式创建屏蔽字
        
        #include <sys/stat.h>
        mode_t umask(mode_t cmask);

        返回值:
            之前的文件模式创建屏蔽字
            出错不返回
        注:
            这是少数几个没有出错返回函数中的一个
            在进程创建一个新文件或新目录时,就一定会使用文件模式创建屏蔽字.

        参数cmask 由下列列出的9个常量中的若干个按位“或”构成
                st_mode 屏蔽    -   含义
                S_IRUSR         -   用户读
                S_IWUSR         -   用户写
                s_IXUSR         -   用户执行
                S_IRGRP         -   组读
                S_IWGRP         -   组写
                S_IXGRP         -   组执行
                S_IROTH         -   其他读
                S_IWPTH         -   其他写
                S_IXOTH         -   其他执行
            想屏蔽什么权限就传入什么以上什么值.

        umask 命令打印当前shell进程的文件模式创建屏蔽字,其值是八进制表示,如下:
            屏蔽位      -       含义
            0400        -       用户读
            0200        -       用户写
            0100        -       用户执行
            0040        -       组读
            0020        -       组写
            0010        -       组执行
            0004        -       其他读
            0002        -       其他写
            0001        -       其他执行

    4、 chmod、fchmod 和 fchmodat 函数  -   更改现有文件的访问权限
        
        #include <sys/stat.h>
        int chmod(const char *pathname, mode_t mode);
        int fchmod(int fd, mode_t mode);
        int fchmodat(int fd, const char *pathname, mode_t mode, int flag);

        3个函数的返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            chmod   -   在指定的文件上操作
            fchmod  -   对已打开的文件操作
            fchmodat    -   在pathname参数为绝对路径时,fd参数取值为AT_FDCWD而pathname参数为相对路径时
                            与chmod函数无差别
                            否则fchmodat计算相对于打开目录(由fd参数指向)的pathname,
                            flag参数可以改变fchmodat的行为,当设置了AT_SYMLINK_NOFOLLOW标志时
                            函数不会追踪符号链接

    5、 chown、fchown、fchownat 和 lchown 函数  -   用于更改文件的用户ID和组ID

        #include <unistd.h>
        int chown(const char *pathname, uid_t owner, gid_t group);
        int fchown(int fd, uid_t owner, gid_t group);
        int fchownat(int fd, const char *pathname, uid_t owner, gid_t group, int flag);
        int lchown(const char *pathname, uid_t owner, gid_t group);

        4个函数的返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            两个参数owner 或 group 中的任意一个传入值是-1时,对应ID的不变.
            在传入文件是符号链接的情况下,lchown 和 fchownat(设置了AT_SYMLINK_NOFOLLOW标志)更改符号链接
            本身的所有者,不更改所指向文件

            fchown      -   改变fd参数所指向的打开文件的所有者,不能用于改变符号链接的所有者

    6、 文件长度
        stat结构成员st_size表示以字节为单位的文件长度,此字段只对普通文件、目录文件和符号链接有意义
        普通文件,文件长度可以是0,在读这种文件时,将得到文件结束(end-of-file)提示
        符号链接,文件长度是指向文件在文件名中的实际字节数 lib -> usr/lib 则lib的文件长度为7
        目录文件,文件长度通常是一个数(如16或512)的整倍数

    7、 文件截断
    
        #include <unistd.h>
        int truncate(const char *pathname, off_t length);
        int ftruncate(int fd, off_t length);

        两个函数的返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            用于截断文件,将现有的文件长度截断为length,如果该文件以前的长度大于length,则超过length以外
            的数据就不能访问了;如果文件长度小于length,文件的长度将增加,在以前文件尾端和新文件的尾端之间
            的数据将读作0,也就是有可能在文件中创建了一个空洞.

    8、 文件系统
        a.  对一个文件进行重命名操作时,不移动(在同一文件系统中)文件本身,只是创建一个指向现有i节点的
            新目录项,并删除旧的目录项   (mv命令)

        b.  任何一个不包含子目录的目录文件,它的链接计数都为2,新增一个子目录,链接计数加1
            一个链接是目录自己本身的名字,另一个是目录中的".",当新增子目录时,子目录中的".."也指向父目录

    9、 link、linkat、unlink、unlinkat 和 remove 函数

        #include <unistd.h>
        int link(const char *existingpath, const char *newpath);
        int linkat(int efd, const char *existingpath, int nfd, const char *newpath, int flag);

        两个函数的返回值:
            成功,返回0
            出错,返回-1
        
        函数说明:
            任何一个文件可以有多个目录项指向其i节点,上述函数可以创建一个指向现有文件的目录项

            参数newpath引用现有文件existingpath,如果newpath已经存在,则返回出错.只创建newpath中的
            最后一个分量,路径中的其他部分应当已经存在.

            对于linkat函数,现有文件是通过efd和existingpath参数指定的,新的路径名是通过nfd和newpath参数
            指定的.默认情况下,如果两个文件描述符中的任意一个是相对路径,那么它需要通过相对于对应的文件
            描述符进行计算;
            如果两个文件描述符中的任意一个设置为AT_FDCWD,那么相对应的路径名(相对路径)就通过相对于当前
            目录进行计算;
            如果任意一路径名是绝对路径,相对应的文件描述符参数就会被忽略.

            当现有文件是符号链接时,flag参数来控制linkat函数是创建指向现有符号链接的链接还是创建指向现有
            符号链接所指向文件的链接.设置AT_SYMLINK_FOLLOW标志,就创建指向原文件的链接.


        #include <unistd.h>
        int unlink(const char *pathname);
        int unlinkat(int fd, const char *pathname, int flag);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            删除一个现有的目录项,即链接计数减-

        *在一个文件有被任意一进程打开的情况下,即使链接计数为0,该文件也不会被立即删除
        *在删除一个文件时,内核会先检查的进程使用计数,当进程使用计数为0时,才会去检查链接计数
        *进程临时文件的做法
            创建一个临时文件,然后立即调用unlink,这样保证即使在程序崩溃的情况下,临时文件也会被删除

        #include <stdio.h>
        int remove(const char *pathname);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            解除对一个文件或目录的链接.对于文件remove的功能和unlink相同,对于目录,remove和rmdir功能相同.

    10、    rename 和 renameat 函数 -   对文件或目录进行重命名
        
        #include <stdio.h>
        int rename(const char *oldname, const char *newname);
        int renameat(int oldfd, const char *oldname, int newfd, const char *newname);

        返回值:
            成功,返回0
            出错,返回-1

        注:
            a.  如果oldname指的是一个文件(文件或符号链接)而不是目录,在这种情况下,如果newname已经存在,
                而且不是一个目录,则先将该文件删除然后将oldname重命名为newname

            b.  如果oldname指的是一个目录,如果newname已经存在,则它必须引用一个目录,而且该目录应当是空
                目录,如果newname存在,而且是一个空目录,则先将其删除,然后将oldname重命名为newname

            c.  如果oldname或newname引用符号链接,则处理的是符号链接本身,而不是它引用的文件

            d.  不能对.和..重命名

            e.  如果oldname 和 newname 引用同一文件,则函数不做任何改动而成功返回.

    11、    符号链接(软链接)
        符号链接是对一个文件的间接指针,硬链接直接指向文件的i节点.
        a.  硬链接通常要求链接和文件位于同一文件系统中.
        b.  只有超级用户才能创建指向目录的硬链接
        c.  符号链接不受文件系统的限制,且任何用户都可以创建指向目录的符号链接
        d.  符号链接一般用于将一个文件或整个目录结构移到系统中另一个位置

    12、    创建和读取符号链接

        #include <unistd.h>
        int symlink(const char *actualpath, const char *sympath);
        int symlinkat(const char *actualpath, int fd, const char *sympath);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            上述两个函数可以用来创建一个符号链接.
            函数创建了一个指向actualpath的新目录项sympath,在创建此符号链接时,并不要求actualpath已经存在
            并且actualpath和sympath并不需要位于同一个文件系统中.

        #include <unistd.h>
        ssize_t readlink(const char *restrict pathname, char *restrict buf, size_t bufsize);
        ssize_t readlinkat(int fd, const char *restrict pathname, char *restrict buf, size_t bufsize);

        返回值:
            成功,返回读取的字节数
            出错,返回-1

        函数说明:
            因为open函数会追踪符号链接,所以需要一种方法可以打开链接本身,并读取链接中的名字.
            两个函数组合了open、read和close的所有操作,如果函数执行成功,则返回读入buf的字节数

    13、    文件的时间
        每个文件维护了3个时间字段:
        st_atime    -   文件数据的最后访问时间,如read函数, ls -u查看
        st_mtime    -   文件数据的最后修改时间,如write函数, ls 默认显示
        st_ctime    -   i节点状态的最后更改时间(文件属性的修改时间),如chmod、chown, ls -c 可查看

    14、    futimens、utimensat 和 utimes 函数

        #include <sys/stat.h>
        int futimens(int fd, const struct timespec times[2]);
        int utimensat(int fd, const char *path, const struct timespec times[2], int flag);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            用于修改文件的访问时间的最后更改时间,所用数据结构是与stat函数族相同的timespec结构
            参数times数组第一个元素包含访问时间,第二个元素包含最后更改时间,这两个时间值是日历时间,
            自特定时间(1970年1月1日00:00:00)以来所经过的秒数,不足秒用纳秒表示
            tiems参数传入值按下列4种方式指定:
            a.  如果times参数是一个空指针,则修改访问时间和最后更改时间为当前时间
            b.  如果times参数指向两个timespec结构的数组,任一数组元素的tv_nsec字段值为UTIME_NOW,则修改
                相对应的时间戳为当前时间,忽略相应的tv_sec字段
            c.  如果times参数指向两个timespec结构的数组,任一数组元素的tv_nsec字段值为UTIME_OMIT,则
                相对应的时间戳保持不变,忽略相应的tv_sec字段
            d.  如果times参数指向两个timespec结构的数组,且tv_nsec字段既不是UTIME_NOW也不是UTIME_OMIT,
                则修改对应时间戳为相应的tv_sec 和 tv_nsec 字段的值

            futimens 函数需要打开文件来更改它的时间,utimensat函数提供了一种使用文件名更改文件时间的方法
            utimensat 函数的flag参数可用于进一步修改默认行为,如果设置了AT_SYMLINK_NOFOLLOW标志,则符号
            链接本身的时间就会被修改(如果路径名指向符号链接),默认的行为是追踪符号链接,并把文件的时间修改
            为符号链接的时间.

        #include <sys/time.h>
        int utimes(const char *pathname, const struct timeval times[2]);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            utimes参数包含的两个时间戳是struct timeval结构,使用秒和微妙表示的
            struct timeval {
                time_t tv_sec;  /* seconds */
                long tv_usec;   /* microseconds */
            };
            状态时间不能用指定值来修改,当调用utimes函数时,文件的状态时间会被自动更新

    15、    mkdir、mkdirat 和 rmdir 函数

        #include <sys/stat.h>
        int mkdir(const char *pathname, mode_t mode);
        int mkdirat(int fd, const char *pathname, mode_t mode);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            上述两函数可用于创建目录,所指定的文件访问权限mode由进程的文件模式创建屏蔽字修改

        #include <unistd.h>
        int rmdir(const char *pathname);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            用rmdir可以删除一个空目录,空目录是只包含.和..这两项的目录

    16、    读目录

        #include <dirent.h>
        DIR *opendir(const char *pathname);
        DIR *fdopendir(int fd);

        返回值:
            成功,返回指针
            出错,返回NULL
        
        struct dirent *readdir(DIR *dp);

        返回值:
            成功,返回指针
            出错或者在目录尾,返回NULL

        void rewinddir(DIR *dp);
        int closedir(DIR *dp);

        返回值:
            成功,返回0
            出错,返回-1

        long telldir(DIR *dp);

        返回值:
            返回与dp关联的目录中的当前位置

        void seekdir(DIR *dp, long loc);

        函数说明:
            fdopendir   -   可以把打开的文件描述符转换成目录处理函数需要的DIR结构
            readdir     -   读取目录中的第一个目录项

    17、    chdir、fchdir 和 getcwd 函数
        每个进程都有一个工作目录,此目录是搜索所有相对路径名的起点,当前工作目录是进程的一个属性.
        当用户登录到unix系统时,其当前目录通常是/etc/passwd中该用户登录项的第6个字段-用户的起始目录.

        #include <unistd.h>
        int chdir(const char *pathname);
        int fchdir(int fd);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            进程调用chdir或fchdir函数可以更改当前的工作目录.
            这两个函数中,分别用pathname或打开的文件描述符来指定新的当前工作目录

        #include <unistd.h>
        char *getcwd(char *buf, size_t size);

        返回值:
            成功,返回buf
            出错,返回NULL

        函数说明:
            返回进程当前工作目录完整的路径名.
            参数buf     -   缓冲区地址
            参数size    -   缓冲区长度

        注:
            chdir 追踪符号链接,但是getcwd不追踪符号链接
            当一个应用程序需要在文件系统中返回到它工作的出发点时,在更换工作目录之前先调用getcwd保存
            当前工作目录路径,在完成处理后把它传送个chdir,这样就返回到进程的出发点.

    18、    设备特殊文件
        st_dev  -   存储【非】字特殊文件和块特殊文件的主、次设备号
        st_rdev -   存储字特殊文件和块特殊文件次设备号

        每个文件系统所在的存储设备都是由主、次设备号表示.
        主设备号标识设备的驱动程序,有时编码为与其通信的外设备
        次设备号标识特定子设备.
        例如在同一磁盘驱动器上的各个文件系统通常具有相同的主设备号,但是次设备号却不同

        设备号的获取方法:
            major 宏,来访问主设备号     -   major(statbuf.st_dev) minor(statbuf.st_dev)
            minor 宏,来访问次设备号     -   major(statbuf.st_rdev) minor(statbuf.st_rdev)

        系统中也每个文件名关联的st_dev值是文件系统的设备号,该文件系统包含了这一文件名以及其对应i节点

        只有字符特殊文件和块特殊文件才有st_rdev值,此值包含实际设备的设备号

第五章、    标准I/O库

    1、 流和FILE对象
        对于ASCII字符集,一个字符用一个字节表示
        对于国际字符集,一个字符可以用多个字节表示
        标准I/O文件流可用于单字节或多字节("宽")字符集
        I/O函数分为多字节I/O函数(<wchar.h>)和单字节I/O函数

        fopen   -   打开一个流
        freopen -   清除一个流的定向
        fwide   -   设置或返回一个流的定向


        #include <stdio.h>
        #include <wchar.h>
        int fwide(FILE *fp, int mode);

        返回值:
            若流是宽定向的,返回正值
            若流是字节定向的,返回负值
            若流是未定向的,返回0

        函数说明:
            fwide函数可用于设置流的定向
            根据mode参数的不同值,fwide函数执行不同的工作:
                a.  mode参数值为负,fwide将试图将指定的流设置为字节定向的
                b.  mode参数值为正,fwide将试图将指定的流设置为宽定向的
                c.  mode参数值为0,fwide将返回指定流的定向方式

        注:
            fwide并不改变已定向流的定向,且无出错返回,使用时应先清除errno,然后调用后检查errno来判读是否成功

    2、 标准输入、标准输出和标准错误
                                            对应的文件指针
        STDIN_FILENO    -   标准输入    -       stdin
        STDOUT_FILENO   -   标准输出    -       stdout
        STDERR_FILENO   -   标准错误    -       stderr

    3、 缓冲
        标准I/O库提供缓冲的目的是尽可能的减少read和write的调用次数
        标准I/O提供了以下3种类型的缓冲:
        1)  全缓冲  -   在填满标准I/O的缓冲区后才进行实际I/O操作,对于驻留在磁盘上的文件通常是全缓冲的
                        在一个流上执行第一次I/O操作时,相关标准I/O函数通常调用malloc来获得缓冲区
                        调用fflush函数可以冲洗一个流,将缓冲区的数据冲洗到磁盘上

        2)  行缓冲  -   当在输入和输出中遇到换行符时,才执行实际的I/O操作,通常当流涉及到一个终端时,使用
                        行缓冲.

        3)  不带缓冲

        注:
            (系统默认)
            a.  标准错误流stderr通常是不带缓冲的
            b.  若是指向终端设备的流,则是行缓冲的;否则是全缓冲的

        #include <stdio.h>
        void setbuf(FILE *restrict fd, char *restrict buf);
        int setvbuf(FILE *restrict fd, char *restrict buf, int mode, size_t size);
    
        返回值:
            成功,返回0
            出错,返回非0

        函数说明:
            用于修改系统默认的流的缓冲类型
            这些函数一定要在流被打开以后使用

            setbuf  -   用以打开或关闭缓冲机制,参数buf指向一个长度为BUFSIZE的缓冲区(该常量定义
                        在<stdio.h>中).
                        关闭缓冲可以将buf设置为NULL

            setvbuf -   可以精确的设置缓冲类型,mode参数来说明:
                        _IOFBF  -   全缓冲
                        _IOLBF  -   行缓冲
                        _IONBF  -   不带缓冲
                        指定一个不带缓冲的流时,忽略buf和size参数
                        指定全缓冲或行缓冲时,buf和size可选择的指定一个缓冲区的及其长度
                        若指定流是带缓冲的,而buf传入NULL,则标准I/O库将自动的为该流分配适当长度的缓冲区,
                        通常是常量BUFSIZE的值
        
        #include <stdio.h>
        int fflush(FILE *fp);

        返回值:
            成功,返回0
            出错,返回EOF

        函数说明:
            强制冲洗一个流,此函数使该流所有未写的数据都被传送至内核
            当参数fp传入NULL时,将导致所有的输出流被冲洗.

    4、 打开流

        #include <stdio.h>
        FILE *fopen(const char *restrict pathname, const char *restrict type);
        FILE *freopen(const char *restrict pathname, const char *restrict type, FILE *restrict fp);
        FILE *fdopen(int fd, const char *type);

        返回值:
            成功,返回文件指针
            出错,返回NULL

        函数说明:
            以上3个函数用于打开一个标准I/O流
            3个函数的区别:
                1)  fopen函数打开路径名为pathname的一个指定的文件
                2)  freopen函数在一个指定的流上打开一个指定的文件,如果该流已经打开,则先关闭该流;
                    若流已经定向,则使用freopen清除该定向,此函数一般用于将一个指定的文件打开为一个
                    预定义的流:标准输入、标准输出或标准错误
                3)  fdopen函数取一个已有的文件描述符,并使一个标准的I/O流与该描述符相结合.
                    此函数常用于由创建管道和网络通信通道函数返回的文件描述符,因为这些特殊类型的文件不能
                    用标准I/O函数fopen打开.

        #include <stdio.h>
        int fclose(FILE *fp);

        返回值:
            成功,返回0
            出错,返回EOF

        函数说明:
            关闭一个打开的流

    5、 读和写流
        3种不同类型的非格式化I/O
            a.  每次一个字符的I/O
            b.  每次一行的I/O   -   fgets() fputs()
            c.  直接I/O     -   fread() fwrite()

        1\  输入函数

            #include <stdio.h>
            int getc(FILE *fp);
            int fgetc(FILE *fp);
            int getchar(voide);

            返回值:
                成功,返回下一个字符
                到达文件尾端或出错,返回EOF

            函数说明:
                上述函数用于一次读一个字符
                getchar = getc(stdin);
                注:
                    1)  getc的参数不应当是具有副作用的表达式,因为它可能被计算多次
                    2)  因为fgetc一定是个函数,所以可以得倒其地址,这就允许将fgetc的地址作为一个参数
                        传给另一个函数
                    3)  调用fgetc所需的时间可能比调用getc要长,因为调用函数所需时间通常长于宏

                    以上函数在到达文件末尾和出错时都将返回-1,为了区别这两种不同的情况,必须调用ferror 或
                    feof.
            #include <stdio.h>
            int ferror(FILE *fp);
            int feof(FILE *fp);
            void clearerr(FILE *fp);

            返回值:
                条件为真,返回非0
                否则,返回0

            函数说明:
                在大多数实现中,为每个流在FILE对象中维护了两个标志:
                a.  出错标志
                b.  文件结束标志
                调用clearerr可以清除这两个标志

            #include <stdio.h>
            int ungetc(int c, FILE *fp);

            返回值:
                成功,返回c
                出错,返回EOF

            函数说明:
                从流中读取数据以后再将字符压送回流中,压送回流中的字符又可以从流中读出,但读出的字符顺序与
                压送回的顺序相反.
                回送的字符不一定是上次读取到的字符,不能回送EOF

        2\  输出函数

            #include <stdio.h>
            int putc(int c, FILE *fp);
            int fputc(int c, FILE *fp);
            int putchar(int c);

            返回值:
                成功,返回c
                出错,返回EOF

            putchar(c) 等同于 putc(c, stdout);


    6、 每次一行I/O

        #include <stdio.h>
        char *fgets(char *restrict buf, int n, FILE *restrict fp);
        char *gets(char *buf);

        返回值:
            成功,返回buf
            若到达文件末尾或出错,返回NULL

        函数说明:
            这两个函数提供每次输入一行的功能
            这两个函数都指定了缓冲区的地址,读入的行将被送入其中,fgets是从标准输入读,而fgets是从指定的流读
            
            fgets   -   必须指定缓冲区的长度n,当超过缓冲区大小时,将返回一个不完整的行,
                        该缓冲区总是以字符null字节结尾,会将换行符存入缓冲区
            gets    -   是一个不被推荐的函数,其问题是调用者在使用gets时不能指定缓冲区的长度,这样有可能
                        造成缓冲区溢出,不会将换行符存入缓冲区

        #include <stdio.h>
        int fputs(const char *restrict str, FILE *restrict fp);
        int puts(const char *str);

        返回值:
            成功,返回非负值
            出错,返回EOF

        函数说明:
            提供一次输出一行的功能
            fputs   -   将一个以null字节终止的字符串写到指定流,尾端的终止符null不写出
            puts    -   将一个以null字节终止的字符串写到标准输出,终止符不写出,
                        但是puts会额外输出一个换行符

    7、 标准I/O的效率
        单字节读取时,fgetc要比直接调用read快,因为系统调用更加的耗费时间
        fgts实现方式使用汇编函数memccpy,比起一次读取一字节要快的多

    8、 二进制I/O   -   一次读写一个结构

        #include <stdio.h>
        size_t fread(void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);
        size_t fwrite(const void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);

        返回值:
            读或写的对象数

        函数说明:
            按结构大小读写或按块读写
            参数size应当是该结构的sizeof,参数nobj应是该数组中的元素个数

    9、 定位流
        
        有3种方法定位标准I/O流
        1)  ftell 和 fseek     函数 -   记录文件位置的数值为一个长整型,不能超过取值范围
        2)  ftello 和 fseeko   函数 -   使用off_t数据类型代替了长整型
        3)  fgetpos 和 fsetpos 函数 -   使用抽象数据类型fpos_t记录文件位置

        #include <stdio.h>
        long ftell(FILE *fp);       -   成功,返回当前文件位置指示;出错,返回-1L
        int fseek(FILE *fp, long offset, int whence);   -   成功,返回0;出错,返回-1
        void rewind(FILE *fp);
        off_t ftello(FILE *fp);     -   成功,返回当前文件位置;出错,返回(off_t)-1
        int fseeko(FILE *fp, off_t offset, int whence);     -   成功,返回0;出错,返回-1
        
        int fgetpos(FILE *restrict fp, fpos_t *restrict pos);
        int fsetpos(FILE *fp, const fpos_t *pos);

        返回值:
            成功,返回0
            出错,返回非0

    10、    格式化I/O
        1\  格式化输出

            #include <stdio.h>
            int printf(const char *restrict format, ...);
            int fprintf(FILE *restrict fp, const char *restrict format, ...);
            int dprintf(int fd, const char *restrict format, ...);

            返回值:
                成功,返回输出的字符数
                出错,返回负值

            int sprintf(char *restrict buf, const char *restrict format, ...);
            int snprintf(char *restrict buf, size_t n, const char *restrict format, ...);
    
            返回值:
                成功,返回存入数组的字符数
                出错,返回负值
    
            函数说明:
                fprintf -   输出到指定流
                dprintf -   输出到指定文件描述符
                sprintf -   将格式化的字符串存入数组buf(字符串)中,会在字符串尾端添加一个null字符
                            且有可能造成缓冲区溢出
                snprintf-   解决sprintf可能造成的缓冲区溢出问题,缓冲区的长度作为一个显示参数传入,
                            当字符串超出缓冲区长度时,超出部分就会被丢弃

                格式说明% 
                    %[flags][fldwidth][precision][lenmodifier]convtype
                    flages :
                        ,       -   将整数按千位分组字符
                        -       -   在字段内左对齐
                        +       -   总是显示带符号转换的正负号
                        (空格)  -   如果第一个字符不是正负号,则在前面加上一个空格
                        #       -   指定另一种转换形式(例如转十六进制,加上0x前缀)
                        0       -   添加前导0(代替空格)进行填充
                    
                    fldwidth    -   说明最小字段宽度,转换后参数字符若小于宽度,则多余位置用空格填充

                    precision   -   说明整型抓换后最小输出数字位数、浮点数转换后的小数点后位数、字符
                                    串转换后最大字节数.精度是一个(.),其后跟随一个可选的非负十进制数或
                                    一个星号(*)
            
                    lenmodifier :   说明参数长度,如下
                        hh  -   将相应的参数按signed 或 unsigned char 类型输出
                        h   -   将相应的参数按signed 或 unsigned short 类型输出
                        l   -   将相应的参数按signed 或 unsigned long 或宽字符类型输出
                        ll  -   将相应的参数按signed 或 unsigned longlong类型输出
                        j   -   intmax_t 或 uintmax_t
                        z   -   size_t
                        t   -   ptrdiff_t
                        L   -   long double

                    convtype    :   必选
                        d、i    -   有符号十进制
                        o       -   无符号八进制
                        u       -   无符号十进制
                        x、X    -   无符号十六进制
                        f、F    -   双精度浮点数
                        e、E    -   指数格式双精度浮点数
                        g、G    -   根据转换后的值解释为f、F、e或E
                        a、A    -   十六进制指数格式双精度浮点数
                        c       -   字符
                        s       -   字符串
                        p       -   指向void的指针
                        %       -   %字符
                        C       -   宽字符,等效于lc
                        S       -   宽字符串,等效于ls
                        n       -   到目前为止,此printf调用输出的字符数将被写入到指针所
                                    指向的带符号整型中
                        
            5中printf族的变体:
            #include <stdarg.h>
            #include <stdio.h>
            int vprintf(const char *restrict format, va_list arg);
            int vfprintf(FILE *restrict fp, const char *restrict format, va_list arg);
            int vdprintf(int fd, const char *restrict format, va_list arg);

            返回值:
                成功,返回输出字符数
                出错,返回负值

            int vsprintf(char *restrict buf, const char *restrict format, va_list arg);
            int vsnprintf(char *restrict buf, size_t n, const char *restrict format, va_list arg);

            返回值:
                成功,返回存入数组的字符数
                出错,返回负值

        2\  格式化输入
            
            #include <stdio.h>
            int scanf(const char *restrict format, ...);
            int fscanf(FILE *restrict fp, const char *restrict format, ...);
            int sscanf(const char *restrict buf, const char *restrict format, ...);

            返回值:
                成功,赋值的输入项数
                输入出错或在任一转换前已达到文件尾端,返回EOF

    11、    实现细节

        #include <stdio.h>
        int fileno(FILE *fp);   -   返回与该流相关联的文件描述符

        见Chapter_5 printStdioCached.c 测试程序

    12、    临时文件

        #include <stdio.h>
        char *tmpnam(char *ptr);    -   返回指向唯一路径名的指针
        FILE *tmpfile(void);        -   成功,返回文件指针;出错,返回NULL

        函数说明:
            用来创建临时文件.
            tmpnam  -   长生一个与现有文件名不同的一个有效路径名字符串,每次调用都会产生一个不同的
                        路径名,最多调用次数是TMP_MAX,定义在<stdio.h>中

            tmpfile -   创建一个临时二进制文件(类型wb+),在关闭该文件或程序结束时将自动删除这种文件.

        见Chapter_5 tmpfile.c 测试程序
        警告：the use of `tmpnam' is dangerous, better use `mkstemp'

        tmpfile函数通常是先调用tmpnam产生一个唯一的路径名,然后用该路径名创建一个文件,并立即unlink它

        #include <stdio.h>
        char *mkdtemp(char *template);  -   成功,返回指向目录名的指针;出错,返回NULL
        int mkstemp(char *template);    -   成功,返回文件描述符;出错,返回-1

        函数说明:
            mkdtemp -   创建了一个目录,该目录有一个唯一的名字;
            mkstemp -   创建了一个文件,该文件有一个唯一的名字,创建并打开文件
        注:
            mkstemp创建的临时文件不会自动删除
            使用tmpnam 和 tempnam有一个缺点,在返回唯一的路径名和用该名字创建文件之间有一个时间窗口
            在这个时间窗口内,另一个进程可以使用相同的名字创建文件,谨慎使用
            tmpfile和mkstemp函数不会存在这个问题.
        见Chapter_5 mkstemp.c 测试程序

    13、    内存流  -   使用FILE指针访问,没有底层文件,通过缓存和主存之间传送字节,类似文件流

        内存流的创建,3个函数

        #include <stdio.h>
        FILE *fmemopen(void *restrict buf, size_t size, const char *restrict type);

        返回值:
            成功,返回流指针
            出错,返回NULL

        函数说明:
            fmemopem 函数允许调用者提供缓冲区用于内存流:
                buf参数指向缓冲区的开始位置,
                size参数指定了缓冲区大小的字节数.
                如果buf参数为空,fmemopen函数分配size字节数的缓冲区,这种情况下,流关闭时,缓冲区会自动释放
                type参数控制如何使用流:
                    r/rb    -   为读而打开
                    w/wb    -   为写而打开
                    a/ab    -   追加
                    r+/rb+  -   读写
                    w+/wb+  -   把文件截断为0,读写
                    a+/ab+  -   追加,读写
            注:
                任何时候需要增加流缓冲区中数据量以及调用fclose、fflush、fseek、fseeko以及fsetpos时,
                都会在当前位置写入一个null字节.

        其他两个函数:
        #include <stdio.h>
        FILE *open_memstream(char **bufp, size_t *sizep);
        #include <wchar.h>
        FILE *open_wmemstream(wchar_t **bufp, size_t *sizep);

        返回值:
            成功,返回流指针
            出错,返回NULL

        函数说明:
            open_memstream 函数创建的流是面向字节的
            open_wmemstream函数创建的流是面向宽字节的
            这两个函数与fmemopen的不同在于:
                a.  创建的流只能写打开
                b.  不能指定自己的缓冲区,但是可以分别通过bufp和sizep参数访问缓冲区地址和大小
                c.  关闭流后需要自行释放缓冲区
                d.  对流添加字节会增加缓冲区的大小
