第一章、UNIX基础知识
    1、 程序和进程
        1\  程序
            程序(program)是一个存储在磁盘上某个目录中的可执行文件,内核使用exec函数(7个exec
            函数之一),将程序读入到内存,并执行程序.
        2\  进程
            程序的执行实例被称为进程.

    2、 出错处理
        打印出错信息的函数
        1)  #include <string.h> -   char *strerror(int errnum);
            返回值: 指向错误信息字符串的指针

        2） #include <stdio.h>  -   void perror(const char *msg);
            perror 函数基于errno的当前值,在标准错误上产生一条出错信息
            它首先输出由msg指向的字符串,然后是一个冒号一个空格,接着是对用于errno值的错误信息

    3、 用户标识
        1\  用户ID
            通常每个用户有一个唯一的用户ID
            用户ID为0的用户为root用户或超级用户superuser
            如果一个进程具有超级用户特权,则大多数文件权限检查都不在进行

        2\  组ID
            对于磁盘上的每个文件,文件系统都存储该文件所有者的用户ID和组ID,存储这两个值需要4个字节
            如果使用完整的ASCII登录名和组名,则需要更多的磁盘空间,另外,在检验权限期间,比较字符串较之
            比较整型数更消耗时间.

        3\  附属组ID
            允许一个用户至多属于16个其他的组

    4、 信号(signal)
        信号用于通知进程发生了某种情况,进程有以下3种处理信号的方式
        1)  忽略信号,有些信号表示硬件异常,例如除以0或访问进程地址空间以外的存储单元等,
            因为这些异常产生的后果不确定,所以不推荐使用这种处理方式
        2)  按系统默认方式处理,大多数信号的默认处理方式是终止该进程
        3)  提供一个函数,信号发生时调用该函数,这被称为捕捉该信号

    5、 时间值
        1\  日历时间
            time_t
        2\  进程时间(CPU时间)
            clock_t
            UNIX系统为一个进程维护了3个进程时间值:
            时钟时间        -   墙上时钟时间,它是进程运行的时间总量
            用户CPU时间     -   是执行用户指令所用的时间量
            系统CPU时间     -   是为该进程执行内核程序所经历的时间
            time 命令查看进程时间

    6、 系统调用和库函数
        1)  所有的操作系统都提供多种服务的入口点,由此程序向内核请求服务.各种版本的UNIX实现都提供
            良好定义、数量有限、直接进入内核的入口点,这些入口点被称为系统调用.

第二章、    UNIX标准及实现
    1、 sysconf、pathconf和fpathconf 函数   -   获取系统的运行时限制值
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        #include <unistd.h>
        long sysconf(int name);
        long pathconf(const char *pathname, int name);
        log  fpathconf(int fd, int name);
                                    3个函数返回值:成功返回相应值,出错,返回-1
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        后面两个函数的差别是:一个用路径名作为其参数,另一个则取文件描述符做为参数.
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        sysconf(int name) name的可传入值:
                限制名                  说明                        name参数
            ARG_MAX         exec函数的参数最大长度(字节)            _SC_ARG_MAX
            ATEXIT_MAX      可用atexit函数登记的最大函数个数        _SC_ATEXIT_MAX
            CHILD_MAX       每个实际用户ID的最大进程数              _SC_CHILD_MAX
            时钟滴答/秒     每秒时钟的滴答数                        _SC_CLK_TCK
            COLL_WEIGHTS_MAX在本地定义文件中可以赋予LC_COLLATE
                            顺序关键字项的最大权重数                _SC_COLL_WEIGHTS_MAX
            DELAYTIMER_MAX  定时器最大超限运行次数                  _SC_DELAYTIMER_MAX
            HOST_NAME_MAX   gethostname函数返回的主机名最大长度     _SC_HOST_NAME_MAX
            IOC_MAX         readv或writev函数可以使用最多的
                            iovec结构的个数                         _SC_IOV_MAX

            LINE_MAX        实用程序输入行的最大长度                _SC_LINE_MAX
            LOGIN_NAME_MAX  登录名的最大长度                        _SC_LOGIN_NAME_MAX
            NGROUPS_MAX     每个进程同时添加的最大进程组ID数        _SC_NGROUPS_MAX
            OPEN_MAX        每个进程最大打开的文件数                _SC_OPEN_MAX
            PAGESIZE        系统存储页长度(字节数)                  _SC_PAGESIZE
            PAGE_SIZE       系统存储页长度(字节数)                  _SC_PAGE_SIZE
            RE_DUP_MAX      regexec和regcomp允许的正则重复次数      _SC_RE_DUP_MAX
            RTSIG_MAX       为应用程序预留的实时信号的最大个数      _SC_RTSIG_MAX
            SEM_NSEMS_MAX   一个进程可使用的信号量最大个数          _SC_SEM_NSEMS_MAX
            SEM_VALUE_MAX   信号量的最大值                          _SC_SEM_VALUE_MAX
            SIGQUEUE_MAX    一个进程可排队信号的最大个数            _SC_SIGQUEUE_MAX
            STREAM_MAX      一个_SC_STREAM_MAX进程在任意给定时刻    _SC_STREAM_MAX
                            标准I/O流的最大个数,如果定义,必须与
                            FOPEN_MAX的值相同

            SYMLOOP_MAX     在解析路径名时,可遍历的符号链接数       _SC_SYMLOOP_MAX
            TIMER_MAX       每个进程的最大定时器个数                _SC_TIMER_MAX
            TTY_NAME_MAX    终端设备名长度,包括终止null字符         _SC_TTY_NAME_MAX
            TZNAME_MAX      时区名中的最大字节数                    _SC_TZNAME_MAX
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        pathconf() 和 fpathconf() 的限制及name参数:
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
                限制名              说明                                name参数
            FILESIZEBITS    以带符号整型值表示在指定目录中允许的    _PC_FILESIZEBITS
                            普通文件最大长度所需的最小位(bit)数     

            LINK_MAX        文件链接计数的最大值                    _PC_LINK_MAX
            MAX_CANON       终端规范输入队列的最大字节数            _PC_MAX_CANON
            MAX_INPUT       终端输入队列可用空间的字节数            _PC_MAX_INPUT
            NAME_MAX        文件名的最大字节数(不包括null)          _PC_NAME_MAX
            PATH_MAX        相对路径名的最大字节数,包括null         _PC_PATH_MAX
            PIPI_BUF        能原子的写到管道的最大字节数            _PC_PIPE_BUF
            SYMLINK_MAX     符号链接的字节数                        _PC_SYMLINK_MAX
            _POSIX_TIMESTAMP_RESOLUTION
                            文件时间戳的纳秒精度                    _PC_TIMESTAMP_RESOLUTION
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

    2、 基本系统数据类型
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
            类型                说明
        clock_t         时钟滴答计数器(进程时间)
        comp_t          压缩的时钟滴答
        dev_t           设备号(主和次)
        fd_set          文件描述符集
        fpos_t          文件位置
        gid_t           数值组ID
        ino_t           i节点编号
        mode_t          文件类型,文件创建模式
        nlink_t         目录项的链接计数
        off_t           文件长度和偏移量(带符号的)(lseek)
        pid_t           进程ID和进程组ID(带符号的)
        pthread_t       线程ID
        ptrdiff_t       两个指针相减的结果
        rlim_t          资源限制
        sig_atomic_t    能原子性的访问的数据类型
        sigset_t        信号集
        size_t          对象(如字符串)长度(不带符号的)
        ssize_t         返回字节计数的函数(不带符号的)(read write)
        time_t          日历时间的秒计数器
        uid_t           数值用户ID
        wchar_t         能表示所有不同的字符码
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

第三章、    文件I/O

    1、 函数open 和 openat
        调用open 或 openat 函数可以打开或创建一个文件

        #include <fcntl.h>
        int open(const char *path, int oflag, ... /* mode_t mode */);
        int openat(int fd, const char *path, int oflag, ... /* mode_t mode */);
        
        两个函数的返回值:
            成功,返回文件描述符
            失败,返回-1
        参数详解:
            path    -   要打开或者创建的文件名字
            oflag   -   用来说明函数的多个选项(文件的打开模式)
            fd      -   fd 参数把open和openat区别开,共有三种可能性:
                        1)  path参数指定的是绝对路径名,在这种情况下,fd参数被忽略,openat = open
                        2)  path是相对路径名,fd参数指出相对路径名在文件系统中的开始地址,fd参数是通过
                            打开相对路径名所在的目录来获取
                        3)  path指定相对路径名,fd参数具有特殊值AT_FDCWD,在这种情况下,路径名在当前工作
                            目录中获取,openat 函数在操作上与open 函数类似

            oflag 的可选值: (用下列一个或多个常量进行"或"运算来构成oflag参数)
                O_RDONLY    -   只读打开
                O_WRONLY    -   只写打开
                O_RDWR      -   读、写打开
                O_EXEC      -   只执行打开
                O_SEARCH    -   只搜索打开(应用于目录)  -   常量的目的在于在目录打开时验证它的搜索权限

                在以上5个常量中必须指定一个且只能指定一个,一下常量可选:

                O_APPEND    -   每次写时都追加到文件的末尾
                O_CLOEXEC   -   把FD_CLOEXEC常量设置为文件描述符标志
                O_CREAT     -   若此文件不存在则创建,使用此选项时,open函数需同时说明第3个参数mode
                                (openat函数需说明第4个参数mode),用mode指定该新文件的访问权限位
                O_DIRECTORY -   如果path引用的不是目录,则出错
                O_EXCL      -   如果同时指定了O_CREAT,而文件已经存在,则出错.用此可以测试一个文件是否
                                存在,如果不存在,则创建此文件,这使测试和创建两者成一个原子操作
                O_NOCTTY    -   如果path引用的是终端设备,则不将该设备分配作为此进程的控制终端
                O_NOFLLOW   -   如果path引用的是一个符号链接,则出错
                O_NONBLOCK  -   如果path引用的是一个FIFO、一个块特殊文件或一个字特殊文件,则此选项为
                                文件的本次打开操作和后续的I/O操作设置非阻塞方式
                O_SYNC      -   使每次write等待物理I/O操作完成,包括由该write操作引起的文件属性
                                更新所需的I/O
                O_TRUNC     -   如果此文件存在,而且为只写或读-写成功打开,则将其长度截断为0
                O_TTY_INIT  -   如果打开一个还未打开的终端设备,设置非标准termios参数值,使其符合
                                Single UNIX Specification.
                O_DSYNC     -   使每次write要等待物理I/O操作完成,但是如果该写操作并不影响读取
                                刚写入的数据,则不需要等待文件属性被更新 -   (与O_SYNC有区别)
                O_RSYNC     -   使每一个以文件描述符作为参数进行的read操作等待,直至所有对文件同一
                                部分挂起的写操作都完成

            openat() 函数希望解决的问题:
                1)  让线程可以使用相对路径名打开目录中的文件,而不再只能打开当前工作目录,在同一进程中
                    的所以线程共享相同的当前工作目录,因此很难让同一个进程的多个不同线程在同一时间工作
                    在不同的目录中
                2)  可以避免time-of-check-to-time-of-use(TOCTTOU)错误
                    TOCTTOU错误的基本思想是: 如果有两个基于文件的函数调用,其中第二个调用依赖于第一个
                    调用的结果,那么程序是脆弱的,因为两个调用并不是原子操作,在两个函数调用之间文件可能
                    改变了,这样也就造成了第一个调用的结果就不再有效,使得程序最终的结果是错误的.

    2、 create 函数 -   创建一个新文件
        
        #include <fcntl.h>
        int creat(const char *path, mode_t mode);

        此函数等效于 open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);
        返回值:
            成功,返回为只写打开的文件描述符
            失败,返回-1

        create的局限性在于创建的文件返回的文件描述符是以只写的方式打开的,如果对此文件有读的需求就
        必须通过open函数。

    3、 colse 函数  -   关闭一个打开的文件

        #include <unistd.h>
        int close(int fd);

        返回值:
            成功,返回0
            失败,返回-1

        关闭一个文件时,还会释放该进程加在该文件上的所有记录锁

    4、 lseek   函数    -   设置文件偏移量
        
        #include <unistd.h>
        off_t lseek(int fd, off_t offset, int whence);

        注:
            按系统默认的情况,当打开一个文件时,除非指定O_APPEND选项,否则该偏移量被设置为0
            如果文件描述符指向的是一个管道、FIFO或网络套接字时,lseek返回-1,并将errno设置为ESPIPE
        返回值:
            成功,返回新的文件偏移量
            失败,返回-1
        参数:
            若whence是 SEEK_SET, 则将该文件的偏移量设置为距文件开始处offset 个字节
            若whence是 SEEK_CUR, 则将该文件的偏移量设置为其当前值加offset,offset可为正值或负值
            若whence是 SEEK_END, 则将该文件的偏移量设置为文件长度加offset,offset可为正值或负值

            文件偏移量可大于文件的当前长度,这种情况下,对该文件的下一次写将加长该文件,并在文件中构成一个
        空洞,位于文件中但是没有写过的字节都被读为0.
            文件中的空洞并不要求在磁盘上占用存储区,具体处理方式与文件系统的实现有关,当定位超出文件尾端
        之后写时,对于新写的数据需要分配磁盘块,但是对于原文件尾端和新开始写位置之间部分不需要分配磁盘块

        od -c [filename]    -   查看文件的实际内容, -c 标志表示以字符方式打印文件内容

    5、 read 函数   -   从打开的文件中读数据

        #include <unistd.h>
        ssize_t read(int fd, void *buf, size_t nbytes);

        返回值:
            成功,读到的字节数,若已到文件末尾,返回0
            失败,返回-1
        有多种情况可能使实际读到的字节数少于预计读的字节数:
            1)  读普通文件时,在读到要求字节数之前已到达文件末尾
            2)  当从终端设备读时,通常一次最多读一行(可改变)
            3)  当从网络读时,网络中的缓冲机制可能造成返回值小于所要求读的字节数
            4)  当从管道或FIFO读时,如若管道包含的字节少于所需的数量,那么read返回实际可用字节数
            5)  当从某些面向记录的设备(如磁带)读时,一次最多返回一个记录
            6)  当一信号造成终端,而已经读了部分数据量时

    6、 write 函数  -   向打开的文件中写数据

        #include <unistd.h>
        ssize_t write(int fd, const void *buf, size_t nbytes);

        返回值:
            成功,返回已经写入的字节数
            失败,返回-1

        其返回值通常与参数nbytes的值相同,否则表示出错,write出错的一个常见原因是磁盘已经写满,或者
        超过一个给定进程的文件长度限制

    7、 进程之间文件共享机制
        1\  内核使用3种数据结构表示打开的文件,它们之间的关系决定了在文件共享方面一个进程对另一个进程
            可能产生的影响
            1)  每个进程在进程表中都有一个记录项,记录项中包含一张打开文件描述符表,每个文件描述符占用
                一项,与每个文件描述符相关联的是:
                a.  文件描述符标志(close_on_exec)
                b.  指向一个文件表项的指针
            2)  内核为所有打开的文件维持一张文件表,每个文件表项包含:
                a.  文件状态标志(读、写、添写、同步和非阻塞等)
                b.  当前文件偏移量
                c.  指向该文件v(i)节点表项的指针
            3)  每个打开的文件(或设备)都有一个v节点(v-node)结构,v节点包含了文件类型和对此文件进行各种
                操作函数的指针,对于大多数文件,v节点还包含了该文件的i节点(i-node, 索引节点).
                这些信息是在打开文件时从磁盘上读入内存的,所以文件的所有相关信息都是随时可用的,例如
                i节点包含了文件的所有者、文件长度、指向文件实际数据块在磁盘上所在位置的指针等
                (Linux 没有使用v节点,而是使用了通用的i节点结构)
        
        当两个独立进程各自打开同一文件时,两个进程各自的进程表项纪录的文件描述符会各自指向一个记录打开
        文件的文件表项,文件表项参上2),但是各自的文件表项纪录的v节点指针指向同一个v节点表项
        *即每个进程都有它自己对该文件的当前偏移量
            a.  在完成每个write后,在文件表项中的当前文件偏移量即增加所写入的字节数,如果这导致当前
                文件偏移量超出了当前文件长度,则将i节点表项中的当前文件长度设置为当前文件偏移量
            b.  如果用O_APPEND标志打开了一个文件,则相应标志也被设置到文件表项的文件状态标志中
                每次对这种具有追加写标志的文件执行写操作时,文件表项中的当前文件偏移量首先会被设置为
                i节点表项中的文件长度,这就使得每次写入的数据都追加到文件的当前尾端处
            c.  若一个文件用lseek定位到文件当前的尾端,则文件表项中的当前文件偏移量被设置为i节点表项
                中的当前文件长度
            d.  lseek函数只修改文件表项中的当前文件偏移量,不进行任何I/O操作

    8、 原子操作    -   在一个原子操作中,不允许发生内核切换进程
        1\  pread 和 pwrite 函数    -   原子性的定位(lseek)并执行I/O

            #include <unistd.h>
            ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);

            返回值:
                成功,读取到的字节数,若已到文件末尾,返回0
                失败,返回-1

            ssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset);

            返回值:
                成功,返回已经写入的字节数
                失败,返回-1

            注: 调用pread(pwrite)相当于调用lseek后调用read(write),但是pread又与这种顺序调用
                有下列重要区别:
                a.  调用pread时,无法中断其定位和读操作
                b.  不更新当前文件的偏移量

        2\  创建文件时 open(pathname, O_RDWR | O_CREAT, MODE) 为一个原子操作
            1)  先判断文件是否存在
            2） 不存在就创建并打开

    9、 dup 和 dup2 函数    -   复制一个现有的文件描述符
        
        #include <unistd.h>
        int dup(int fd);
        int dup2(int fd, int fd2);

        两个函数的返回值:
            成功,返回新的文件描述符
            失败,返回-1

        注:
            由dup返回的新文件描述符一定是当前可用文件描述符中的最小数值.
            对于dup2,可用fd2参数指定新文件描述符的值,如果fd2已经打开,则先将其关闭.
            如若fd等于fd2，则dup2返回fd2,而不关闭它,否则fd2的FD_CLOEXEC文件描述符标志就被清除,
            这样fd2在进程调用exec时是打开状态
            **这些函数返回的新文件描述符与参数fd共享同一个文件表项,所以他们共享同一文件状态标志(读、写
            追加等)以及同一文件偏移量

        每一个文件描述符都有它自己的一套文件描述符标志,新描述符的执行时关闭(close-on-exec)标志总是
        由dup函数清除.

        复制一个文件描述符的另一种方法是使用fcntl函数,实际上:
        调用
            dup(fd);
        等效于
            fcntl(fd, F_DUPFD, 0);
        调用
            dup2(fd, fd2);
        等效于
            close(fd2);
            fcntl(fd, F_DUPFD, fd2);
        在后一种情况下,dup2并不完全等同于close加上fcntl,它们之间的区别如下:
            a.  dup2是一个原子操作,而close和fcntl包括两个函数的调用,有可能在close和fcntl之间调用
                了信号捕捉函数,它可能修改文件描述符,如果不同的线程改变了文件描述符的话也会出现相同问题
            b.  dup2和fcntl有一些不同的errno

    10、    sync、fsync 和 fdatasync 函数   -   保证磁盘上实际文件系统与缓冲区中内容的一致性
    
            传统UNIX系统实现在内核中设有缓冲区高速缓存或页高速缓存,大多数磁盘I/O都是通过缓冲区进行.
        当我们向文件写入数据时,内核通常先将数据复制到缓冲区中,然后排入队列,晚些时候在写入磁盘,这种方式
        称为延时写(delayed write).
            通常当内核需要重用缓冲区来存放其他磁盘块数据时,他会把所有延迟写的数据写入到磁盘.

        #include <unistd.h>
        int fsync(int fd);
        int fdatasync(int fd);

        返回值:
            成功,返回0
            失败,返回-1

        void sync(void);

        注:
            sync 只是将所有修改过的块缓冲区排入到写队列,然后就返回,它并不等待实际写磁盘操作结束
            通常,称为update的系统守护进程周期性的调用(默认间隔30秒)sync函数,命令sync也是调用sync函数

            fsync函数只对由文件描述符fd指定的一个文件起作用,并且等待写磁盘操作结束才返回,可用于数据库
            这样的应用程序

            fdatasync函数类似fsync,但它只影响文件的数据部分,除数据外,fsync还会同步更新文件属性

    11、    fcntl 函数  -   可以改变已经打开文件的属性

        #include <fcntl.h>
        int fcntl(int fd, int cmd, ... /* int arg */);

        返回值:
            成功,则依赖于cmd
            失败,返回-1

        注:
            fcntl函数有以下5种功能:
            1)  复制一个已有的描述符(cmd = F_DUPFD 或 F_DUPFD_CLOEXEC)
            2)  获取/设置文件描述符标志(cmd = F_GETFD 或 F_SETFD)
            3)  获取/设置文件状态标志(cmd = F_GETFL 或 F_SETFL)
            4)  获取/设置异步I/O所有权(cmd = F_GETOWN 或 F_SETOWN)
            5)  获取/设置纪录锁(cmd = F_GETLK、F_SETLK 或 F_SETLKW)

        F_DUPFD -   复制文件描述符fd,新文件描述符作为函数值返回.返回尚未打开的描述符中大于或等于第3
                    个参数值中的最小值
        F_DUPFD_CLOEXEC -   复制文件描述符,设置与新描述符关联的FD_CLOEXEC文件描述符标志的值

        F_GETFD -   对应于fd的文件描述符标志作为函数值返回,当前只定义了一个文件描述符标志FD_CLOEXEC
        F_SETFD -   对于fd设置文件描述符标志,新标志值按第3个参数设置 0 在exec时不关闭,1 在exec时关闭

        F_GETFL -   对应fd的文件状态标志作为函数值返回,例如 O_RDONLY O_RDWR 等
                    获取方式要用屏蔽字O_ACCMODE取得位访问方式,然后结果与5个值比较
        F_SETFL -   将文件状态设置为第3个参数的值,可以更改的标志: O_APPEND O_NONBLOCK O_SYNC O_RSYNC
                                                                O_FSYNC 和 O_ASYNC

        F_GETOWN    -   获取当前接受SIGIO 和 SIGURG信号的进程ID或进程组ID
        F_SETOWN    -   设置接受SIGNO 和 SIGURG信号的进程ID或进程组ID,正的arg值指定一个进程ID
                                                                      负的arg绝对值指定一个进程组ID

