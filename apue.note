第一章、UNIX基础知识
    1、 程序和进程
        1\  程序
            程序(program)是一个存储在磁盘上某个目录中的可执行文件,内核使用exec函数(7个exec
            函数之一),将程序读入到内存,并执行程序.
        2\  进程
            程序的执行实例被称为进程.

    2、 出错处理
        打印出错信息的函数
        1)  #include <string.h>
            char *strerror(int errnum);
            
            返回值: 指向错误信息字符串的指针

        2） #include <stdio.h>
            void perror(const char *msg);
            
            perror 函数基于errno的当前值,在标准错误上产生一条出错信息
            它首先输出由msg指向的字符串,然后是一个冒号一个空格,接着是对用于errno值的错误信息

    3、 用户标识
        1\  用户ID
            通常每个用户有一个唯一的用户ID
            用户ID为0的用户为root用户或超级用户superuser
            如果一个进程具有超级用户特权,则大多数文件权限检查都不在进行

        2\  组ID
            对于磁盘上的每个文件,文件系统都存储该文件所有者的用户ID和组ID,存储这两个值需要4个字节
            如果使用完整的ASCII登录名和组名,则需要更多的磁盘空间,另外,在检验权限期间,比较字符串较之
            比较整型数更消耗时间.

        3\  附属组ID
            允许一个用户至多属于16个其他的组

    4、 信号(signal)
        信号用于通知进程发生了某种情况,进程有以下3种处理信号的方式
        1)  忽略信号,有些信号表示硬件异常,例如除以0或访问进程地址空间以外的存储单元等,
            因为这些异常产生的后果不确定,所以不推荐使用这种处理方式
        2)  按系统默认方式处理,大多数信号的默认处理方式是终止该进程
        3)  提供一个函数,信号发生时调用该函数,这被称为捕捉该信号

    5、 时间值
        1\  日历时间
            time_t
        2\  进程时间(CPU时间)
            clock_t
            UNIX系统为一个进程维护了3个进程时间值:
            时钟时间        -   墙上时钟时间,它是进程运行的时间总量
            用户CPU时间     -   是执行用户指令所用的时间量
            系统CPU时间     -   是为该进程执行内核程序所经历的时间
            time 命令查看进程时间

    6、 系统调用和库函数
        1)  所有的操作系统都提供多种服务的入口点,由此程序向内核请求服务.各种版本的UNIX实现都提供
            良好定义、数量有限、直接进入内核的入口点,这些入口点被称为系统调用.

第二章、    UNIX标准及实现
    1、 sysconf、pathconf和fpathconf 函数   -   获取系统的运行时限制值
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        #include <unistd.h>
        long sysconf(int name);
        long pathconf(const char *pathname, int name);
        log  fpathconf(int fd, int name);
                                    3个函数返回值:成功返回相应值,出错,返回-1
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        后面两个函数的差别是:一个用路径名作为其参数,另一个则取文件描述符做为参数.
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        sysconf(int name) name的可传入值:
                限制名                  说明                        name参数
            ARG_MAX         exec函数的参数最大长度(字节)            _SC_ARG_MAX
            ATEXIT_MAX      可用atexit函数登记的最大函数个数        _SC_ATEXIT_MAX
            CHILD_MAX       每个实际用户ID的最大进程数              _SC_CHILD_MAX
            时钟滴答/秒     每秒时钟的滴答数                        _SC_CLK_TCK
            COLL_WEIGHTS_MAX在本地定义文件中可以赋予LC_COLLATE
                            顺序关键字项的最大权重数                _SC_COLL_WEIGHTS_MAX
            DELAYTIMER_MAX  定时器最大超限运行次数                  _SC_DELAYTIMER_MAX
            HOST_NAME_MAX   gethostname函数返回的主机名最大长度     _SC_HOST_NAME_MAX
            IOC_MAX         readv或writev函数可以使用最多的
                            iovec结构的个数                         _SC_IOV_MAX

            LINE_MAX        实用程序输入行的最大长度                _SC_LINE_MAX
            LOGIN_NAME_MAX  登录名的最大长度                        _SC_LOGIN_NAME_MAX
            NGROUPS_MAX     每个进程同时添加的最大进程组ID数        _SC_NGROUPS_MAX
            OPEN_MAX        每个进程最大打开的文件数                _SC_OPEN_MAX
            PAGESIZE        系统存储页长度(字节数)                  _SC_PAGESIZE
            PAGE_SIZE       系统存储页长度(字节数)                  _SC_PAGE_SIZE
            RE_DUP_MAX      regexec和regcomp允许的正则重复次数      _SC_RE_DUP_MAX
            RTSIG_MAX       为应用程序预留的实时信号的最大个数      _SC_RTSIG_MAX
            SEM_NSEMS_MAX   一个进程可使用的信号量最大个数          _SC_SEM_NSEMS_MAX
            SEM_VALUE_MAX   信号量的最大值                          _SC_SEM_VALUE_MAX
            SIGQUEUE_MAX    一个进程可排队信号的最大个数            _SC_SIGQUEUE_MAX
            STREAM_MAX      一个_SC_STREAM_MAX进程在任意给定时刻    _SC_STREAM_MAX
                            标准I/O流的最大个数,如果定义,必须与
                            FOPEN_MAX的值相同

            SYMLOOP_MAX     在解析路径名时,可遍历的符号链接数       _SC_SYMLOOP_MAX
            TIMER_MAX       每个进程的最大定时器个数                _SC_TIMER_MAX
            TTY_NAME_MAX    终端设备名长度,包括终止null字符         _SC_TTY_NAME_MAX
            TZNAME_MAX      时区名中的最大字节数                    _SC_TZNAME_MAX
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        pathconf() 和 fpathconf() 的限制及name参数:
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
                限制名              说明                                name参数
            FILESIZEBITS    以带符号整型值表示在指定目录中允许的    _PC_FILESIZEBITS
                            普通文件最大长度所需的最小位(bit)数     

            LINK_MAX        文件链接计数的最大值                    _PC_LINK_MAX
            MAX_CANON       终端规范输入队列的最大字节数            _PC_MAX_CANON
            MAX_INPUT       终端输入队列可用空间的字节数            _PC_MAX_INPUT
            NAME_MAX        文件名的最大字节数(不包括null)          _PC_NAME_MAX
            PATH_MAX        相对路径名的最大字节数,包括null         _PC_PATH_MAX
            PIPI_BUF        能原子的写到管道的最大字节数            _PC_PIPE_BUF
            SYMLINK_MAX     符号链接的字节数                        _PC_SYMLINK_MAX
            _POSIX_TIMESTAMP_RESOLUTION
                            文件时间戳的纳秒精度                    _PC_TIMESTAMP_RESOLUTION
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

    2、 基本系统数据类型
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
            类型                说明
        clock_t         时钟滴答计数器(进程时间)
        comp_t          压缩的时钟滴答
        dev_t           设备号(主和次)
        fd_set          文件描述符集
        fpos_t          文件位置
        gid_t           数值组ID
        ino_t           i节点编号
        mode_t          文件类型,文件创建模式
        nlink_t         目录项的链接计数
        off_t           文件长度和偏移量(带符号的)(lseek)
        pid_t           进程ID和进程组ID(带符号的)
        pthread_t       线程ID
        ptrdiff_t       两个指针相减的结果
        rlim_t          资源限制
        sig_atomic_t    能原子性的访问的数据类型
        sigset_t        信号集
        size_t          对象(如字符串)长度(不带符号的)
        ssize_t         返回字节计数的函数(不带符号的)(read write)
        time_t          日历时间的秒计数器
        uid_t           数值用户ID
        wchar_t         能表示所有不同的字符码
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

第三章、    文件I/O

    1、 函数open 和 openat
        调用open 或 openat 函数可以打开或创建一个文件

        #include <fcntl.h>
        int open(const char *path, int oflag, ... /* mode_t mode */);
        int openat(int fd, const char *path, int oflag, ... /* mode_t mode */);
        
        两个函数的返回值:
            成功,返回文件描述符
            失败,返回-1
        参数详解:
            path    -   要打开或者创建的文件名字
            oflag   -   用来说明函数的多个选项(文件的打开模式)
            fd      -   fd 参数把open和openat区别开,共有三种可能性:
                        1)  path参数指定的是绝对路径名,在这种情况下,fd参数被忽略,openat = open
                        2)  path是相对路径名,fd参数指出相对路径名在文件系统中的开始地址,fd参数是通过
                            打开相对路径名所在的目录来获取
                        3)  path指定相对路径名,fd参数具有特殊值AT_FDCWD,在这种情况下,路径名在当前工作
                            目录中获取,openat 函数在操作上与open 函数类似

            oflag 的可选值: (用下列一个或多个常量进行"或"运算来构成oflag参数)
                O_RDONLY    -   只读打开
                O_WRONLY    -   只写打开
                O_RDWR      -   读、写打开
                O_EXEC      -   只执行打开
                O_SEARCH    -   只搜索打开(应用于目录)  -   常量的目的在于在目录打开时验证它的搜索权限

                在以上5个常量中必须指定一个且只能指定一个,一下常量可选:

                O_APPEND    -   每次写时都追加到文件的末尾
                O_CLOEXEC   -   把FD_CLOEXEC常量设置为文件描述符标志
                O_CREAT     -   若此文件不存在则创建,使用此选项时,open函数需同时说明第3个参数mode
                                (openat函数需说明第4个参数mode),用mode指定该新文件的访问权限位
                O_DIRECTORY -   如果path引用的不是目录,则出错
                O_EXCL      -   如果同时指定了O_CREAT,而文件已经存在,则出错.用此可以测试一个文件是否
                                存在,如果不存在,则创建此文件,这使测试和创建两者成一个原子操作
                O_NOCTTY    -   如果path引用的是终端设备,则不将该设备分配作为此进程的控制终端
                O_NOFLLOW   -   如果path引用的是一个符号链接,则出错
                O_NONBLOCK  -   如果path引用的是一个FIFO、一个块特殊文件或一个字特殊文件,则此选项为
                                文件的本次打开操作和后续的I/O操作设置非阻塞方式
                O_SYNC      -   使每次write等待物理I/O操作完成,包括由该write操作引起的文件属性
                                更新所需的I/O
                O_TRUNC     -   如果此文件存在,而且为只写或读-写成功打开,则将其长度截断为0
                O_TTY_INIT  -   如果打开一个还未打开的终端设备,设置非标准termios参数值,使其符合
                                Single UNIX Specification.
                O_DSYNC     -   使每次write要等待物理I/O操作完成,但是如果该写操作并不影响读取
                                刚写入的数据,则不需要等待文件属性被更新 -   (与O_SYNC有区别)
                O_RSYNC     -   使每一个以文件描述符作为参数进行的read操作等待,直至所有对文件同一
                                部分挂起的写操作都完成

            openat() 函数希望解决的问题:
                1)  让线程可以使用相对路径名打开目录中的文件,而不再只能打开当前工作目录,在同一进程中
                    的所有线程共享相同的当前工作目录,因此很难让同一个进程的多个不同线程在同一时间工作
                    在不同的目录中
                2)  可以避免time-of-check-to-time-of-use(TOCTTOU)错误
                    TOCTTOU错误的基本思想是: 如果有两个基于文件的函数调用,其中第二个调用依赖于第一个
                    调用的结果,那么程序是脆弱的,因为两个调用并不是原子操作,在两个函数调用之间文件可能
                    改变了,这样也就造成了第一个调用的结果就不再有效,使得程序最终的结果是错误的.

    2、 create 函数 -   创建一个新文件
        
        #include <fcntl.h>
        int creat(const char *path, mode_t mode);

        此函数等效于 open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);
        返回值:
            成功,返回为只写打开的文件描述符
            失败,返回-1

        create的局限性在于创建的文件返回的文件描述符是以只写的方式打开的,如果对此文件有读的需求就
        必须通过open函数。

    3、 colse 函数  -   关闭一个打开的文件

        #include <unistd.h>
        int close(int fd);

        返回值:
            成功,返回0
            失败,返回-1

        关闭一个文件时,还会释放该进程加在该文件上的所有记录锁

    4、 lseek   函数    -   设置文件偏移量
        
        #include <unistd.h>
        off_t lseek(int fd, off_t offset, int whence);

        注:
            按系统默认的情况,当打开一个文件时,除非指定O_APPEND选项,否则该偏移量被设置为0
            如果文件描述符指向的是一个管道、FIFO或网络套接字时,lseek返回-1,并将errno设置为ESPIPE
        返回值:
            成功,返回新的文件偏移量
            失败,返回-1
        参数:
            若whence是 SEEK_SET, 则将该文件的偏移量设置为距文件开始处offset 个字节
            若whence是 SEEK_CUR, 则将该文件的偏移量设置为其当前值加offset,offset可为正值或负值
            若whence是 SEEK_END, 则将该文件的偏移量设置为文件长度加offset,offset可为正值或负值

            文件偏移量可大于文件的当前长度,这种情况下,对该文件的下一次写将加长该文件,并在文件中构成一个
        空洞,位于文件中但是没有写过的字节都被读为0.
            文件中的空洞并不要求在磁盘上占用存储区,具体处理方式与文件系统的实现有关,当定位超出文件尾端
        之后写时,对于新写的数据需要分配磁盘块,但是对于原文件尾端和新开始写位置之间部分不需要分配磁盘块

        od -c [filename]    -   查看文件的实际内容, -c 标志表示以字符方式打印文件内容

    5、 read 函数   -   从打开的文件中读数据

        #include <unistd.h>
        ssize_t read(int fd, void *buf, size_t nbytes);

        返回值:
            成功,读到的字节数,若已到文件末尾,返回0
            失败,返回-1
        有多种情况可能使实际读到的字节数少于预计读的字节数:
            1)  读普通文件时,在读到要求字节数之前已到达文件末尾
            2)  当从终端设备读时,通常一次最多读一行(可改变)
            3)  当从网络读时,网络中的缓冲机制可能造成返回值小于所要求读的字节数
            4)  当从管道或FIFO读时,如若管道包含的字节少于所需的数量,那么read返回实际可用字节数
            5)  当从某些面向记录的设备(如磁带)读时,一次最多返回一个记录
            6)  当一信号造成终端,而已经读了部分数据量时

    6、 write 函数  -   向打开的文件中写数据

        #include <unistd.h>
        ssize_t write(int fd, const void *buf, size_t nbytes);

        返回值:
            成功,返回已经写入的字节数
            失败,返回-1

        其返回值通常与参数nbytes的值相同,否则表示出错,write出错的一个常见原因是磁盘已经写满,或者
        超过一个给定进程的文件长度限制

    7、 进程之间文件共享机制
        1\  内核使用3种数据结构表示打开的文件,它们之间的关系决定了在文件共享方面一个进程对另一个进程
            可能产生的影响
            1)  每个进程在进程表中都有一个记录项,记录项中包含一张打开文件描述符表,每个文件描述符占用
                一项,与每个文件描述符相关联的是:
                a.  文件描述符标志(close_on_exec)
                b.  指向一个文件表项的指针
            2)  内核为所有打开的文件维持一张文件表,每个文件表项包含:
                a.  文件状态标志(读、写、添写、同步和非阻塞等)
                b.  当前文件偏移量
                c.  指向该文件v(i)节点表项的指针
            3)  每个打开的文件(或设备)都有一个v节点(v-node)结构,v节点包含了文件类型和对此文件进行各种
                操作函数的指针,对于大多数文件,v节点还包含了该文件的i节点(i-node, 索引节点).
                这些信息是在打开文件时从磁盘上读入内存的,所以文件的所有相关信息都是随时可用的,例如
                i节点包含了文件的所有者、文件长度、指向文件实际数据块在磁盘上所在位置的指针等
                (Linux 没有使用v节点,而是使用了通用的i节点结构)
        
        当两个独立进程各自打开同一文件时,两个进程各自的进程表项纪录的文件描述符会各自指向一个记录打开
        文件的文件表项,文件表项参上2),但是各自的文件表项纪录的v节点指针指向同一个v节点表项
        *即每个进程都有它自己对该文件的当前偏移量
            a.  在完成每个write后,在文件表项中的当前文件偏移量即增加所写入的字节数,如果这导致当前
                文件偏移量超出了当前文件长度,则将i节点表项中的当前文件长度设置为当前文件偏移量
            b.  如果用O_APPEND标志打开了一个文件,则相应标志也被设置到文件表项的文件状态标志中
                每次对这种具有追加写标志的文件执行写操作时,文件表项中的当前文件偏移量首先会被设置为
                i节点表项中的文件长度,这就使得每次写入的数据都追加到文件的当前尾端处
            c.  若一个文件用lseek定位到文件当前的尾端,则文件表项中的当前文件偏移量被设置为i节点表项
                中的当前文件长度
            d.  lseek函数只修改文件表项中的当前文件偏移量,不进行任何I/O操作

    8、 原子操作    -   在一个原子操作中,不允许发生内核切换进程
        1\  pread 和 pwrite 函数    -   原子性的定位(lseek)并执行I/O

            #include <unistd.h>
            ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);

            返回值:
                成功,读取到的字节数,若已到文件末尾,返回0
                失败,返回-1

            ssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset);

            返回值:
                成功,返回已经写入的字节数
                失败,返回-1

            注: 调用pread(pwrite)相当于调用lseek后调用read(write),但是pread又与这种顺序调用
                有下列重要区别:
                a.  调用pread时,无法中断其定位和读操作
                b.  不更新当前文件的偏移量

        2\  创建文件时 open(pathname, O_RDWR | O_CREAT, MODE) 为一个原子操作
            1)  先判断文件是否存在
            2） 不存在就创建并打开

    9、 dup 和 dup2 函数    -   复制一个现有的文件描述符
        
        #include <unistd.h>
        int dup(int fd);
        int dup2(int fd, int fd2);

        两个函数的返回值:
            成功,返回新的文件描述符
            失败,返回-1

        注:
            由dup返回的新文件描述符一定是当前可用文件描述符中的最小数值.
            对于dup2,可用fd2参数指定新文件描述符的值,如果fd2已经打开,则先将其关闭.
            如若fd等于fd2，则dup2返回fd2,而不关闭它,否则fd2的FD_CLOEXEC文件描述符标志就被清除,
            这样fd2在进程调用exec时是打开状态
            **这些函数返回的新文件描述符与参数fd共享同一个文件表项,所以他们共享同一文件状态标志(读、写
            追加等)以及同一文件偏移量

        每一个文件描述符都有它自己的一套文件描述符标志,新描述符的执行时关闭(close-on-exec)标志总是
        由dup函数清除.

        复制一个文件描述符的另一种方法是使用fcntl函数,实际上:
        调用
            dup(fd);
        等效于
            fcntl(fd, F_DUPFD, 0);
        调用
            dup2(fd, fd2);
        等效于
            close(fd2);
            fcntl(fd, F_DUPFD, fd2);
        在后一种情况下,dup2并不完全等同于close加上fcntl,它们之间的区别如下:
            a.  dup2是一个原子操作,而close和fcntl包括两个函数的调用,有可能在close和fcntl之间调用
                了信号捕捉函数,它可能修改文件描述符,如果不同的线程改变了文件描述符的话也会出现相同问题
            b.  dup2和fcntl有一些不同的errno

    10、    sync、fsync 和 fdatasync 函数   -   保证磁盘上实际文件系统与缓冲区中内容的一致性
    
            传统UNIX系统实现在内核中设有缓冲区高速缓存或页高速缓存,大多数磁盘I/O都是通过缓冲区进行.
        当我们向文件写入数据时,内核通常先将数据复制到缓冲区中,然后排入队列,晚些时候在写入磁盘,这种方式
        称为延时写(delayed write).
            通常当内核需要重用缓冲区来存放其他磁盘块数据时,他会把所有延迟写的数据写入到磁盘.

        #include <unistd.h>
        int fsync(int fd);
        int fdatasync(int fd);

        返回值:
            成功,返回0
            失败,返回-1

        void sync(void);

        注:
            sync 只是将所有修改过的块缓冲区排入到写队列,然后就返回,它并不等待实际写磁盘操作结束
            通常,称为update的系统守护进程周期性的调用(默认间隔30秒)sync函数,命令sync也是调用sync函数

            fsync函数只对由文件描述符fd指定的一个文件起作用,并且等待写磁盘操作结束才返回,可用于数据库
            这样的应用程序

            fdatasync函数类似fsync,但它只影响文件的数据部分,除数据外,fsync还会同步更新文件属性

    11、    fcntl 函数  -   可以改变已经打开文件的属性

        #include <fcntl.h>
        int fcntl(int fd, int cmd, ... /* int arg */);

        返回值:
            成功,则依赖于cmd
            失败,返回-1

        注:
            fcntl函数有以下5种功能:
            1)  复制一个已有的描述符(cmd = F_DUPFD 或 F_DUPFD_CLOEXEC)
            2)  获取/设置文件描述符标志(cmd = F_GETFD 或 F_SETFD)
            3)  获取/设置文件状态标志(cmd = F_GETFL 或 F_SETFL)
            4)  获取/设置异步I/O所有权(cmd = F_GETOWN 或 F_SETOWN)
            5)  获取/设置纪录锁(cmd = F_GETLK、F_SETLK 或 F_SETLKW)

        F_DUPFD -   复制文件描述符fd,新文件描述符作为函数值返回.返回尚未打开的描述符中大于或等于第3
                    个参数值中的最小值
        F_DUPFD_CLOEXEC -   复制文件描述符,设置与新描述符关联的FD_CLOEXEC文件描述符标志的值

        F_GETFD -   对应于fd的文件描述符标志作为函数值返回,当前只定义了一个文件描述符标志FD_CLOEXEC
        F_SETFD -   对于fd设置文件描述符标志,新标志值按第3个参数设置 0 在exec时不关闭,1 在exec时关闭

        F_GETFL -   对应fd的文件状态标志作为函数值返回,例如 O_RDONLY O_RDWR 等
                    获取方式要用屏蔽字O_ACCMODE取得位访问方式,然后结果与5个值比较
        F_SETFL -   将文件状态设置为第3个参数的值,可以更改的标志: O_APPEND O_NONBLOCK O_SYNC O_RSYNC
                                                                O_FSYNC 和 O_ASYNC

        F_GETOWN    -   获取当前接受SIGIO 和 SIGURG信号的进程ID或进程组ID
        F_SETOWN    -   设置接受SIGNO 和 SIGURG信号的进程ID或进程组ID,正的arg值指定一个进程ID
                                                                      负的arg绝对值指定一个进程组ID

第四章、    文件和目录
    
    1、 stat、fstat、fstatat 和 lstat 函数

        #include <sys/stat.h>
        int stat(const char *restrict pathname, struct stat *restrict buf);
        int fstat(int fd, struct stat *buf);
        int lstat(const char *restrict pathname, struct stat *restrict buf);
        int fstatat(int fd, const char *restrict pathname, struct stat *restrict bug, int flag);

        4个函数的返回值:
            成功,返回0
            失败,返回-1

        函数说明:
            stat    -   传入pathname, 函数返回与此文件有关的信息结构
            fstat   -   传入一个已打开的文件描述符,返回该文件的有关信息
            lstat   -   类似stat,但是当传入文件是一个符号链接时,lstat返回该符号链接的有关信息
            fstatat -   返回相对于当前打开目录的路径名文件统计信息
                        flag参数控制是否追踪一个符号链接,当AT_SYMLINK_NOFOLLOW标志被设置时,
                        fstatat不会追踪符号链接,直接返回符号链接本身的信息,否则在默认情况下,返回的
                        是符号链接所指向实际文件的信息.
                        fd参数的值为AT_FDCWD时,并且pathname是一个相对路径名,fstatat会计算相对于当前
                        目录的pathname参数;如果pathname是一个绝对路径,fd参数就会被忽略

                        buf参数是一个指针,它指向一个我们提供的结构
                        struct stat {
                            mode_t          st_mode;    /* file type & mode (permissions) */
                            ino_t           st_ino;     /* i_node number (serial number) */
                            dev_t           st_dev;     /* device number (file system) */
                            dev_t           st_rdev;    /* device number for special files(特殊文件) */
                            nlink_t         st_nlink;   /* number of links (链接数)*/
                            uid_t           st_uid;     /* user ID of owner */
                            gid_t           st_gid;     /* group ID of owner */
                            off_t           st_size;    /* size in bytes, for regular files
                                                            (常规文件的字节大小) */
                            struct timespec st_atime;   /* time of last access(使用) */
                            struct timespec st_mtime;   /* time of last modification(修改) */
                            struct timespec st_ctime;   /* time of last file status change(属性) */
                            blksize_t       st_blksize; /* best I/O block size(最佳I/O块大小) */
                            blkcnt_t        st_blocks;  /* number of disk blocks allocated
                                                            (分配的磁盘块数)*/
                        };
                        struct timespec {
                            time_t  tv_sec;     /* 秒 */
                            long    tv_nsec;    /* 纳秒 */
                        };

    2、 文件类型
        1)  普通文件(regular file)      -   包含文本或二进制数据的文件
        2)  目录文件(directory file)
        3)  块特殊文件(block special file)  -   这种类型的文件提供对设备(如磁盘)带缓冲的访问,
                                                每次以固定长度单位访问
        4)  字符特殊文件(character speaial file)    -   这种类型的文件提供对设备不带缓冲的访问,
                                                        每次访问长度可变.系统中所有的设备要么是
                                                        字符特殊文件,要么是块特殊文件
        5)  FIFO                    -   这种类型的文件用于进程间通信,也叫命名管道
        6)  套接字(socket)          -   这种类型的文件用于进程间的网络通信,也可用于本地
        7)  符号链接(symbolic link) -   这种类型的文件指向另一个文件   

        文件类型的信息包含在stat结构的st_mode成员中,可以用以下宏来确定文件类型,参数是st_mode:
            S_ISREG()   -   普通文件
            S_ISDIR()   -   目录文件
            S_ISCHR()   -   字符特殊文件
            S_ISBLK()   -   块特殊文件
            S_ISFIFO()  -   管道或FIFO
            S_ISLNK()   -   符号链接
            S_ISSOCK()  -   套接字

        IPC -   进程通信
        确定IPC对象类型的宏,参数是指向stat结构的指针:
            S_TYPEISMQ()    -   消息队列
            S_TYPEISSEM()   -   信号量
            S_TYPEISSHM()   -   共享存储对象

    3、 umask 函数      -   为进程设置文件模式创建屏蔽字
        
        #include <sys/stat.h>
        mode_t umask(mode_t cmask);

        返回值:
            之前的文件模式创建屏蔽字
            出错不返回
        注:
            这是少数几个没有出错返回函数中的一个
            在进程创建一个新文件或新目录时,就一定会使用文件模式创建屏蔽字.

        参数cmask 由下列列出的9个常量中的若干个按位“或”构成
                st_mode 屏蔽    -   含义
                S_IRUSR         -   用户读
                S_IWUSR         -   用户写
                s_IXUSR         -   用户执行
                S_IRGRP         -   组读
                S_IWGRP         -   组写
                S_IXGRP         -   组执行
                S_IROTH         -   其他读
                S_IWPTH         -   其他写
                S_IXOTH         -   其他执行
            想屏蔽什么权限就传入什么以上什么值.

        umask 命令打印当前shell进程的文件模式创建屏蔽字,其值是八进制表示,如下:
            屏蔽位      -       含义
            0400        -       用户读
            0200        -       用户写
            0100        -       用户执行
            0040        -       组读
            0020        -       组写
            0010        -       组执行
            0004        -       其他读
            0002        -       其他写
            0001        -       其他执行

    4、 chmod、fchmod 和 fchmodat 函数  -   更改现有文件的访问权限
        
        #include <sys/stat.h>
        int chmod(const char *pathname, mode_t mode);
        int fchmod(int fd, mode_t mode);
        int fchmodat(int fd, const char *pathname, mode_t mode, int flag);

        3个函数的返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            chmod   -   在指定的文件上操作
            fchmod  -   对已打开的文件操作
            fchmodat    -   在pathname参数为绝对路径时,fd参数取值为AT_FDCWD而pathname参数为相对路径时
                            与chmod函数无差别
                            否则fchmodat计算相对于打开目录(由fd参数指向)的pathname,
                            flag参数可以改变fchmodat的行为,当设置了AT_SYMLINK_NOFOLLOW标志时
                            函数不会追踪符号链接

    5、 chown、fchown、fchownat 和 lchown 函数  -   用于更改文件的用户ID和组ID

        #include <unistd.h>
        int chown(const char *pathname, uid_t owner, gid_t group);
        int fchown(int fd, uid_t owner, gid_t group);
        int fchownat(int fd, const char *pathname, uid_t owner, gid_t group, int flag);
        int lchown(const char *pathname, uid_t owner, gid_t group);

        4个函数的返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            两个参数owner 或 group 中的任意一个传入值是-1时,对应ID的不变.
            在传入文件是符号链接的情况下,lchown 和 fchownat(设置了AT_SYMLINK_NOFOLLOW标志)更改符号链接
            本身的所有者,不更改所指向文件

            fchown      -   改变fd参数所指向的打开文件的所有者,不能用于改变符号链接的所有者

    6、 文件长度
        stat结构成员st_size表示以字节为单位的文件长度,此字段只对普通文件、目录文件和符号链接有意义
        普通文件,文件长度可以是0,在读这种文件时,将得到文件结束(end-of-file)提示
        符号链接,文件长度是指向文件在文件名中的实际字节数 lib -> usr/lib 则lib的文件长度为7
        目录文件,文件长度通常是一个数(如16或512)的整倍数

    7、 文件截断
    
        #include <unistd.h>
        int truncate(const char *pathname, off_t length);
        int ftruncate(int fd, off_t length);

        两个函数的返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            用于截断文件,将现有的文件长度截断为length,如果该文件以前的长度大于length,则超过length以外
            的数据就不能访问了;如果文件长度小于length,文件的长度将增加,在以前文件尾端和新文件的尾端之间
            的数据将读作0,也就是有可能在文件中创建了一个空洞.

    8、 文件系统
        a.  对一个文件进行重命名操作时,不移动(在同一文件系统中)文件本身,只是创建一个指向现有i节点的
            新目录项,并删除旧的目录项   (mv命令)

        b.  任何一个不包含子目录的目录文件,它的链接计数都为2,新增一个子目录,链接计数加1
            一个链接是目录自己本身的名字,另一个是目录中的".",当新增子目录时,子目录中的".."也指向父目录

    9、 link、linkat、unlink、unlinkat 和 remove 函数

        #include <unistd.h>
        int link(const char *existingpath, const char *newpath);
        int linkat(int efd, const char *existingpath, int nfd, const char *newpath, int flag);

        两个函数的返回值:
            成功,返回0
            出错,返回-1
        
        函数说明:
            任何一个文件可以有多个目录项指向其i节点,上述函数可以创建一个指向现有文件的目录项

            参数newpath引用现有文件existingpath,如果newpath已经存在,则返回出错.只创建newpath中的
            最后一个分量,路径中的其他部分应当已经存在.

            对于linkat函数,现有文件是通过efd和existingpath参数指定的,新的路径名是通过nfd和newpath参数
            指定的.默认情况下,如果两个文件描述符中的任意一个是相对路径,那么它需要通过相对于对应的文件
            描述符进行计算;
            如果两个文件描述符中的任意一个设置为AT_FDCWD,那么相对应的路径名(相对路径)就通过相对于当前
            目录进行计算;
            如果任意一路径名是绝对路径,相对应的文件描述符参数就会被忽略.

            当现有文件是符号链接时,flag参数来控制linkat函数是创建指向现有符号链接的链接还是创建指向现有
            符号链接所指向文件的链接.设置AT_SYMLINK_FOLLOW标志,就创建指向原文件的链接.


        #include <unistd.h>
        int unlink(const char *pathname);
        int unlinkat(int fd, const char *pathname, int flag);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            删除一个现有的目录项,即链接计数减-

        *在一个文件有被任意一进程打开的情况下,即使链接计数为0,该文件也不会被立即删除
        *在删除一个文件时,内核会先检查的进程使用计数,当进程使用计数为0时,才会去检查链接计数
        *进程临时文件的做法
            创建一个临时文件,然后立即调用unlink,这样保证即使在程序崩溃的情况下,临时文件也会被删除

        #include <stdio.h>
        int remove(const char *pathname);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            解除对一个文件或目录的链接.对于文件remove的功能和unlink相同,对于目录,remove和rmdir功能相同.

    10、    rename 和 renameat 函数 -   对文件或目录进行重命名
        
        #include <stdio.h>
        int rename(const char *oldname, const char *newname);
        int renameat(int oldfd, const char *oldname, int newfd, const char *newname);

        返回值:
            成功,返回0
            出错,返回-1

        注:
            a.  如果oldname指的是一个文件(文件或符号链接)而不是目录,在这种情况下,如果newname已经存在,
                而且不是一个目录,则先将该文件删除然后将oldname重命名为newname

            b.  如果oldname指的是一个目录,如果newname已经存在,则它必须引用一个目录,而且该目录应当是空
                目录,如果newname存在,而且是一个空目录,则先将其删除,然后将oldname重命名为newname

            c.  如果oldname或newname引用符号链接,则处理的是符号链接本身,而不是它引用的文件

            d.  不能对.和..重命名

            e.  如果oldname 和 newname 引用同一文件,则函数不做任何改动而成功返回.

    11、    符号链接(软链接)
        符号链接是对一个文件的间接指针,硬链接直接指向文件的i节点.
        a.  硬链接通常要求链接和文件位于同一文件系统中.
        b.  只有超级用户才能创建指向目录的硬链接
        c.  符号链接不受文件系统的限制,且任何用户都可以创建指向目录的符号链接
        d.  符号链接一般用于将一个文件或整个目录结构移到系统中另一个位置

    12、    创建和读取符号链接

        #include <unistd.h>
        int symlink(const char *actualpath, const char *sympath);
        int symlinkat(const char *actualpath, int fd, const char *sympath);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            上述两个函数可以用来创建一个符号链接.
            函数创建了一个指向actualpath的新目录项sympath,在创建此符号链接时,并不要求actualpath已经存在
            并且actualpath和sympath并不需要位于同一个文件系统中.

        #include <unistd.h>
        ssize_t readlink(const char *restrict pathname, char *restrict buf, size_t bufsize);
        ssize_t readlinkat(int fd, const char *restrict pathname, char *restrict buf, size_t bufsize);

        返回值:
            成功,返回读取的字节数
            出错,返回-1

        函数说明:
            因为open函数会追踪符号链接,所以需要一种方法可以打开链接本身,并读取链接中的名字.
            两个函数组合了open、read和close的所有操作,如果函数执行成功,则返回读入buf的字节数

    13、    文件的时间
        每个文件维护了3个时间字段:
        st_atime    -   文件数据的最后访问时间,如read函数, ls -u查看
        st_mtime    -   文件数据的最后修改时间,如write函数, ls 默认显示
        st_ctime    -   i节点状态的最后更改时间(文件属性的修改时间),如chmod、chown, ls -c 可查看

    14、    futimens、utimensat 和 utimes 函数

        #include <sys/stat.h>
        int futimens(int fd, const struct timespec times[2]);
        int utimensat(int fd, const char *path, const struct timespec times[2], int flag);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            用于修改文件的访问时间的最后更改时间,所用数据结构是与stat函数族相同的timespec结构
            参数times数组第一个元素包含访问时间,第二个元素包含最后更改时间,这两个时间值是日历时间,
            自特定时间(1970年1月1日00:00:00)以来所经过的秒数,不足秒用纳秒表示
            tiems参数传入值按下列4种方式指定:
            a.  如果times参数是一个空指针,则修改访问时间和最后更改时间为当前时间
            b.  如果times参数指向两个timespec结构的数组,任一数组元素的tv_nsec字段值为UTIME_NOW,则修改
                相对应的时间戳为当前时间,忽略相应的tv_sec字段
            c.  如果times参数指向两个timespec结构的数组,任一数组元素的tv_nsec字段值为UTIME_OMIT,则
                相对应的时间戳保持不变,忽略相应的tv_sec字段
            d.  如果times参数指向两个timespec结构的数组,且tv_nsec字段既不是UTIME_NOW也不是UTIME_OMIT,
                则修改对应时间戳为相应的tv_sec 和 tv_nsec 字段的值

            futimens 函数需要打开文件来更改它的时间,utimensat函数提供了一种使用文件名更改文件时间的方法
            utimensat 函数的flag参数可用于进一步修改默认行为,如果设置了AT_SYMLINK_NOFOLLOW标志,则符号
            链接本身的时间就会被修改(如果路径名指向符号链接),默认的行为是追踪符号链接,并把文件的时间修改
            为符号链接的时间.

        #include <sys/time.h>
        int utimes(const char *pathname, const struct timeval times[2]);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            utimes参数包含的两个时间戳是struct timeval结构,使用秒和微妙表示的
            struct timeval {
                time_t tv_sec;  /* seconds */
                long tv_usec;   /* microseconds */
            };
            状态时间不能用指定值来修改,当调用utimes函数时,文件的状态时间会被自动更新

    15、    mkdir、mkdirat 和 rmdir 函数

        #include <sys/stat.h>
        int mkdir(const char *pathname, mode_t mode);
        int mkdirat(int fd, const char *pathname, mode_t mode);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            上述两函数可用于创建目录,所指定的文件访问权限mode由进程的文件模式创建屏蔽字修改

        #include <unistd.h>
        int rmdir(const char *pathname);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            用rmdir可以删除一个空目录,空目录是只包含.和..这两项的目录

    16、    读目录

        #include <dirent.h>
        DIR *opendir(const char *pathname);
        DIR *fdopendir(int fd);

        返回值:
            成功,返回指针
            出错,返回NULL
        
        struct dirent *readdir(DIR *dp);

        返回值:
            成功,返回指针
            出错或者在目录尾,返回NULL

        void rewinddir(DIR *dp);
        int closedir(DIR *dp);

        返回值:
            成功,返回0
            出错,返回-1

        long telldir(DIR *dp);

        返回值:
            返回与dp关联的目录中的当前位置

        void seekdir(DIR *dp, long loc);

        函数说明:
            fdopendir   -   可以把打开的文件描述符转换成目录处理函数需要的DIR结构
            readdir     -   读取目录中的第一个目录项

    17、    chdir、fchdir 和 getcwd 函数
        每个进程都有一个工作目录,此目录是搜索所有相对路径名的起点,当前工作目录是进程的一个属性.
        当用户登录到unix系统时,其当前目录通常是/etc/passwd中该用户登录项的第6个字段-用户的起始目录.

        #include <unistd.h>
        int chdir(const char *pathname);
        int fchdir(int fd);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            进程调用chdir或fchdir函数可以更改当前的工作目录.
            这两个函数中,分别用pathname或打开的文件描述符来指定新的当前工作目录

        #include <unistd.h>
        char *getcwd(char *buf, size_t size);

        返回值:
            成功,返回buf
            出错,返回NULL

        函数说明:
            返回进程当前工作目录完整的路径名.
            参数buf     -   缓冲区地址
            参数size    -   缓冲区长度

        注:
            chdir 追踪符号链接,但是getcwd不追踪符号链接
            当一个应用程序需要在文件系统中返回到它工作的出发点时,在更换工作目录之前先调用getcwd保存
            当前工作目录路径,在完成处理后把它传送个chdir,这样就返回到进程的出发点.

    18、    设备特殊文件
        st_dev  -   存储【非】字特殊文件和块特殊文件的主、次设备号
        st_rdev -   存储字特殊文件和块特殊文件次设备号

        每个文件系统所在的存储设备都是由主、次设备号表示.
        主设备号标识设备的驱动程序,有时编码为与其通信的外设备
        次设备号标识特定子设备.
        例如在同一磁盘驱动器上的各个文件系统通常具有相同的主设备号,但是次设备号却不同

        设备号的获取方法:
            major 宏,来访问主设备号     -   major(statbuf.st_dev) minor(statbuf.st_dev)
            minor 宏,来访问次设备号     -   major(statbuf.st_rdev) minor(statbuf.st_rdev)

        系统中也每个文件名关联的st_dev值是文件系统的设备号,该文件系统包含了这一文件名以及其对应i节点

        只有字符特殊文件和块特殊文件才有st_rdev值,此值包含实际设备的设备号

第五章、    标准I/O库

    1、 流和FILE对象
        对于ASCII字符集,一个字符用一个字节表示
        对于国际字符集,一个字符可以用多个字节表示
        标准I/O文件流可用于单字节或多字节("宽")字符集
        I/O函数分为多字节I/O函数(<wchar.h>)和单字节I/O函数

        fopen   -   打开一个流
        freopen -   清除一个流的定向
        fwide   -   设置或返回一个流的定向


        #include <stdio.h>
        #include <wchar.h>
        int fwide(FILE *fp, int mode);

        返回值:
            若流是宽定向的,返回正值
            若流是字节定向的,返回负值
            若流是未定向的,返回0

        函数说明:
            fwide函数可用于设置流的定向
            根据mode参数的不同值,fwide函数执行不同的工作:
                a.  mode参数值为负,fwide将试图将指定的流设置为字节定向的
                b.  mode参数值为正,fwide将试图将指定的流设置为宽定向的
                c.  mode参数值为0,fwide将返回指定流的定向方式

        注:
            fwide并不改变已定向流的定向,且无出错返回,使用时应先清除errno,然后调用后检查errno来判读是否成功

    2、 标准输入、标准输出和标准错误
                                            对应的文件指针
        STDIN_FILENO    -   标准输入    -       stdin
        STDOUT_FILENO   -   标准输出    -       stdout
        STDERR_FILENO   -   标准错误    -       stderr

    3、 缓冲
        标准I/O库提供缓冲的目的是尽可能的减少read和write的调用次数
        标准I/O提供了以下3种类型的缓冲:
        1)  全缓冲  -   在填满标准I/O的缓冲区后才进行实际I/O操作,对于驻留在磁盘上的文件通常是全缓冲的
                        在一个流上执行第一次I/O操作时,相关标准I/O函数通常调用malloc来获得缓冲区
                        调用fflush函数可以冲洗一个流,将缓冲区的数据冲洗到磁盘上

        2)  行缓冲  -   当在输入和输出中遇到换行符时,才执行实际的I/O操作,通常当流涉及到一个终端时,使用
                        行缓冲.

        3)  不带缓冲

        注:
            (系统默认)
            a.  标准错误流stderr通常是不带缓冲的
            b.  若是指向终端设备的流,则是行缓冲的;否则是全缓冲的

        #include <stdio.h>
        void setbuf(FILE *restrict fd, char *restrict buf);
        int setvbuf(FILE *restrict fd, char *restrict buf, int mode, size_t size);
    
        返回值:
            成功,返回0
            出错,返回非0

        函数说明:
            用于修改系统默认的流的缓冲类型
            这些函数一定要在流被打开以后使用

            setbuf  -   用以打开或关闭缓冲机制,参数buf指向一个长度为BUFSIZE的缓冲区(该常量定义
                        在<stdio.h>中).
                        关闭缓冲可以将buf设置为NULL

            setvbuf -   可以精确的设置缓冲类型,mode参数来说明:
                        _IOFBF  -   全缓冲
                        _IOLBF  -   行缓冲
                        _IONBF  -   不带缓冲
                        指定一个不带缓冲的流时,忽略buf和size参数
                        指定全缓冲或行缓冲时,buf和size可选择的指定一个缓冲区的及其长度
                        若指定流是带缓冲的,而buf传入NULL,则标准I/O库将自动的为该流分配适当长度的缓冲区,
                        通常是常量BUFSIZE的值
        
        #include <stdio.h>
        int fflush(FILE *fp);

        返回值:
            成功,返回0
            出错,返回EOF

        函数说明:
            强制冲洗一个流,此函数使该流所有未写的数据都被传送至内核
            当参数fp传入NULL时,将导致所有的输出流被冲洗.

    4、 打开流

        #include <stdio.h>
        FILE *fopen(const char *restrict pathname, const char *restrict type);
        FILE *freopen(const char *restrict pathname, const char *restrict type, FILE *restrict fp);
        FILE *fdopen(int fd, const char *type);

        返回值:
            成功,返回文件指针
            出错,返回NULL

        函数说明:
            以上3个函数用于打开一个标准I/O流
            3个函数的区别:
                1)  fopen函数打开路径名为pathname的一个指定的文件
                2)  freopen函数在一个指定的流上打开一个指定的文件,如果该流已经打开,则先关闭该流;
                    若流已经定向,则使用freopen清除该定向,此函数一般用于将一个指定的文件打开为一个
                    预定义的流:标准输入、标准输出或标准错误
                3)  fdopen函数取一个已有的文件描述符,并使一个标准的I/O流与该描述符相结合.
                    此函数常用于由创建管道和网络通信通道函数返回的文件描述符,因为这些特殊类型的文件不能
                    用标准I/O函数fopen打开.

        #include <stdio.h>
        int fclose(FILE *fp);

        返回值:
            成功,返回0
            出错,返回EOF

        函数说明:
            关闭一个打开的流

    5、 读和写流
        3种不同类型的非格式化I/O
            a.  每次一个字符的I/O
            b.  每次一行的I/O   -   fgets() fputs()
            c.  直接I/O     -   fread() fwrite()

        1\  输入函数

            #include <stdio.h>
            int getc(FILE *fp);
            int fgetc(FILE *fp);
            int getchar(voide);

            返回值:
                成功,返回下一个字符
                到达文件尾端或出错,返回EOF

            函数说明:
                上述函数用于一次读一个字符
                getchar = getc(stdin);
                注:
                    1)  getc的参数不应当是具有副作用的表达式,因为它可能被计算多次
                    2)  因为fgetc一定是个函数,所以可以得倒其地址,这就允许将fgetc的地址作为一个参数
                        传给另一个函数
                    3)  调用fgetc所需的时间可能比调用getc要长,因为调用函数所需时间通常长于宏

                    以上函数在到达文件末尾和出错时都将返回-1,为了区别这两种不同的情况,必须调用ferror 或
                    feof.
            #include <stdio.h>
            int ferror(FILE *fp);
            int feof(FILE *fp);
            void clearerr(FILE *fp);

            返回值:
                条件为真,返回非0
                否则,返回0

            函数说明:
                在大多数实现中,为每个流在FILE对象中维护了两个标志:
                a.  出错标志
                b.  文件结束标志
                调用clearerr可以清除这两个标志

            #include <stdio.h>
            int ungetc(int c, FILE *fp);

            返回值:
                成功,返回c
                出错,返回EOF

            函数说明:
                从流中读取数据以后再将字符压送回流中,压送回流中的字符又可以从流中读出,但读出的字符顺序与
                压送回的顺序相反.
                回送的字符不一定是上次读取到的字符,不能回送EOF

        2\  输出函数

            #include <stdio.h>
            int putc(int c, FILE *fp);
            int fputc(int c, FILE *fp);
            int putchar(int c);

            返回值:
                成功,返回c
                出错,返回EOF

            putchar(c) 等同于 putc(c, stdout);


    6、 每次一行I/O

        #include <stdio.h>
        char *fgets(char *restrict buf, int n, FILE *restrict fp);
        char *gets(char *buf);

        返回值:
            成功,返回buf
            若到达文件末尾或出错,返回NULL

        函数说明:
            这两个函数提供每次输入一行的功能
            这两个函数都指定了缓冲区的地址,读入的行将被送入其中,fgets是从标准输入读,而fgets是从指定的流读
            
            fgets   -   必须指定缓冲区的长度n,当超过缓冲区大小时,将返回一个不完整的行,
                        该缓冲区总是以字符null字节结尾,会将换行符存入缓冲区
            gets    -   是一个不被推荐的函数,其问题是调用者在使用gets时不能指定缓冲区的长度,这样有可能
                        造成缓冲区溢出,不会将换行符存入缓冲区

        #include <stdio.h>
        int fputs(const char *restrict str, FILE *restrict fp);
        int puts(const char *str);

        返回值:
            成功,返回非负值
            出错,返回EOF

        函数说明:
            提供一次输出一行的功能
            fputs   -   将一个以null字节终止的字符串写到指定流,尾端的终止符null不写出
            puts    -   将一个以null字节终止的字符串写到标准输出,终止符不写出,
                        但是puts会额外输出一个换行符

    7、 标准I/O的效率
        单字节读取时,fgetc要比直接调用read快,因为系统调用更加的耗费时间
        fgts实现方式使用汇编函数memccpy,比起一次读取一字节要快的多

    8、 二进制I/O   -   一次读写一个结构

        #include <stdio.h>
        size_t fread(void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);
        size_t fwrite(const void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);

        返回值:
            读或写的对象数

        函数说明:
            按结构大小读写或按块读写
            参数size应当是该结构的sizeof,参数nobj应是该数组中的元素个数

    9、 定位流
        
        有3种方法定位标准I/O流
        1)  ftell 和 fseek     函数 -   记录文件位置的数值为一个长整型,不能超过取值范围
        2)  ftello 和 fseeko   函数 -   使用off_t数据类型代替了长整型
        3)  fgetpos 和 fsetpos 函数 -   使用抽象数据类型fpos_t记录文件位置

        #include <stdio.h>
        long ftell(FILE *fp);       -   成功,返回当前文件位置指示;出错,返回-1L
        int fseek(FILE *fp, long offset, int whence);   -   成功,返回0;出错,返回-1
        void rewind(FILE *fp);
        off_t ftello(FILE *fp);     -   成功,返回当前文件位置;出错,返回(off_t)-1
        int fseeko(FILE *fp, off_t offset, int whence);     -   成功,返回0;出错,返回-1
        
        int fgetpos(FILE *restrict fp, fpos_t *restrict pos);
        int fsetpos(FILE *fp, const fpos_t *pos);

        返回值:
            成功,返回0
            出错,返回非0

    10、    格式化I/O
        1\  格式化输出

            #include <stdio.h>
            int printf(const char *restrict format, ...);
            int fprintf(FILE *restrict fp, const char *restrict format, ...);
            int dprintf(int fd, const char *restrict format, ...);

            返回值:
                成功,返回输出的字符数
                出错,返回负值

            int sprintf(char *restrict buf, const char *restrict format, ...);
            int snprintf(char *restrict buf, size_t n, const char *restrict format, ...);
    
            返回值:
                成功,返回存入数组的字符数
                出错,返回负值
    
            函数说明:
                fprintf -   输出到指定流
                dprintf -   输出到指定文件描述符
                sprintf -   将格式化的字符串存入数组buf(字符串)中,会在字符串尾端添加一个null字符
                            且有可能造成缓冲区溢出
                snprintf-   解决sprintf可能造成的缓冲区溢出问题,缓冲区的长度作为一个显示参数传入,
                            当字符串超出缓冲区长度时,超出部分就会被丢弃

                格式说明% 
                    %[flags][fldwidth][precision][lenmodifier]convtype
                    flages :
                        ,       -   将整数按千位分组字符
                        -       -   在字段内左对齐
                        +       -   总是显示带符号转换的正负号
                        (空格)  -   如果第一个字符不是正负号,则在前面加上一个空格
                        #       -   指定另一种转换形式(例如转十六进制,加上0x前缀)
                        0       -   添加前导0(代替空格)进行填充
                    
                    fldwidth    -   说明最小字段宽度,转换后参数字符若小于宽度,则多余位置用空格填充

                    precision   -   说明整型抓换后最小输出数字位数、浮点数转换后的小数点后位数、字符
                                    串转换后最大字节数.精度是一个(.),其后跟随一个可选的非负十进制数或
                                    一个星号(*)
            
                    lenmodifier :   说明参数长度,如下
                        hh  -   将相应的参数按signed 或 unsigned char 类型输出
                        h   -   将相应的参数按signed 或 unsigned short 类型输出
                        l   -   将相应的参数按signed 或 unsigned long 或宽字符类型输出
                        ll  -   将相应的参数按signed 或 unsigned longlong类型输出
                        j   -   intmax_t 或 uintmax_t
                        z   -   size_t
                        t   -   ptrdiff_t
                        L   -   long double

                    convtype    :   必选
                        d、i    -   有符号十进制
                        o       -   无符号八进制
                        u       -   无符号十进制
                        x、X    -   无符号十六进制
                        f、F    -   双精度浮点数
                        e、E    -   指数格式双精度浮点数
                        g、G    -   根据转换后的值解释为f、F、e或E
                        a、A    -   十六进制指数格式双精度浮点数
                        c       -   字符
                        s       -   字符串
                        p       -   指向void的指针
                        %       -   %字符
                        C       -   宽字符,等效于lc
                        S       -   宽字符串,等效于ls
                        n       -   到目前为止,此printf调用输出的字符数将被写入到指针所
                                    指向的带符号整型中
                        
            5中printf族的变体:
            #include <stdarg.h>
            #include <stdio.h>
            int vprintf(const char *restrict format, va_list arg);
            int vfprintf(FILE *restrict fp, const char *restrict format, va_list arg);
            int vdprintf(int fd, const char *restrict format, va_list arg);

            返回值:
                成功,返回输出字符数
                出错,返回负值

            int vsprintf(char *restrict buf, const char *restrict format, va_list arg);
            int vsnprintf(char *restrict buf, size_t n, const char *restrict format, va_list arg);

            返回值:
                成功,返回存入数组的字符数
                出错,返回负值

        2\  格式化输入
            
            #include <stdio.h>
            int scanf(const char *restrict format, ...);
            int fscanf(FILE *restrict fp, const char *restrict format, ...);
            int sscanf(const char *restrict buf, const char *restrict format, ...);

            返回值:
                成功,赋值的输入项数
                输入出错或在任一转换前已达到文件尾端,返回EOF

    11、    实现细节

        #include <stdio.h>
        int fileno(FILE *fp);   -   返回与该流相关联的文件描述符

        见Chapter_5 printStdioCached.c 测试程序

    12、    临时文件

        #include <stdio.h>
        char *tmpnam(char *ptr);    -   返回指向唯一路径名的指针
        FILE *tmpfile(void);        -   成功,返回文件指针;出错,返回NULL

        函数说明:
            用来创建临时文件.
            tmpnam  -   长生一个与现有文件名不同的一个有效路径名字符串,每次调用都会产生一个不同的
                        路径名,最多调用次数是TMP_MAX,定义在<stdio.h>中

            tmpfile -   创建一个临时二进制文件(类型wb+),在关闭该文件或程序结束时将自动删除这种文件.

        见Chapter_5 tmpfile.c 测试程序
        警告：the use of `tmpnam' is dangerous, better use `mkstemp'

        tmpfile函数通常是先调用tmpnam产生一个唯一的路径名,然后用该路径名创建一个文件,并立即unlink它

        #include <stdio.h>
        char *mkdtemp(char *template);  -   成功,返回指向目录名的指针;出错,返回NULL
        int mkstemp(char *template);    -   成功,返回文件描述符;出错,返回-1

        函数说明:
            mkdtemp -   创建了一个目录,该目录有一个唯一的名字;
            mkstemp -   创建了一个文件,该文件有一个唯一的名字,创建并打开文件
        注:
            mkstemp创建的临时文件不会自动删除
            使用tmpnam 和 tempnam有一个缺点,在返回唯一的路径名和用该名字创建文件之间有一个时间窗口
            在这个时间窗口内,另一个进程可以使用相同的名字创建文件,谨慎使用
            tmpfile和mkstemp函数不会存在这个问题.
        见Chapter_5 mkstemp.c 测试程序

    13、    内存流  -   使用FILE指针访问,没有底层文件,通过缓存和主存之间传送字节,类似文件流

        内存流的创建,3个函数

        #include <stdio.h>
        FILE *fmemopen(void *restrict buf, size_t size, const char *restrict type);

        返回值:
            成功,返回流指针
            出错,返回NULL

        函数说明:
            fmemopem 函数允许调用者提供缓冲区用于内存流:
                buf参数指向缓冲区的开始位置,
                size参数指定了缓冲区大小的字节数.
                如果buf参数为空,fmemopen函数分配size字节数的缓冲区,这种情况下,流关闭时,缓冲区会自动释放
                type参数控制如何使用流:
                    r/rb    -   为读而打开
                    w/wb    -   为写而打开
                    a/ab    -   追加
                    r+/rb+  -   读写
                    w+/wb+  -   把文件截断为0,读写
                    a+/ab+  -   追加,读写
            注:
                任何时候需要增加流缓冲区中数据量以及调用fclose、fflush、fseek、fseeko以及fsetpos时,
                都会在当前位置写入一个null字节.

        其他两个函数:
        #include <stdio.h>
        FILE *open_memstream(char **bufp, size_t *sizep);
        #include <wchar.h>
        FILE *open_wmemstream(wchar_t **bufp, size_t *sizep);

        返回值:
            成功,返回流指针
            出错,返回NULL

        函数说明:
            open_memstream 函数创建的流是面向字节的
            open_wmemstream函数创建的流是面向宽字节的
            这两个函数与fmemopen的不同在于:
                a.  创建的流只能写打开
                b.  不能指定自己的缓冲区,但是可以分别通过bufp和sizep参数访问缓冲区地址和大小
                c.  关闭流后需要自行释放缓冲区
                d.  对流添加字节会增加缓冲区的大小

第六章、系统数据文件和信息
    1、 口令文件(用户数据库)
        <pwd.h>中的passwd结构:
            char    *pw_name    -   用户名
            char    *pw_passwd  -   加密口令
            uid_t   pw_uid      -   数值用户ID
            gid_t   pw_gid      -   数值组ID
            char    *pw_gecos   -   注释字段
            char    *pw_dir     -   初始工作目录
            char    *pw_shell   -   初始shell
            char    *pw_class   -   用户访问类
            time_t  pw_change   -   下次口令修改时间
            time_t  pw_expire   -   账户有效期时间

        #include <pwd.h>
        struct passwd *getpwuid(uid_t uid);
        struct passwd *getpwnam(const char *name);

        返回值:
            成功,返回指向struct passwd结构的指针
            出错,返回NULL

        函数说明:
            在给出用户登录名或数值用户ID后,获取相关的struct passwd结构
            getpwuid函数由ls程序使用,它将i节点中的用户ID映射为用户登录名
            在输入登录名时,getpwnam函数由login程序使用

        #include <pwd.h>
        struct passwd *getpwent(void);  -   成功,返回指针;出错或到达文件尾端,返回NULL
        void setpwdent(void);
        void endpwent(void);

        函数说明:
            查看整个口令文件
            getpwent    -   返回口令文件中的下一个记录项,在第一次调用时,它打开它所使用的各个文件
            setpwent    -   
            endpwent    -   关闭getpwnet打开的文件,一般在调用getpwent结束之后调用

    2、 阴影口令    -   shadow password
        /etc/shadow文件中的字段和struct spwd结构中的成员:
        用户登录名                  -   char    *sp_namp
        加密口令                    -   char    *sp_pwdp
        上次更改口令以来经过的时间  -   int     sp_lstchg
        经多少天后允许更改          -   int     sp_min
        要求更改剩余天数            -   int     sp_max
        超期警告天数                -   int     sp_warn
        账户不活动之前的剩余天数    -   int     sp_inact
        账户超期天数                -   int     sp_expire
        保留字段                    -   unsigned int sp_flag

        #include <shadow.h>
        struct spwd *getspnam(const char *name);
        struct spwd *getspent(void);
        void setspent(void);
        void endspent(void);

        前两个函数的返回值:
            成功,返回指针
            出错,返回NULL

        函数说明:
            用于访问阴影口令文件/etc/shadow

    3、 组文件  -   /etc/group
        
        /etc/group文件中的字段,包含在<grp.h>中所定义的group结构中
        char    *gr_name    -   组名
        char    *gr_passwd  -   加密口令
        int     gr_gid      -   数值组ID
        char    **gr_mem    -   指向各用户名指针的数组,其中每个指针指向一个属于该组的用户名

        #include <grp.h>
        struct group *getgrgid(gid_t gid);
        struct group *getgrnam(const char *name);

        返回值:
            成功,返回指向struct group的指针,该指针指向静态变量,每次调用时重写该静态变量
            出错,返回NULL

        函数说明:
            传入gid 或 组名,获取struct group结构体

        #include <grp.h>
        struct group *getgrent(void);   -   成功,返回下一个组信息的指针;出错或到达文件尾端,返回NULL
        void setgrent(void);
        void endgrent(void);

        函数说明:
            获取整个组文件
            setgrent    -   打开组文件并反绕它(?)
            getgrent    -   从组文件中读出下一个记录,如果该文件尚未打开,就先打开它
            endgrent    -   关闭组文件

    4、 附属组ID
        每个用户除了属于口令文件记录项中组ID所对应的组之外,还可以属于16个另外的组

        #include <unistd.h>
        int getgroups(int gidsetsize, gid_t grouplist[]);   -   成功,返回附属组ID数量;出错,返回-1

        #include <grp.h>    /* on Linux */
        #include <unistd.h> /* on FreeBSD, Mac OS X, and Solaris */
        int setgroups(int ngroups, const gid_t grouplist[]);

        #include <grp.h>    /* on Linux and Solaris */
        #include <unistd.h> /* on FreeBSD and Mac OS X */
        int initgroups(const char *username, gid_t basegid);

        后两个函数的返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            getgroups   -   将进程所属用户的各个附属组ID填写到数组grouplist中,填写入该数组的附属组ID数
                            最多为gifsetsize个;实际填写到数组中的附属组ID数由函数返回值返回.
                            当gidsetsize传入为0时,函数只返回附属组ID数

            setgroups   -   可由超级用户调用以便为调用进程设置附属组ID表
                            grouplist是组ID数组;
                            ngroups说明数组中的元素个数,且ngroups值不能大于NGROUPS_MAX

            initgroups  -   通常只有initgroups函数调用setgroups,initgroups读整个组文件(用getgrent、
                            setgrent和endgrent),然后对username确定其组的成员关系.然后调用setgroups,
                            以便为该用户初始化附属组ID表

    5、 时间和日期例程

        #include <time.h>
        time_t time(time_t *calptr);

        返回值:
            成功,返回当前时间值
            出错,返回-1

        函数说明:
            time函数返回当前时间和日期
            时间值作为函数值返回,如果参数非空,则时间值也存放在由calptr指向的单元内

        时钟通过clockid_t 类型标识:
        CLOCK_REALTIME                                              -   实时系统时间
        CLOCK_MONOTONIC             -   _POSIX_MONOTONIC_CLOCK      -   不带负跳数的实时系统时间
        CLOCK_PROCESS_CPUTIME_ID    -   _POSIX_CPUTIME              -   调用进程的CPU时间
        CLOCK_THREAD_CPUTIME_ID     -   _POSIX_THREAD_CPUTIME       -   调用线程的CPU时间

        #include <sys/time.h>
        int clock_gettime(clockid_t clock_id, struct timespec *tsp);

        返回值:
            成功,返回0
            出错,返回-1
        
        函数说明:
            clock_gettime函数可用于获取指定时钟的时间,返回的时间在timespec结构中,表示为秒和纳秒
            当clock_id设置为CLOCK_REALTIME时,与time函数类似,精度更高

        #include <sys/time.h>
        int clock_getres(clockid_t clock_id, struct timespec *tsp);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            clock_getres函数把参数tsp指向的timespec结构初始化为与clock_id参数对应的时钟精度

        #include <sys/time.h>
        int clock_settime(clockid_t clock_id, const struct timespec *tsp);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            对特定的时钟设置时间

        struct tm {         /* 存放时间的结构体 */
            int     tm_sec;     /* seconds after the minute: [0 - 60] */
            int     tm_min;     /* minutes after the hour: [0 - 59] */
            int     tm_hour;    /* hours after midnight: [0 - 23] */
            int     tm_mday;    /* day of the month: [1 - 31] */
            int     tm_mon;     /* months since January: [0 - 11] */
            int     tm_year;    /* years since 1900 */
            int     tm_wday;    /* days since Sunday: [0 - 6] */
            int     tm_yday;    /* days since January 1: [0 - 365] */
            int     tm_isdst;   /* daylight saving time flag: <0, 0, >0 */
        };

        #include <time.h>
        struct tm *gmtime(const time_t *calptr);
        struct tm *localtime(const time_t *calptr);

        返回值:
            成功,指向分解的tm结构指针
            出错,返回NULL

        函数说明:
            localtime   -   将日历时间转换为本地时间(考虑到本地时区和夏令时标志)
            gmtime      -   将日历时间转换为协调统一时间的年、月、日、时、分、秒、周日分解结构

        #include <time.h>
        time_t mktime(struct tm *tmptr);

        返回值:
            成功,返回日历时间
            出错,返回-1

        函数说明:
            mktime函数以本地时间的年、月、日等作为参数,将其转换成time_t值

        size_t strftime(char *restrict buf, size_t maxsize, const char *restrict format,
                        const struct tm *restrict tmptr);
        size_t strftime_l(char *restrict buf, size_t maxsize, const char *restrict format,
                        const struct tm *restrict tmptr, locale_t locale);
        char *strptime(const char *restrict buf, const char *restrict format, 
                        struct tm *restrict tmptr);

第七章、    进程环境
    1、 进程终止
        进程终止的8种方式:
            正常终止:
                1)  从main返回
                2)  调用exit
                3)  调用_exit 或 _Exit
                4)  最后一个线程从其启动例程返回
                5)  从最后一个线程调用pthread_exit
            异常终止:
                6)  调用abort
                7)  接到一个信号
                8)  最后一个线程对取消请求做出响应

        1\  退出函数

            #include <stdlib.h>
            void exit(int status);
            void _Exit(int status);
            #include <unistd.h>
            void _exit(int status);

            函数说明:
                3个函数用于正常终止一个程序
                _exit 和 _Exit 立即进入内核
                exit 则先执行一些清理处理,然后返回内核;执行一个标准I/O库的清理关闭操作,
                        对所有打开的流调用fclose函数.

                3个函数都带一个整型参数,称为终止状态(exit status)

        2\  函数 atexit
            ISO C规定,一个进程最多可以登记32个函数,这些函数将由exit自动调用.
            我们称这些函数为终止处理程序(exit handler),并调用atexit函数来登记这些函数

            #include <stdlib.h>
            int atexit(void (*func)(void));

            返回值:
                成功,返回0
                出错,返回非0

            函数说明:
                atexit的参数是一个函数地址,当调用此函数时无需向他传递任何参数,也不期望它返回一个值.
                exit调用这些函数的顺序与它们登记的时候的顺序相反,同一函数如若登记多次,也会被调用多次.

            一个C程序如何启动:
                1)  内核开始,调用exec函数族中一个,启动一个C启动例程
                2)  C启动例程调用main函数,main函数再调用其他用户函数
            C程序的终止方式:
                3)  C启动例程、main函数和用户函数调用exit函数,
                    然后exit函数调用终止处理程序和标准I/O清理程序,
                    清理程序返回之后,由exit函数返回内核,_exit或_Exit
                4)  也可由mian函数或用户函数直接调用_exit或_Exit直接返回内核

            atexit函数测试程序,见Chapter_7/atexit.c

    2、 命令行参数  char *argv[]
        当执行一个程序时,调用exec的进程可将命令行参数传递给该新程
        ISO C和POSIX.1要求argv[argc]是一个空指针,即argv数组以NULL结尾

    3、 环境表
        每个程序都接收到一张环境表,与参数表一样,环境表也是一个字符指针数组,其中每个指针包含一个
        以null结束的C字符串的地址,全局变量environ则包含了该指针数组的地址
            extern char **environ;
        可使用getenv 和 putenv函数来访问特定的环境变量,当要查看整个环境时,使用environ指针

    4、 C程序的存储空间布局
        C程序的组成部分:
            1)  正文段  -   这是由CPU执行的机器指令部分,通常是可共享的,频繁被执行的程序在存储器中
                            只需要保留一个副本,只读属性,防止被修改
            2)  初始化数据段    -   也称为数据段,包含了程序中需明确的赋初值的变量
            3)  未初始化数据段  -   也称为bss(block started by symbol)段,在程序开始执行之前,内核通过
                                    exec将此段中的数据初始化为0或空指针

            4)  栈      -   自动变量以及每次函数调用时所需保存的信息都存放在此段中.
                            每次函数调用时,其返回地址以及调用者的环境信息(如某些机器寄存器的值)都存放
                            在栈中,然后,最近被调用的函数在栈上为其自动和临时变量分配存储空间.
                            递归函数每次调用自身时,就用一个新的栈帧,因此一次函数调用实例中的变量集不会
                            影响另一次函数调用实例中的变量.

            5)  堆      -   通常在堆中进行动态存储分配,位于未初始化数据段和栈之间

        注:
            栈从高地址向低地址方向增长,堆从低地址向高地址方向增长,
            通常,堆顶和栈顶之间未使用的虚拟地址空间很大
            未初始化数据段的内容并不存在在磁盘程序文件中,需要存放在磁盘程序文件中的段只有正文段
            和初始化数据段

            size 命令报告正文段、数据段、和未初始化数据段的长度
            size /usr/bin/cc    执行结果:
            text       data     bss     dec     hex filename
            755125     8536   81856  845517   ce6cd /usr/bin/cc

            text    -   正文段
            data    -   初始化数据段
            bss     -   未初始化数据段
            dec     -   十进制3段总长度
            hex     -   十六进制3段总长度

    5、 共享库
        可执行文件中不再需要包含公用的库函数,只需要在所有进程都可以引用的存储区中保存这种库例程的一个
        副本,程序第一次执行或者第一次调用某个库函数时,用动态链接方法将程序与共享库函数相链接.
        特点:
            1)  减少了每个可执行文件的长度
            2)  增加了第一次运行时间的开销
            3)  当共享库发生变换时,无需重新编译可执行文件

        gcc -static 选项组织gcc使用动态共享库

    6、 存储空间分配
        3个用于存储空间动态分配的函数
        1)  malloc  -   分配指定字节数的存储区,此存储区中的初始值不确定
        2)  calloc  -   为指定数量指定长度的对象分配存储空间,该空间中的每一位(bit)都初始化为0
        3)  realloc -   增加或减少以前分配区的长度,当增加长度时,可能需要将以前分配区的内容移动到
                        另一个足够大的区域,以便在尾端提供增加的存储区,而新增区域内的初始值则不确定.

        #include <stdlib.h>
        void *malloc(size_t size);
        void *calloc(size_t nobj, size_t size);
        void *realloc(void *ptr, size_t newsize);
        void free(void *ptr);

        前3个函数返回值:
            成功,返回非空指针
            出错,返回NULL

        函数说明:
            这3个函数所返回的指针一定是适当对齐的,使其可用于任何数据对象

        替代的存储空间分配程序
            1)  libmalloc   -   libmalloc库包括mallopt函数,它使进程可以设置一些变量,并用他们来控制存储
                                空间分配程序的操作,还可以使用另一个名为mallinfo的函数,以对存储空间分配
                                程序的操作进行统计.
            2)  vmalloc
            3)  quick-fit   -   快速分配,标准malloc算法是最佳适配或首次适配存储分配策略,quick-fit算法
                                比上述两种算法快,但会使用较多的存储空间.
                                该算法基于将存储空间分裂成各种长度的缓冲区,并将未使用的缓冲区按其长度
                                组成不同的空闲区列表
            4)  jemalloc    -   jemalloc函数实现是FreeBSD 8.0中的默认存储空间分配程序,它是库函数malloc
                                族在FreeBSD中的实现,它的设计具有良好的可扩展性,可用于多处理器系统中多
                                线程的应用程序
            5)  TCMalloc    -   Google-perftools开源工具中的一个,用来替代malloc函数族以提供高性能、高
                                扩展性和高存储效率;从高速缓存中分配缓冲区以及释放缓冲区到高速缓存中,
                                它使用线程-本地高速缓存来避免锁开销;它还有内置的堆检查程序和堆分析程序
                                帮助调试和分许动态存储的使用.
            6)  alloca函数  -   它的调用序列与malloc相同,但是它是在当前函数的栈帧上分配存储空间
                                优点: 当函数返回时,自动释放它所使用的栈帧
                                缺点: alloca函数增加了栈帧的长度,而某些系统在函数已被调用后不能增加栈
                                      帧长度,于是就不支持alloca函数

    7、 环境变量
        环境变量的解释权完全取决于各个应用程序,内核不关注环境变量
        name=value
        环境表和环境字符串通常存放在进程存储空间的顶部(栈之上),修改和新增环境变量很复杂

        #include <stdlib.h>
        char *getenv(const char *name);

        返回值:
            找到,返回指向与name关联的value的指针
            未找到,返回NULL

        函数说明:
            指定环境变量的name,获取当前进程环境变量的value值
    
        #include <stdlib.h>
        int putenv(char *str);      -   成功,返回0;出错,返回非0
        int setenv(const char *name, const char *value, int rewrite);
        int unsetenv(const char *name);

        后2个函数返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            putenv      -   取形式为name=value的字符串,将其输出到环境列表中;
                            如果name已经存在,则先删除原来value值
            setenv      -   将name设置为value;如果name已经存在:
                            a.  参数rewrite非0,则先删除其原有value值
                            b.  参数rewrite为0,则不删除原有值,name也不设置新值,返回也不出错
            unsetenv    -   删除name的value值,name不存在也不会报错


        POSIX.1定义的某些环境变量:
            COLUMNS         -   终端宽度
            DATEMSK         -   getdate模版文件路径名
            HOME            -   起始目录
            LANG            -   本地字符集
            LC_ALL          -   本地名
            LC_COLLATE      -   排序习惯
            LC_CTYPE        -   本地字符分类类型
            LC_MESSAGES     -   本地消息名
            LC_MONETARY     -   本地货币编辑名
            LC_NUMERIC      -   本地数字编辑名
            LC_TIME         -   本地日期/时间格式名
            LINES           -   终端高度
            LOGNAME         -   登录名
            MSGVERB         -   fmtmsg处理的消息组成部分
            NLSPATH         -   消息类模版序列
            PATH            -   搜索可执行文件的路径前缀列表
            SHELL           -   用户首选的shell名
            TERM            -   终端类型
            TMPDIR          -   在其中创建临时文件的目录路径名
            TZ              -   时区信息
           
    8、 setjmp 和 longjmp 函数

        #include <setjmp.h>
        int setjmp(jmp_buf env);
            返回值: 若直接调用,返回0;若从longjmp返回,则为非0
        void longjmp(jmp_buf env, int val);

        函数说明:
            在C中,goto语句是不能跨越函数的,执行跨越函数的跳转函数setjmp 和 longjmp
            setjmp  -   设置程序的返回点
            longjmp -   使用返回点,使程序进行跳转,参数val是跳转回返回点之后setjmp的返回值
                        一个setjmp可以有多个longjmp,longjmp的参数val可用于判断是哪个longjmp返回

            注:
                上述函数适合于,在C语言函数的深层嵌套层时,出现非致命性错误的处理方式
                无需逐层检查返回值的返回,本质是直接进行函数栈帧跳转,直接在栈上跳过若干调用帧
                
            见Chapter_7/jump.c 测试程序

    问题:
        自动变量、寄存器变量和易失变量
            当调用longjmp跳转返回点后,longjmp和返回点之间压入的栈帧会被丢弃,此时,各个函数的变量值
            不会自动回滚到调用setjmp之前,值是不确定的.
   
            gcc -O 编译时进行编译器优化
            在编译时不进行编译器优化时,在调用longjmp之后,各个变量的值是最近所呈现的值(最近一次赋值)
            在编译时进行编译器优化之后,存放在存储器中的变量将具有调用longjmp时的值,
            而存放在CPU和浮点寄存器中的变量则恢复为调用setjmp时的值.

            编译器不进行优化时,所有种类的变量都存放在存储器中,即忽略了register的类型说明
            而进行编译器优化后,自动变量和register类型变量都会存放在寄存器中,
            volatitle声明的变量仍然存放在存储器中

        重点:
            如果要编写使用非局部跳转的可移植程序,必须使用volatitle属性,禁止编译器对该属性变量进行优化

            见Chapter_7/longjmp.c 测试程序,测试longjmp对各类变量的影响

    9、 getrlimit 和 setrlimit 函数     -   查询和更改资源限制
        
        #include <sys/resource.h>
        int getrlimit(int resource, struct rlimit *rlptr);
        int setrlimit(int resource, const struct rlimit *rlptr);

        返回值:
            成功,返回0
            出错,返回非0

        函数说明:
            进程的资源限制通常是在系统初始化时由0进程建立,然后由后续进程继承
            对这两个函数的每一次调用都指定一个资源以及一个指向下列结构的指针:
                struct rlimit {
                    rlim_t rlim_cur;    /* soft limit: current limit */
                    rlim_t rlim_max;    /* hard limit: maximum value for rlim_cur */
                };
            在更改资源限制时,须遵守以下规则:
                a.  任何一个进程都可将一个软限制值更改为小于或等于其硬限制值
                b.  任何一个进程都可降低其硬限制值,但它必须大于或等于其软限制值;
                    这种降低对普通用户而言是不可逆向的
                c.  只有超级用户进程可以提高硬限制值

            常量RLIM_INFINITY指定一个无限量的限制
            resource参数取下列值之一:
                RLIMIT_AS       -   进程总的可用存储空间的最大长度(字节数),这影响到sbrk函数和mmap函数
                                    sbrk(动态内存分配) mmap(创建共享内存映射)
                RLIMIT_CORE     -   core文件的最大字节数,若值为0则阻止该进程创建core文件
                RLIMIT_CPU      -   CPU时间的最大量值(秒),若超过此软限制时,向该进程发送SIGXCPU信号
                RLIMIT_DATA     -   数据段的最大字节数,初始化数据段、非初始化数据段和堆的总和
                RLIMIT_FSIZE    -   创建的文件的最大字节长度;当超过该限制时,向该进程发送SIGXFSZ信号
                RLIMIT_MEMLOCK  -   一个进程使用mlock能够锁定在存储空间中的最大字节数
                RLIMIT_MSGQUEUE -   进程为POSIX消息队列可分配的最大存储字节数
                RLIMIT_NICE     -   此值影响进程调度的优先级,nice可设置的最大限制
                RLIMIT_NOFILE   -   每个进程能打开的最大文件数;更改此限制将影响到sysconf函数在参数
                                    _SC_OPEN_MAX 中的返回值
                RLIMIT_NPROC    -   每个实际用户ID可拥有的最大子进程数;更改此限制将影响到sysconf函数
                                    在参数_SC_CHILD_MAX中的返回值
                RLIMIT_NPTS     -   用户可以打开的伪终端最大数量
                RLIMIT_RSS      -   最大驻内存集字节长度(resident set size in bytes,RSS)
                                    如果可用的物理存储器非常少,则内核将从进程处取回超过RSS的部分
                RLIMIT_SBSIZE   -   在任一给定时刻,一个用户可以占用的套接字缓冲区的最大长度
                RLIMIT_SIGPENDING   一个进程可排队的信号最大数量;这个限制是sigqueue函数实施的
                RLIMIT_STACK    -   栈的最大字节长度
                RLIMIT_SWAP     -   用户可消耗的交换空间的最大字节数
                RLIMIT_VMEM     -   RLIMIT_AS的同义词
            资源限制影响到调用进程并由其子进程继承,所以为了影响一个用户的后续所有进程,需将资源限制
            的设置构造在shell之中.
                ulimit 命令可查看当前shell

第八章、    进程控制
    1、 进程标识
        
        #include <unistd.h>
        pid_t getpid(void);         -   返回调用进程的进程ID
        pid_t getppid(void);        -   返回调用进程的父进程ID
        uid_t getuid(void);         -   返回调用进程的实际用户ID
        uid_t geteuid(void);        -   返回调用进程的有效用户ID
        gid_t getgid(void);         -   返回调用进程的实际组ID
        gid_t getegid(void);        -   返回调用进程的有效组ID

    2、 fork 函数       -   创建一个新进程

        #include <unistd.h>
        pid_t fork(void);

        返回值:
            子进程,返回0
            父进程,返回子进程ID
            出错,返回-1

        函数说明:
            写时复制(Copy-On-Write)
        
        注:
            fork函数会将缓冲区的数据同样复制一份给子进程,所以在fork之前要考虑缓冲区内容问题
            可调用fflush冲洗缓冲区
            fork函数创建的子进程会中的已经打开的文件描述符会和父进程共享同一个文件表项,所以父子进程
            会共享同一个文件偏移量

        子进程会继承父进程的属性:
            文件描述符表
            实际用户ID、实际组ID、有效用户ID、有效组ID
            附属组ID
            进程组ID
            会话ID
            控制终端
            设置用户ID标志和设置组ID标志
            当前工作目录
            根目录
            文件模式创建屏蔽字
            信号屏蔽和安排
            对任一打开文件描述符的执行时关闭标志(close-on-exec)
            环境变量
            连接的共享存储段
            存储映像
            资源限制

        子进程与父进程之间的区别:
            子进程的tms_utime、tms_stime、tms_cutime 和 tms_ustime的值设置为0
            子进程不会继承父进程设置的文件锁
            子进程的未处理闹钟被清除
            子进程的未处理信号集设置为空集

        fork函数可能调用失败的两个主要原因:
            a.  系统中已经存在太多进程
            b.  该实际用户ID的进程总数超过了系统限制    CHILD_MAX

        fork的两种用法:
            a.  一个父进程希望复制自己,使父进程和子进程同时执行不同的代码段
            b.  一个进程要执行不同的程序,这种情况下,子进程从fork返回后立即调用exec(组合在一起叫做spawn)

    2、 vfork 函数
        
        pid_t vfork(void);      -   与fork函数的调用序列和返回值相同(在可移植程序中不建议使用)

        函数说明:
            vfork函数用于创建一个新进程,而该新进程的目的是exec一个新程序
            vfork在创建子进程后,并不将父进程的地址空间完全复制到子进程中,因为子进程会立即调用exec
            vfork 与 fork 之间的另一个区别是:
                vfork 保证子进程先运行,在它调用exec 或 exit之后父进程才可能被调度运行,当子进程调用这
                两个函数中的任意一个时,父进程才会恢复运行,如果在调用这两个函数之前子进程依赖于父进程
                的进一步动作,则会导致死锁
            在vfork创建的子进程中修改变量的值会导致父进程中的变量值发生改变

    3、 exit 函数
        在进程终止方式中:
            a.  调用exit函数,次函数由ISO C定义,其操作包括调用各种终止处理程序(atexit函数登记的处理函数),
                然后关闭所有标准I/O流等
            b.  调用_exit 或 _Exit 函数,ISO C定义_Exit,其目的是为进程提供一种无需运行终止处理程序或
                信号处理程序就能终止的方法,在UNIX系统中,_Exit 和 _exit是同义,并不冲洗标准I/O流.
                在UNIX系统的实现中,exit() 是标准C库中的一个函数,而_exit()是一个系统调用

    4、 wait 和 waitpid 函数
        当调用wait 或 waitpid 的进程会产生的3种情况:
            a.  如果其所有子进程都还在运行呢,则阻塞
            b.  如果一个子进程已终止,正等待父进程获取其终止状态,则取得该子进程的终止状态后立即返回
            c.  如果该进程没有任何子进程,则出错返回

        #include <sys/wait.h>
        pid_t wait(int *statloc);
        pid_t waitpid(pid_t pid, int *statloc, int options);

        返回值:
            成功,返回进程ID
            出错,返回0或-1

        函数说明:
            在一个子进程终止前,wait 使其调用者阻塞,而waitpid有一选项,可使调用者不阻塞
            waitpid 并不等待在其调用之后的第一个终止子程序,可以控制它所等待的进程

            参数statloc 是一个整型指针,如果statloc不是一个空指针,则终止进程的终止状态就存放在它所指向
            的单元内;传NULL则不关心终止进程的返回状态

            终止状态用定义在<sys/wait.h>中的各个宏来查看,有4个互斥的宏可用来取得进程终止的原因:
            WIFEXITED(status)       -   若为正常终止子进程返回的状态,则为真.可执行WEXITSTATUS(status)
                                        获取子进程传送给exit 或 _exit 参数的低8位

            WIFSIGNALED(status)     -   若为异常终止子进程返回的状态,则为真(接到一个不捕捉的信号);
                                        可执行WTERMSIG(status),获取使子进程终止的信号编号

            WIFSTOPPED(status)      -   若为当前暂停子进程的返回状态,则为真;
                                        可执行WSTOPSIG(status),获取使子进程暂停的信号编号

            WIFCONTINUED(status)    -   若在作业控制暂停后已经继续的子进程返回了状态,则为真

            见src/pr_exit.c and Chapter_8/printExit.c

            waitpid 函数pid参数:
                pid == -1   -   等待任一子进程,此时,waitpid 和 wait 等效 
                pid >  0    -   等待进程ID 与 pid 相等的子进程
                pid == 0    -   等待组ID等于调用进程组ID的任一子进程
                pid <  -1   -   等待组ID等于pid绝对值的任一子进程
            options 参数:
                WCONTINUED  -   若实现作业控制,那么由pid指定的任一子进程在停止后已经继续,返回其状态
                WNOHANG     -   若由pid指定的子进程并不是立即可用的,则waitpid不阻塞,此时返回值为0
                WUNTRACED   -   子进程停止且未报告状态,返回其状态

            见 Chapter_8/waitpid.c

    5、 waitid 函数

        #include <sys/wait.h>
        int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);

        返回值:
            成功,返回0
            出错,返回-1
        函数说明:
            与waitpid相似,waitid允许一个进程指定要等待的子进程.
            waitid 可以使用两个单独的参数表示要等待的子进程所属的类型
            id参数的值与idtype的值相关,idtype的类型如下:
                P_PID   -   等待一个特定进程:id包含要等待子进程的进程ID
                P_PGID  -   等待一个特定进程组的任一子进程:id包含要等待子进程的进程组ID
                P_ALL   -   等待任一子进程:忽略id 
            options参数是如下各标志的按位或运算,这些标志指示调用者关注哪些状态变化.
                WCONTINUED  -   等待一进程,它以前曾被停止,此后又已继续,但其状态尚未报告
                WEXITED     -   等待已退出的进程
                WNOHANG     -   如无可用的子进程退出状态,立即返回而非阻塞等待
                WNOWAIT     -   不破坏子进程退出状态,该子进程退出状态可由后续的wait、waitpid 获得
                WSTOPPED    -   等待一进程,它已经停止,但其状态尚未报告.
            infop参数是指向siginfo结构的指针,该结构包含了造成子进程状态改变有关信号的详细信息

    6、 wait3 和 wait4 函数 
        
        #include <sys/types.h>
        #include <sys/wait.h>
        #include <time.h>
        #include <sys/resource.h>
        
        pid_t wait3(int *statloc, int options, struct rusage *rusage);
        pid_t wait4(pid_t pid, int *statloc, int options, struct rusage *rusage);

        返回值:
            成功,返回进程ID
            出错,返回-1

        函数说明:
            相比wait\waitpid\waitid所提供的功能多一个,这与附加参数有关.
            该参数允许内核返回由终止进程及其所有子进程使用的资源概况.
            资源统计信息包括用户CPU时间总量、系统CPU时间总量、缺页次数、接收到信号的次数等

    7、 竞序条件


    8、 exec 函数
        exec函数的作用是用磁盘上的一个新程序替换当前进程的正文段、数据段、堆段、和栈段

        #include <unistd.h>
        int execl(const char *pathname, const char *arg0, ... /* (char *)0 */);
        int execv(const char *pathname, char *const argv[]);
        int execle(const char *pathname, const char *arg0, ... /* (char *)0, char *const envp[] */);
        int execve(const char *pathname, char *const argv[], char *const envp[]);
        int execlp(const char *filename, const char *arg0, ... /* (char *)0 */);
        int execvp(const char *filename, char *const arhv[]);
        int fexecve(int fd, char *const argv[], char *const envp[]);

        返回值:
            成功,不返回
            出错,返回-1

        函数说明:
            前4个函数取路径名作为参数,后两个函数则取文件名作为参数,最后一个函数取文件面舒服作为参数
            当指定filename作为参数时:
                a.  如果filename中包含/,就将其视为路径名
                b.  否则就按PATH环境变量在它所指定的各个目录中搜寻可执行文件

            参数表传递的方式(l表示列表list,v表示矢量vector),函数execl/execlp/execle要求将新程序的
            每个命令行参数都说明为一个单独的参数,这种参数表以空指针结尾
            对于另外4个函数,则应先构造一个指向各参数的指针数组,然后将该数组地址作为这4个函数的参数

            传递环境表的方式,以e结尾的3个函数(execle\execve\fexecve)可以传递一个指向环境字符串指针数组
            指针,当需要子进程不完全继承父进程环境变量时使用.
            其他4个函数则使用调用进程中的environ变量为新程序复制现有的环境

        注:
            这7个函数中只有execve是内核的系统调用,另外6个是库函数,这6个最终都会调用execve

        见Chapter_8/execExample.c

    9、 更改用户ID和更改组ID
        目的:访问控制,当需要访问当前并不允许访问的资源是,我们需要更换自己的用户ID或组ID,使新ID具有
            合适的访问权限

        #include <unistd.h>
        int setuid(uid_t uid);
        int setgid(gid_t gid);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            更改ID的规则:
                a.  若进程具有超级用户权限,则setuid函数将实际用户ID、有效用户ID以及保存的
                    设置用户ID(saved set-user-ID)设置为uid.
                b.  若进程没有超级用户权限,但是uid等于实际用户ID或保存的设置用户ID,则setuid 
                    只将有效用户ID设置为uid,不更改实际用户ID和保存的设置用户ID 
                c.  以上条件都不满足,则errno设置为EPERM,并返回-1

        关于内核所维护的3个用户ID:
            a.  只有超级用户进程可以更改实际用户ID;通常,实际用户ID是在用户登录时,由login程序设置的,
                而且绝不会改变它;因为login是个超级用户进程,当它调用setuid时,设置所有3个用户ID
            b.  仅当对程序文件设置了设置用户ID位时,exec函数才设置有效用户ID;如果没有设置,则
                exec函数不会改变有效用户ID,而维持现有值.
            c.  保存的设置用户ID是由exec复制有效用户ID得到的

        #include <unistd.h>
        int setreuid(uid_t ruid, uid_t euid);
        int setregid(gid_t rgid, gid_t egid);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            交换实际用户(组)ID 和有效用户ID的值
            如果其中任一参数的值为-1,则表示相应的ID应当保持不变
            一个非超级用户总能交换实际用户ID和有效用户ID

        #include <unistd.h>
        int seteuid(uid_t uid);
        int setegid(gid_t gid);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            只更改有效用户ID和有效组ID
    
    10、    system 函数

        #include <stdlib.h>
        int system(const char *cmdstring);

        函数说明:
            当cmdstring是一个空指针,则当命令处理程序可用时,system返回非0值,这一特征可以确定在一个给定
            的操作系统上是否支持system函数.
            因为system在其实现中调用了fork、exec和waitpid,因此有3种返回值
            1)  fork失败或者waitpid返回除EINTR之外的错误,则system返回-1,并且设置errno以指示错误类型
            2)  如果exec失败(表示不能执行shell),则其返回值如同shell执行了exit一样
            3)  否则所有3个函数都成功,那么system的返回值是shell的终止状态

    11、    用户标示
        一个用户可以在口令文件中有多个登录项,它们的用户ID相同,但登录shell不同

        #include <unistd.h>
        char *getlogin(void);

        返回值:
            成功,返回指向登录名字符串的指针
            出错,返回NULL 

        函数说明:
            获取用户登录名
            如果调用此函数的进程没有连接到用户登录时所用的终端,则函数会调用失败,
            通常称这些进程为守护进程

    12、    进程调度
        进程通过调整nice值来降低它对CPU的占有,nice值越小,优先级越高
        (你越友好,你的调度优先级就越低)

        #include <unistd.h>
        int nice(int incr);

        返回值:
            成功,返回新的nice值NZERO
            出错,返回-1

        函数说明:
            进程可以通过nice函数获取或更改它的nice值,使用此函数,进程只能影响自己的
            nice值,不能影响任何其他进程的nice值
            
            参数incr被增加到调用进程的nice值上,如果incr太大,系统直接把它降低到最大合法值
            如果,incr太小,系统也会把它提高到最小合法值
            由于-1是合法的成功返回值,在调用nice之前需要清空errno,在nice返回-1时,需要检查
            errno的值.

        #include <sys/resource.h>
        int getpriority(int which, id_t who);

        返回值:
            若成功,返回-NZERO~NZERO-1 之间的nice值
            出错,返回-1

        函数说明:
            getpriority函数可以像nice函数那样用于获取进程的nice值,还可以获取一组相关进程的nice值

            which参数可以取以下三个值之一:
                PRIO_PROCESS    -   表示进程
                PRIO_PGRP       -   表示进程组
                PRIO_USER       -   表示用户ID
            which参数控制who参数是如何解释的,who参数选择感兴趣的一个或多个进程
            如果who参数为0,表示调用进程、进程组或者用户,取决于which参数的值 
            当which设为PRIO_USER并且who为0时,使用调用进程的实际用户ID
            如果which参数作用于多个进程,则返回所有作用进程中优先级最高的(最小的nice值)

        #include <sys/resource.h>
        int setpriority(int which, id_t who, int value);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            setpriority函数可用于为进程、进程组和属于特定用户ID的所有进程设置优先级
            参数which和who 与getpriority函数中相同,value增加到NZERO上,然后变为新的nice值

        nice值影响,见Chapter_8/niceTest.c

    13、    进程时间

        #include <sys/times.h>
        clock_t times(struct tms *buf);

        返回值:
            成功,返回流逝的墙上时钟时间(以时钟滴答数为单位)
            出错,返回-1

        函数说明:
            任何一个进程都可以调用times函数获得它自己以及已终止子进程的3个时间值(墙上时钟时间、
                    用户CPU时间和系统CPU时间)

            参数buf是一个指向tms结构的指针,传入参数
                struct tms {
                    clock_t tms_utime;  /* user CPU time */
                    clock_t tms_stime;  /* system CPU time */
                    clock_t tms_cutime; /* user CPU time,terminated children */
                    clock_t tms_cstime; /* system CPU time,terminated children */
                }
            此结构没有墙上时钟时间,times函数将墙上时钟时间作为函数返回值返回
            获取墙上时钟时间方式(调用times,保存返回值,在以后某个时间再次调用,两次相减)
            
            所有有此函数返回的clock_t值都用_SC_CLK_TCK(有syscong函数返回的每秒时钟滴答数)转换成秒数

            测试程序见Chapter_8/timesTest.c

第9章、 进程关系
    
    1、 终端登录
        登录过程:
            1)  init进程读取/etc/ttys, 为每个个终端执行fork,创建空环境
            2)  fork的子进程成调用exec gettty,getty 调用open函数打开终端设备,
                然后getty输出"login:"之类的信息,并等待用户输入,读取用户名,初始化环境集
            3)  getty 再次exec login (execle("/bin/login", "login", "-p", username, (char *)0, envp));
            4)  login 调用getpwnam 取得相应用户的口令文件登录项,然后调用getpass以显示提示"Password:",
                接着读取用户输入,与阴影口令文件作比较

        用户正确登录后,login将执行以下工作:
            a.  将当前工作目录更改为该用户的起始目录(chdir)
            b.  调用chown更改该终端的所有权,使登录用户成为它的所有者
            c.  将对该终端设备的访问权限改变成"用户读和写"
            d.  调用setgid 及 initgroups 设置进程的组ID
            e.  用login得到的所有信息初始化环境:起始目录(HOME)、shell(SHELL)、
                用户名(USER和LOGNAME)以及一个系统默认路径(PATH)
            f.  login 进程更改为登录用户的用户ID(setuid)并调用该用户的登录shell,其方式类似于:
                execl("/bin/sh", "-sh", (char *)0);

    2、 网络登录
        在网络登录的情况下,login仅仅是一种可用的服务
        网络连接时,所有的登录都经由内核的网络接口驱动程序(如以太网驱动程序),因此必须等待一个网络连接请求的到达
        伪终端处理网络登录

        当通过终端或者网络登录时,我们得到了一个登录shell,其标准输出、标准输入和标准错误要么连接到一个终端设备
        要么连接到一个伪终端设备上.
        登录到一个shell将是一个POSIX.1会话的开始,而此终端或伪终端则是会话的控制终端.

    3、 进程组 

        进程组是一个或多个进程的集合,同一进程组中的各个进程接受来自同一终端的各种信号.

        #include <unistd.h>
        pid_t getpgrp(void);

        返回值:
            调用进程的进程组ID

        #include <unistd.h>
        pid_t getpgid(pid_t pid);

        返回值:
            成功,返回进程组ID 
            出错,返回-1

        函数说明:
            若参数pid是0,则返回调用进程的进程组ID
            getpgid(0); 等效于 getpgrp();

        每个进程组有一个组长进程,组长进程的进程组ID等于其进程ID
        进程组组长可以创建一个进程组、创建该组中的进程,然后终止

        #include <unistd.h>
        int setpgid(pid_t pid, pid_t pgid);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            进程调用setpgid可以加入现有的进程组或者创建一个新进程组
            setpgid函数将pid进程的进程组ID设置为pgid,如果这两个参数相等,则由pid指定的进程
            变成进程组组长
            如果pid是0,则使用调用者的进程ID;如果pgid是0,则由pid指定的进程ID用作进程组ID.
            一个进程只能为它自己或它的子进程设置进程组ID,在它的子进程调用exec之后,它就不能
            在更改该子进程的进程组ID.

    4、 会话(session)
        会话是一个或多个进程组的集合

        #include <unistd.h>
        pid_t setsid(void);

        返回值:
            成功,返回进程组ID
            出错,返回-1

        函数说明:
            进程调用setsid函数建立一个新会话
            如果调用此函数的进程不是一个进程组的组长,则此函数创建一个新会话,调用之后会发生的3件事:
                a.  该进程变成新会话的会话首进程(session leader),此时,该进程是新会话中的唯一进程
                b.  该进程成为一个新进程组的组长进程,新进程组ID是该调用进程的进程ID
                c.  该进程没有控制终端.

            注:
                进程组组长进程不可调用此函数,会出错返回.

        #include <unistd.h>
        pid_t getsid(pid_t pid);

        返回值:
            成功,返回会话首进程的进程组ID
            出错,返回-1

        函数说明:
            getsid函数返回会话首进程的进程组ID(可理解为会话ID)
            若pid是0,getsid返回调用进程的会话首进程的进程组ID
            不能返回pid不属于调用者所在会话的首进程的进程组ID

    5、 控制终端
        会话和进程组还有一些其他特性:
            a.  一个会话可以有一个控制终端(controlling terminal),终端设备或伪终端设备
            b.  建立与控制终端连接的会话首进程被称为控制进程(controlling process)
            c.  一个会话中的几个进程组可被分成一个前台进程组(foreground process group)以及 
                或多个后台进程组(background process group)
            d.  如果一个会话有一个控制终端,则它有一个前台进程组,其他进程组为后台进程组
            e.  无论何时键入终端的中断键,都会将中断信号发送至前台进程组的所有进程
            f.  无论何时键入终端的退出键,都会将退出信号发送至前台进程组的所有进程.
            g.  如果终端接口检测到调制解调器(或网络)已经断开连接,则将挂断信号发送至控制进程(会话首进程)
    
    6、 tcgetpgrp、tcsetpgrp 和 tcgetsid 函数
        
        #include <unistd.h>
        pid_t tcgetpgrp(int fd);
        返回值:
            成功,返回前台进程组ID
            出错,返回-1

        int tcsetpgrp(int fd, pid_t pgrpid);
        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            需要有一种方法来通知内核哪一个进程组是前台进程组,这样,终端设备驱动程序就能知道
            将终端输入和终端产生的信号发送到何处

            函数tcgetpgrp返回前台进程组ID,它与在fd上打开的终端相关联
            如果进程有一个控制终端,则该进程可以调用tcsetpgrp将前台进程组ID设置为pgrpid;pgrpid值
            应当是在同一会话中的一个进程组的ID,fd必须引用该会话的控制终端

        #include <termios.h>
        pid_t tcgetsid(int fd);

        返回值:
            成功,返回会话首进程的进程组ID
            出错,返回-1

        函数说明:
            给出控制TTY的文件描述符,通过tcgetsid函数,应用程序就能获得会话首进程的进程组ID
            需要管理控制终端的应用程序可以调用tcgetsid函数识别出控制终端的会话首进程的会话ID

    7、 作业控制
        作业控制允许在一个终端上启动多个作业(进程组),它控制哪一个作业可以访问该终端以及哪些作业在后台运行
        作业控制要求以下3种形式的支持:
            a.  支持作业控制的shell
            b.  内核中的终端驱动程序必须支持作业控制
            c.  内核必须提供对某些作业控制信号的支持
    
    8、 shell执行程序
    
    9、 孤儿进程组

第10章、    信号
    1、 概念
        信号是软件中断,信号提供了一种处理异步事件的方法
        在头文件<signal.h>中,信号名都被定义为正整数常量(信号编号),信号的实现定义在<bits/signum.h>中(linux)
        不存在编号为0的信号
        
        产生信号的条件:
            1)  当用户按某些终端键时,引发终端产生信号
            2)  硬件异常产生信号: 除数为0、无效的内存引用等
                这些条件通常由硬件检测到,并通知内核;然后内核为该条件发生时正在运行的进程产生适当的心海
            3)  进程调用kill函数可将任意信号发送给另一个进程或进程组
                接受信号进程和发送信号进程的所有者必须相同,超级用户发送信号无限制
            4)  用户可以使用kill命令将信号发送给其他进程;此命令只是kill函数的接口
            5)  当检测到某种软件条件已经发生,并应将其通知有关进程时也产生信号
                如在网络连接上传来带外的数据产生的SIGURG、在管道的读进程已经终止后,一个进程写此管道
                产生的SIGPIPE、进程设置的定时器超时产生的SIGALRM

        当信号随机产生时,可以告诉内核的3种处理方式:
            1)  忽略此信号  -   大多数信号都可以使用这种方式处理,但有两种信号不能被忽略(SIGKILL和SIGSTOP)
                                不能被忽略的原因是:它们向内核和超级用户提供了使进程终止或停止的可靠方法

            2)  捕捉信号    -   为了做到这一点,要通知内核在某种信号发生时,调用一个用户函数
                                SIGKILL 和 SIGSTOP 不能被捕捉

            3)  执行系统默认动作    -   对大多数信号的系统默认动作是终止该进程

        信号类型及说明:
            SIGABRT     -   异常终止(abort)         abort 函数产生
            SIGALRM     -   定时器超时(alarm)       alarm 函数和 setitimer函数
            SIGBUS      -   硬件故障                某些类型的内存故障
            SIGCANCEL   -   线程库内部使用      
            SIGCHID     -   子进程状态发生改变
            SIGCONT     -   使暂停进程继续          此作业控制发送给需要继续运行但当前处于停止状态的进程
            SIGEMT      -   硬件故障
            SIGFPE      -   算术异常                如除以0、浮点溢出等
            SIGFREEZE   -   检查点冻结
            SIGHUP      -   连接断开                检查到连接断开后将此信号发送给该终端的会话首进程
            SIGILL      -   非法硬件指令
            SIGINFO     -   键盘状态请求
            SIGINT      -   终端中断符              当用户按终端键,终端驱动程序产生此信号并发送至前台进程组
            SIGIO       -   异步I/O                 指示一个异步I/O事件
            SIGIOT      -   硬件故障                
            SIGKILL     -   终止 
            SIGPIPE     -   写至无读进程的管道      SOCK_STREAM类型的套接字已不再连接时,进程写该套接字也产生
            SIGPOLL     -   可轮询事件(poll)
            SIGPROF     -   硬概时间超时(setitimer)
            SIGPWR      -   电源失效/重启动         主要用于具有不间断电源(UPS)的系统
            SIGQUIT     -   终端退出符              用户按键,终端驱动程序产生,发送给前台进程组中的所有进程
            SIGSEGV     -   无效内存引用            通常说明程序有错,如访问了一个未初始化的指针
            SIGSTKFLT   -   协处理器栈故障
            SIGSTOP     -   停止
            SIGSYS      -   无效系统调用
            SIGTRAP     -   硬件故障 
            SIGTSTP     -   终端停止符              停止交互,挂起信号  
            SIGTERM     -   终止                    kill命令发送的系统默认终止信号,让程序优雅的退出(做清理工作)
            SIGTTIN     -   后台读控制tty
            SIGTTOU     -   后台写向控制tty
            SIGURG      -   紧急情况(套接字)
            SIGUSR1     -   用户定义信号
            SIGUSR2     -   用户定义信号 
            SIGVTALRM   -   虚拟时间闹钟(setitimer) setitimer函数设置的虚拟间隔时间已经超时时产生
            SIGWINCH    -   终端窗口大小改变        内核维持与每个终端或伪终端相关联窗口的大小,可用ioctl设置
            SIGXCPU     -   超过CPU限制(setrlimit)
            SIGFSZ      -   超过文件长度限制(setrlimit)
        下列条件下不产生core文件:
            a.  进程是设置用户ID的,而且当前用户并非程序文件的所有者
            b.  进程是设置组ID的,而且当前用户并非程序文件的组所有者
            c.  用户没有写当前工作目录的权限
            d.  文件已经存在,而且用户对该文件没有写权限
            e.  文件太大,超过最大文件限制(RLIMIT_CORE)

    2、 signal 函数 
        
        #include <signal.h>
        void (*signal(int signo, void (*func)(int)))(int);

        返回值:
            成功,返回以前的信号处理配置
            出错,返回SIG_ERR

        函数说明:
            UNIX系统信号机制最简单的接口函数
            不可靠信号语义函数,应当使用sigaction代替

            signo参数是信号名,func参数的值是常量SIG_IGN、常量SIG_DFL或当接到此信号要调用的函数地址
            指定SIG_IGN,则向内核表示忽略此信号
            指定SIG_DFL,则向内核表示接到此信号后的动作是系统默认动作
            指定函数地址时,则在信号发生时,调用该函数,称此函数为信号处理函数(signal handler),
                            或称为信号捕捉函数(signal-catching function)

            signal函数原型说明此函数要求有两个参数,返回一个函数指针,而该指针所指向的函数无返回值(void)
            signal函数的返回值是一个函数地址,该函数有一个整型参数(即最后的(int));即signal的返回函数指针
            指向的是在此之前的信号处理程序的指针
            typedef void Sigfunc(int);      -   Sigfunc(int) 是一个拥有一个int参数且无返回值的函数类型
            Sigfunc *signal(int, Sigfunc *);
            等效于:
            void (*signal(int, void(*func)(int)))(int);

            <signal.h>中:
                #define SIG_ERR (void (*)())-1
                #define SIG_DFL (void (*)())0
                #define SIG_IGN (void (*)())1
            表示:   指向函数的指针,该函数要求一个整型参数,而且无返回值

            见Chapter_9/signalTest.c

            注:
                当一个进程调用fork时,其子进程继承父进程的信号处理方式,因为子进程在开始时复制了父进程的
                内存映像,所以信号捕捉函数的地址在子进程中是有意义的
                当子进程执行exec后,则不继承父进程的信号处理方式,exec函数将原有设置为捕捉的信号都更改为
                默认处理动作

    3、 不可靠的信号    -   可能会丢失的信号
        
        当进行信号捕捉操作时,每个信号第一次被捕捉处理以后,随即将该信号动作重置为默认处理动作

    4、 中断的系统调用
        当进程在执行一个低速系统调用而阻塞期间捕捉到一个信号,则该系统调用就被中断返回不再继续执行;
        该系统调用返回出错,其errno被设置为EINTR

        注:
            当捕捉到某个信号时,被中断的是内核中执行的[系统调用].
        系统调用可以分为两类: 低速系统调用和其他系统调用
            低速系统调用    -   是可能会使进程永远阻塞的一类系统调用

            4.2BSD引进了某些被中断系统调用的自动重启动
            自动重启动的系统调用包括:
                ioctl、read、readv、write、writev、wait、waitpid
            POSIX.1要求只有中断信号的SA_RESTART标志有效时,实现才重启动系统调用

    5、 可重入函数
        可重入  -   在进程正在执行正常指令序列时被信号处理程序临时中断,它首先执行该信号处理程序中的指令
                    如果在信号处理程序中返回(没有调用exit或longjmp),则继续执行在捕捉到信号时进程正在执行
                    的正常指令序列(类似于硬件中断)

        不可重入函数的特点:
            a.  已知它们使用静态数据结构
            b.  它们调用malloc 或 free
            c.  它们是标准I/O函数,标准I/O库的很多实现都以不可重入方式使用全局数据结构

            注:
                信号处理程序有可能会中断主程序中的printf函数调用,所以产生的结果是不可预期的
                信号处理程序应当调用可重入函数,但是由于每个线程只有一个errno变量,所以信号处理程序有可能
                修改其原有值,因此,【应当在信号处理程序调用函数之前先保存errno的值,在调用之后恢复errno】
        
        见Chapter_10测试程序arlarmTest.c

    6、 SIGCLD 语义 (Centos 8 不支持此信号)
        对于SIGCLD信号的处理方式:
            如果进程明确的将该信号的配置设置为SIG_IGN,则调用进程的子进程将不产生僵死进程

        SIGCHLD信号可以被忽略,在被忽略时,4.4BSD总是产生僵死进程;
        在SVR4中,如果调用signal或sigset将SIGCHLD的配置设置为忽略,则绝不会产生僵尸进程
        使用sigaction可设置SA_NOCLDWAIT标志以避免进程僵死

    7、 可靠信号术语和语义
        当造成信号的[事件]发生时,为进程产生一个信号(或向一个进程发生一个信号)
        事件可以是硬件异常(如除以0)、软件条件(如alarm定时器超时)、终端产生的信号或调用kill函数
        当一个信号产生时,内核通常在进程表中以某种形式设置一个标志

        当对信号采取了某种动作时,称为向进程[递送]了一个信号;
        在信号产生(generation)和递送(delivery)之间的时间间隔内,称信号是未决的(pending)

        进程可以选用[阻塞信号递送];如果为进程产生了一个阻塞的信号,而且对该信号的动作是系统默认动作
        或捕捉该信号,则为该进程将此信号保持在未决状态,直到该进程对此信号解除阻塞,或者将对此信号的动作
        更改为忽略

        内核在[递送]一个原来被阻塞的信号给进程时,才决定对它的处理方式,而不是在信号产生时决定处理方式.
        所以,进程在信号递送给它之前仍可改变对该信号的动作
        进程调用sigpending函数来判定哪些信号是设置为阻塞并处于未决状态的

        如果在进程解除对某个信号的阻塞之前,这个信号发生了多次,POSIX.1允许系统递送该信号一次或多次
        如果递送该信号多次,则称这些信号进行了排队.

        每个进程都有一个信号屏蔽字(signal mask),它规定了当前要阻塞递送到该进程的信号集;对于没中可能的信号,
        该屏蔽字都有一位与之对应,对于某种信号,若其对应位置已设置,则它当前是被阻塞的
        进程可以调用sigprocmask来检测和更改其当前信号屏蔽字

        信号编号可能会超过一个整型所包含的二进制位数,因此POSIX.1定义了一个新数据类型sigset_t,
        它可以容纳一个信号集.

    8、 kill 函数和 raise 函数
        
        #include <signal.h>
        int kill(pid_t pid, int signo);
        int raise(int signo);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            kill函数将信号发送给进程或进程组
            raise函数则允许进程向自身发送信号
            
            调用raise(signo) 等价于 kill(getpid(), signo);

            kill的pid参数有以下4种不同的情况:
                pid >  0    -   将该信号发送给进程ID为pid的进程
                pid == 0    -   将该信号发送给于发送进程属于同一进程组的所有进程
                pid <  0    -   将该信号发送给其进程组ID等于pid绝对值,
                                而且发送进程具有权限向其发送信号的所有进程
                pid == -1   -   将该信号发送给发送进程有权限向它们发送信号的所有进程(不包括系统进程集中的进程)

            进程将信号发送给其他进程需要权限,超级用户可以将信号发送给任一进程
            对于非超级用户,其基本规则是发送者的实际用户ID或有效用户ID必须等于接收者的实际用户ID或有效ID
            如果实现支持_POSIX_SAVED_IDS,则检查接收者的保存设置用户ID(而不是有效ID)

            权限特例:
                如果被发送的信号是SIGONT,则进程可将它发送给属于同一会话的任一其他进程

            POSIX.1将信号编号0定义为空信号,如果参数signo为0,则kill仍执行正常的错误检查,但不发送信号,
            这常被用来确定一个特定进程是否仍然存在,如果向一个不存在的进程发送空信号,则kill返回-1,
            errno被设置为ESRCH

    9、 alarm 和 pause 函数
        
        #include <unistd.h>
        unsigned int alarm(unsigned int seconds);

        返回值:
            返回0或以前设置的闹钟时间的剩余秒数

        函数说明:
            使用alarm函数可以设置一个定时器(闹钟),在将来的某个时刻该定时闹钟会超时;当闹钟
            定时器超时时,产生一个SIGALRM信号,如果忽略或不捕捉此信号,则其默认动作是终止调用该函数的进程

            参数seconds的值是产生信号SIGALRM需要经过的时钟秒数,当这一时刻到达时,信号由内核产生

            每个进程只能有一个闹钟时间,如果在调用alarm时,之前已为该进程注册的闹钟时间还没有超时,则该
            闹钟时间的剩余值作为本次alarm函数调用的值返回,以前注册的闹钟时间则被新值代替

            如果有以前注册的尚未超时的闹钟时间,而且本地调用的seconds值是0,则取消以前的闹钟时间,剩余值
            作为函数返回值返回

            注:
                先注册信号处理程序再调用alarm,否则在注册信号处理程序之前接收到SIGALRM信号,程序将终止

        #include<unistd.h>
        int pause(void);

        返回值:
            返回-1,errno设置为EINTR

        函数说明:
            pause函数使调用进程挂起直到捕捉到一个信号
            只有执行了一个信号处理程序并从其返回时,pause才会返回.

        见Chapter_10/sleep1.c sleep2.c    使用函数alarm 和 pause

        除了用来实现sleep函数外,alarm还常用于对可能阻塞的操作设置时间上限值
        在程序中慢速系统调用在阻塞期间,我们希望超过一定时间值后就停止等待
        见Chapter_10/limitRead.c    带时间限制的read函数

    10、    信号集  -   表示多个信号的数据类型(singnal set)

        #include <signal.h>
        int sigemptyset(sigset_t *set);
        int sigfillset(sigset_t *set);
        int sigaddset(sigset_t *set, int signo);
        int sigdelset(sigset_t *set, int signo);

        返回值:
            成功,返回0
            出错,返回-1

        int sigismember(const sigset_t *set, int signo);

        返回值:
            若真,返回1
            若假,返回0

        函数说明:
            sigemptyset -   初始化由set指向的信号集,清除其中所有信号
            sigfillset  -   初始化由set指向的信号集,使其包括所有信号
            sigaddset   -   将一个信号添加到已有的信号集中
            sigdelset   -   将一个信号从已有的信号集中删除
            sigismember -   判断一个信号在不在集合内

        函数实现原理:   见Chapter_10/sigset.c

    11、    sigprocmask 函数    -   检测和更改进程的信号屏蔽字

        #include <signal.h>
        int sigprocmask(int how, const sigset_t *restrict set, sigset_t *restrict oset);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            若参数oset是非空指针,则进程的当前信号屏蔽字通过oset返回
            若参数set 是一个非空指针,则参数how指示如何修改当前的信号屏蔽字,how的可选值如下:
                SIG_BLOCK   -   该进程新的信号屏蔽字是其[当前信号屏蔽字和set指向信号集的并集],
                                set包含了希望[阻塞]的附加信号
                
                SIG_UNBLOCK -   进程新的信号屏蔽字是[当前信号屏蔽字和set所指向信号集补集的交集],
                                set包含了希望[解除阻塞]的信号

                SIG_SETMASK -   该进程新的信号屏蔽字是[set指向的值]

            如果set是个空指针,则不改变该进程的信号屏蔽字,how的值也无意义
            注:
                在调用sigprocmask后,如果有任何未决的、不再阻塞的信号,则在sigprocmask返回前至少将其中之一递送给进程
                sigprocmask 仅是单线程进程定义的,不可用在处理多线程进程中的信号屏蔽.

            见src/pr_mask.c

    12、    sigpending 函数 -   返回当前未决信号集

        #include <signal.h>
        int sigpending(sigset_t *set);

        返回值:
            成功,返回0
            出错,返回-1

        见Chapter_10/signalSet.c

    13、    sigaction 函数  -   检查或修改与指定信号相关的处理动作(代替signal函数)

        #include <signal.h>
        int sigaction(int signo, const struct sigaction *restrict act, struct sigaction *restrict oact);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            参数signo是要检测或修改其具体动作的信号编号
            若act指针不为空,则要修改其处理动作
            若oact指针非空,则系统经由oact指针返回该信号的上一个动作
            此函数使用下列数据结构:
                struct sigaction {
                    void     (*sa_handler)(int);    /* addr of signal handler, or SIG_IGN, or SIG_DFL*/
                    sigset_t sa_mask;               /* additional signals to block */
                    int         sa_flags;           /* signal options */

                    void (*sa_sigactionn)(int, siginfo_t *, void *);    /* alternate handler */
                }
            当更改信号处理动作时,如果sa_handler字段包含一个信号捕捉处理函数的地址,则sa_mask字段说明了一个信号集,
            在调用该信号捕捉函数之前,这一信号集要加到进程的信号屏蔽字中
            当从信号捕捉函数返回时,再将进程的信号屏蔽字恢复为原有值

            一旦对给定的信号设置了一个处理动作,那么在调用sigaction显式改变它之前,该设置就一直有效

            act结构的sa_flags字段指定对信号进行处理的各个选项,如下:
                SA_INTERRUPT    -   由此信号中断的系统调用不自动重启动(sigaction默认处理方式)
                SA_NOCLDSTOP    -   若signo是SIGCHLD,当子进程停止(作业控制),不产生此信号;当子进程终止仍旧产生此信号
                SA_NOCLDWAIT    -   若signo是SIGCHLD,则当调用进程的子进程终止时,不创建僵尸进程;
                                    若调用进程随后调用wait,则阻塞到它所有子进程都终止,此时返回-1,errno设置ECHILD
                SA_NODEFER      -   当捕捉到此信号时,在执行其信号捕捉函数时,系统不自动阻塞该信号(除非sa_mask包括了
                                    此信号)
                SA_ONSTACK      -   若用sigaltstack已声明了一个替换栈,则此信号传递送给替换栈上的进程
                SA_RESETHAND    -   在此信号捕捉函数的入口处,将此信号的处理方式重置为SIG_DFL,并清除SA_SIGINFO标志;
                                    但是不能自动重置SIGILL和SIGTRAP这两个信号的配置
                SA_RESTART      -   由此信号中断的系统调用自动重启动
                SA_SIGINFO      -   此选项对信号处理程序提供了附加信息:一个指向siginfo结构的指针以及一个指向
                                    进程上下文标识符的指针

            sa_sigaction字段是一个替代信号处理程序,在sigaction结构中使用了SA_SIGINFO标志时,使用该信号处理程序.
            对于sa_sigaction字段和sa_handler字段两者,实现可能使用同一存储区,所以应用只能一次使用这两个字段中的一个
            通常,按下列方式调用信号处理程序:
                void handler(int signo);
            但是,当设置了SA_SIGINFO标志时,按下列方式调用:
                void handler(int signo, siginfo_t *info, void *context);

            siginfo结构体:
                struct siginfo {
                    int         si_signo;       /* signal number */
                    int         si_errno;       /* if nonzero, errno value from <errno.h> */
                    int         si_code;        /* additional info (depends on signal) */
                    pid_t       si_pid;         /* sending process ID */
                    uid_t       si_uid;         /* sending process real user ID */
                    void        *si_addr;       /* address that caused the fault */
                    int         si_status;      /* exit value or signal number */
                    union sigval si_value;      /* application-specific value */
                    /* possibly other fields also */
                };
            sigval 联合体包含以下字段:
                int   sival_int;
                void  *sival_ptr;
            应用程序在递送信号时,在si_value.sival_int中传递一个整型数或在si_value.sival_ptr中传递一个指针值.

            若信号是SIGCHLD,则将设置si_pid、si_status和si_uid字段;
            若信号是SIGBUS、SIGILL、SIGFPRE或SIGSEGV,则si_addr包含造成故障的根源地址(该地址可能不准确),
            si_errno字段包含错误编号,对应造成信号产生的条件

            信号处理程序的context参数是无类型指针,它可被强制类型转换为ucontext_t结构类型,该结构标识信号传递时进程的
            上下文,该结构包含的字段:    
                ucontext_t      *uc_link;       /* pointer to context resumed when */
                                                /* this context returns */
                sigset_t        uc_sigmask;     /* signals blocked when this context is active */
                stack_t         us_stack;       /* stack used by this context */
                mcontext_t      uc_mcontext;    /* machine-specific representation of saved context */

                uc_stack 字段描述了当前上下文使用的栈,包括以下成员:
                    void    *ss_sp;     /* stack base or pointer */
                    size_t  ss_size;    /* stack size */
                    int     ss_flags;   /* flags */

        见src/signal.c  用sigaction实现signal函数

    14、    sigsetjmp 和 siglongjmp 函数

        调用longjmp有一个问题,当捕捉到一个信号时,进入信号捕捉函数,此时当前信号被自动的加到进程的信号屏蔽字中,
        这阻止了后来产生的这种信号中断该信号处理程序

        #include <setjmp.h>
        int sigsetjmp(sigjmp_buf env, int savemask);

        返回值:
            若直接调用,返回0
            若从siglongjmp调用返回,则返回非0

        void siglongjmp(sigjmp_buf env, int val);

        函数说明:
            在信号处理程序中进行非局部转移调用上述函数.
            这两个函数和setjmp、longjmp之间的唯一区别是sigsetjmp增加了一个参数
            如果savemask非0,则sigsetjmp在env中保存进程的当前信号屏蔽字
            调用siglongjmp时,如果带非0savemask的sigsetjmp调用已经保存了env,则siglongjmp从其中恢复保存的信号屏蔽字

        见Chapter_10/sigsetjmp.c 演示了在信号处理程序被调用时,系统所设置的信号屏蔽字如何自动的包括刚被捕捉到的信号
        也说明如何使用sigsetjmp和siglongjmp函数

        注:
            在siglongjmp返回时,会恢复在sigsetjmp处保存的进程屏蔽字,而setjmp达不到这种效果

    15、    sigsuspend 函数 -   原子操作(先恢复信号屏蔽字,解除阻塞,然后使进程休眠(pause))
        
        #include <signal.h>
        int sigsuspend(const sigset_t *sigmask);

        返回值:
            返回-1,并将errno设置为EINTR

        函数说明:
            进程的信号屏蔽字设置为由参数sigmask指向的值
            在捕捉到一个信号或发生了一个会终止该进程的信号之前,该进程被挂起
            如果捕捉到一个信号而且从该信号的处理程序中返回,则sigsuspend返回,
            并且该进程的信号屏蔽字设置为调用sigsuspend之前的值

        见Chapter_10/sigsuspend.c   保护代码临界区,使其不被特定信号中断的正确方法
        见Chapter_10/sigsuspend2.c  等待一个信号处理程序设置一个全局变量
        见Chapter_10/sigsuspend3.c  用信号实现父、子进程之间的同步

    16、    abort 函数  -   使调用程序异常终止

        #include <stdlib.h>
        void abort(void);

        函数说明:
            此函数将SIGABRT信号发送给调用进程,调用abort将向主机环境递送一个未成功终止的通知,其方法是
            调用raise(SIGABRT)函数

            ISO C要求若捕捉到此信号而且相信信号处理程序返回,abort仍不会返回到其调用者
            如果捕捉到此信号,则信号处理程序不能返回的唯一方法是调用exit、_exit、_Exit、longjmp或siglongjmp
            POSIX.1说明abort并不会理会进程对此信号的阻塞和忽略

            让进程捕捉SIGABRT的意图是:在进程终止之前由其执行所需的清理操作;
            如果进程并不在信号处理程序中终止自己,POSIX.1声明当信号处理程序返回时,abort终止该进程

            见Chpater_10/abort.c    abort的POSIX.1实现
    
    17、    system 函数
        POSIX.1 要求system忽略SIGINT和SIGQUIT,阻塞SIGCHLD
        见Chpater_10/systemTT.c   

        由此程序可知:
            当在父进程创建子进程时,终端发送SIGINT信号时,将发送给整个前台进程组每个进程(shell、父进程、子进程)
            但是,当调用system运行另一个程序时,不应使父、子进程两者都捕捉终端产生的两个信号:中断和退出
            这两个信号只应该发送给正在运行的程序:子进程.
            因为由system执行的命令可能是交互式命令,以及因为system的调用者在程序执行时放弃了控制,等待该执行程序的结束
            所以system的调用者就不应该接受这两个终端产生的信号

            所以,POSIX.1规定system的调用者在等待命令完成时应当忽略这两个信号

        见Chapter_10/sigSystem.c    进行了所要求的信号处理的system函数实现

    18、    sleep、nanosleep 和 clock_nanosleep 函数

        #include <unistd.h>
        unsigned int sleep(unsigned int seconds);

        返回值:
            0或未休眠完的秒数

        函数说明:
            此函数使调用进程被挂起直到满足下面两个条件之一:
                a.  已经过了seconds所指定的墙上时钟时间             -   返回0
                b.  调用进程捕捉到一个信号并从信号处理程序返回      -   返回剩余秒数

        见Chapter_10/sigSleep.c 是一个POSIX.1 sleep函数的实现,可以可靠的处理信号,避免了竞序条件

        #include <time.h>
        int nanosleep(const struct timespec *reqtp, struct timespec *remtp);

        返回值:
            若休眠到要求的时间,返回0
            出错,返回-1

        函数说明:
            nanosleep 函数与sleep函数类似,但提供了纳秒级的精度
            此函数挂起调用进程,直到要求的时间已经超时或者某个信号中断了该函数;
            reqtp参数用秒和纳秒指定了需要休眠的时间长度
            如果某个信号中断了休眠间隔,进程并没有终止,remtp参数指向的timespec结构就会被设置为
            剩余的休眠时间长度,可以传NULL

        #include <time.h>
        int clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *reqtp, struct timespec *remtp);

        返回值:
            若休眠到要求的时间,返回0
            出错,返回错误码

        函数说明:
            随着多个系统时钟的引入,需要使用相对于特定时钟的延迟时间来挂起调用线程
            clock_id参数指定了计算延迟时间基于的时钟(时钟标识符查看第6章)
            flags 参数用于控制延迟是相对还是绝对的;
                flags为0时表示休眠时间是相对的(例如,希望休眠的时间长度)
                flags设置为TIMER_ABSTIME,表示休眠时间是绝对的(例如,希望休眠到时钟到达某个特定的时间)
            reqtp 和 remtp参数与nanosleep函数中相同
            使用绝对时间时,remtp参数未使用

    19、    sigqueue 函数
        通常一个信号带有一个位信息:信号本身
        除了对信号排队以外,这些扩展允许应用程序在递交信号时传递更多的信息,这些信息嵌入在siginfo结构中
        除了系统提供的信息,应用程序还可以向信号处理程序传递整数或者指向包含更多信息的缓冲区指针
        使用排队信号必须做以下几个操作:
            1)  使用sigaction函数安装信号处理程序时指定SA_SIGINFO标志,如果没有给出这个标志,信号会延迟
                但信号是否进入队列要取决于具体实现

            2)  在sigaction结构的sa_sigaction成员中提供信号处理程序,实现可能允许用户使用sa_handler字段,
                但是不能获取sigqueue函数发送出来的额外信息

            3)  使用sigqueue函数发送信号

        #include <signal.h>
        int sigqueue(pid_t pid, int signo, const union sigval value);

        返回值:
            若成功,返回0
            出错,返回-1

        函数说明:
            sigqueue函数只能把信号发送给单个进程,可以使用value参数向信号处理程序传递整数和指针值
            除此之外,sigqueue函数与kill函数类似

        信号不能被无限排队,取决于系统限制SIGQUEUE_MAX,到达相应的限制以后,sigqueue就会失败,将errno设为EAGIN

        随着实时信号的增强,引入了用于应用程序的独立信号集,这些信号的编号在SIGRTMIN~SIGRTMAX之间,包括这两个
        限制值,这些信号的默认行为是终止进程

    20、    作业控制信号
        POSIX.1 认为与作业控制有关的6个信号:
            SIGCHLD     -   子进程已停止或终止
            SIGCONT     -   如果进程已停止,则使其继续运行
            SIGSTOP     -   停止信号(不能被捕捉或忽略)
            SIGTSTP     -   交互式停止信号
            SIGTTIN     -   后台进程组成员读控制终端
            SIGTTOU     -   后台进程组成员写控制终端
        除SIGCHLD以外,大多数应用程序并不处理这些信号,交互式shell则通常会处理这些信号的所有工作

        见Chapter_10/SIGTSTP.c  实现如何处理SIGTSTP信号

    21、    信号名和编号    -   如何在信号编号和信号名之间映射

        #include <signal.h>
        void psignal(int signo, const char *msg);

        函数说明:
            可移植的打印与信号编号对应的字符串
            字符串msg(通常是程序名)输出到标准错误文件,后面跟随一个冒号和一个空格,在后面对该信号的说明,
            最后是一个换行符;如果msg为NULL,只有信号说明部分输出到标准错误文件,该函数类似于perror

        #include <signal.h>
        void psiginfo(const sigingo_t *info, const char *msg);

        函数说明:
            如果在sigaction信号处理程序中有siginfo结构,可以使用psiginfo函数打印信号信息

        #include <string.h>
        char *strsignal(int signo);

        返回值:
            指向描述该信号的字符串的指针

        函数说明:
            如果只需要信号的字符描述部分,也不需要把它写到标准错误文件中(可以写到日志文件中),可以使用
            strsignal函数,它类似于strerror
            给出一个信号编号,strsignal将返回描述该信号的字符串,应用程序可用该字符串打印关于接收到信号的出错信息.

        #include <signal.h>
        int sig2str(int signo, char *str);
        int str2sig(const char *str, int *signop);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            一个将信号编号映射为信号名,另一个反之

第十一章、  线程

    1、线程概念
        线程的优点:
            a.  通过为每种事件类型分配单独的处理线程,可以简化处理异步事件的代码;
                每个线程在进行事件处理时可以采用同步编程模式,同步编程模式要比异步编程模式简单

            b.  多个进程必须使用操作系统提供的复杂机制才能实现内存和文件描述符的共享,而多个线程
                在同一进程下可以访问相同存储地址空间和文件描述符

            c.  有些问题可以分解从而提高整个程序的吞吐量
                在只有一个控制线程的情况下,一个单线程要完成多个任务,只需要把这些任务串行化;
                在有多个控制线程时,相互独立的任务处理就可以交叉进行,此时只需要为每个任务分配一个单独的线程

            d.  交互的程序同样可以通过使用多线程来改善响应时间,多线程可以把程序中处理用户输入输出的部分与
                其他部分分开

        每个线程都包含有表示执行环境所必需的信息,其中包括进程中标识线程的线程ID、一组寄存器值、栈、调度优先级和
        策略、信号屏蔽字、errno变量以及线程私有数据
        
        一个进程的所有信息对该进程中的所有线程都是共享的,包括可执行程序的代码、程序的全局内存和堆内存、栈以及
        文件描述符

    2、 线程标识    -   线程id(pthread_t tid)
        线程ID只有在它所属的进程上下文中才有意义
        线程ID的数据类型是pthread_t, 该结构不能把它作为整数处理(不同系统实现方式不同)

        #include <pthread.h>
        int pthread_equal(pthread_t tid1, pthread_t tid2);

        返回值:
            若相等,返回非0数值
            不想等,返回0

        函数说明:
            用来比较两个线程ID是否相等

        #include <pthread.h>
        pthread_t pthread_self(void);

        返回值:
            调用线程的线程ID

        函数说明:
            获取自身的线程ID

    3、 线程创建
        
        #include <pthread.h>
        int pthread_create(pthread_t *restrict tidp, const pthread_attr_t *restrict attr,
                            void *(*start_rtn)(void *), void *restrict arg);

        返回值:
            成功,返回0
            出错,返回错误编号

        函数说明:
            当pthread_create成功返回时,新创建线程的线程ID会被设置成tidp指向的内存单元
            attr参数用于定制各种不同的线程属性
            新创建的线程从start_rtn函数的地址开始运行,该函数只有一个无类型指针参数arg
            线程创建时并不能保证哪个线程会先运行

            新创建的线程可以访问进程的地址空间,并且继承调用线程的浮点环境和信号屏蔽字,但是该线程的
            挂起信号集会被清除

            pthread函数在调用失败时通常会返回错误码,并不像其他的POSIX函数一样设置errno

            见Chapter_11/pthread_create.c  创建并打印线程ID

    4、 线程终止
        进程中任意线程调用了exit、_Exit 或者 _exit,那么整个进程就会终止
        单个线程可以通过3种方式退出:
            1)  线程可以简单的从启动例程中返回,返回值是线程的退出码
            2)  线程可以被同一进程中的其他线程取消
            3)  线程调用pthread_exit

        #include <pthread.h>
        void pthread_exit(void *rval_ptr);

        函数说明:
            rval_ptr参数是一个无类型指针,与传给启动例程的单个参数类似
            进程中的其他线程也可以通过调用pthread_join函数访问到这个指针

        #include <pthread.h>
        int pthread_join(pthread_t thread, void **rval_ptr);

        返回值:
            成功,返回0
            出错,返回错误编号

        函数说明:
            调用此函数的线程将一直阻塞,直到指定的线程调用pthread_exit、从启动例程中返回或者被取消
            如果线程从它的启动例程中返回,rval_ptr就包含了返回码
            如果线程被取消,由rval_ptr指定的内存单元就设置为PTHREAD_CANCELED

            可以通过调用pthread_join自动把线程设置为分离状态,这样资源就会被自动释放
            如果线程已经处于分离状态,pthread_join调用就会失败返回,返回EINVAL

            如果对线程的返回值并不感兴趣可以把rval_ptr设置为NULL,这种情况下,调用pthread_join函数可以等待
            指定的线程终止,但不获取线程的终止状态

            见Chapter_11/getExitCode.c  获取已终止线程的退出码
            见Chapter_11/pthread_exit.c pthread_exit参数的不正确使用

        #include <pthread.h>
        int pthrenad_cancel(pthread_t tid);

        函数返回值:
            成功,返回0
            出错,返回错误编号

        函数说明:
            线程通过调用pthread_cancel函数来请求取消同一进程中的其他线程

            注:
                pthread_cancel函数并不等待线程终止,它仅仅提出请求

        #include <pthread.h>
        void pthread_cleanup_push(void (*rtn)(void *), void *arg);
        void pthread_cleanup_pop(int execute);

        函数说明:
            线程可以安排它退出时需要调用的函数,类似于进程退出时可以用atexit函数安排退出
            这样的函数称为线程清理处理程序(thread cleanup handler),一个线程可以建立多个清理处理程序
            处理程序记录在栈中,也就是说,它们的执行顺序与它们的注册时间相反

            当线程执行一下动作时,清理函数rtn是由pthread_cleanup_push函数调度的,调用时只有一个参数arg:
                a.  调用pthread_exit时
                b.  响应取消请求时
                c.  用非零execute参数调用pthread_cleanup_pop时
            如果execute参数设置为0,清理函数将不被调用
            不管发生上述哪种情况,pthread_cleanup_pop都将删除上次pthread_cleanup_push调用建立的清理处理程序

        注:
            当线程是从启动例程中返回而终止的话,它的清理处理程序就不会被调用

            这些函数有一个限制,由于它们可以实现为宏,所以必须在与线程相同的作用域以匹配对的形式使用
            pthread_cleanup_push的宏定义可以包含字符{,这种情况下,在pthread_cleanup_pop的定义中要有
            对应的匹配字符}.

        见Chapter_11/cleanupPth.c   使用线程清理处理程序的例子

        默认情况下,线程的终止状态会保存直到对该线程调用pthread_join;
        如果线程已经被分离,线程的底层存储资源可以在线程终止时立即被收回,
        在线程分离后,我们不能用pthread_join函数等待它的终止状态,因为对分离状态的线程调用pthread_join会
        产生未定义行为

        #include <pthread.h>
        int pthread_detach(pthread_t tid);

        返回值:
            成功,返回0
            出错,返回错误号

        函数说明:
            调用pthread_detach分离线程
