第一章、UNIX基础知识
    1、 程序和进程
        1\  程序
            程序(program)是一个存储在磁盘上某个目录中的可执行文件,内核使用exec函数(7个exec
            函数之一),将程序读入到内存,并执行程序.
        2\  进程
            程序的执行实例被称为进程.

    2、 出错处理
        打印出错信息的函数
        1)  #include <string.h>
            char *strerror(int errnum);
            
            返回值: 指向错误信息字符串的指针

        2） #include <stdio.h>
            void perror(const char *msg);
            
            perror 函数基于errno的当前值,在标准错误上产生一条出错信息
            它首先输出由msg指向的字符串,然后是一个冒号一个空格,接着是对用于errno值的错误信息

    3、 用户标识
        1\  用户ID
            通常每个用户有一个唯一的用户ID
            用户ID为0的用户为root用户或超级用户superuser
            如果一个进程具有超级用户特权,则大多数文件权限检查都不在进行

        2\  组ID
            对于磁盘上的每个文件,文件系统都存储该文件所有者的用户ID和组ID,存储这两个值需要4个字节
            如果使用完整的ASCII登录名和组名,则需要更多的磁盘空间,另外,在检验权限期间,比较字符串较之
            比较整型数更消耗时间.

        3\  附属组ID
            允许一个用户至多属于16个其他的组

    4、 信号(signal)
        信号用于通知进程发生了某种情况,进程有以下3种处理信号的方式
        1)  忽略信号,有些信号表示硬件异常,例如除以0或访问进程地址空间以外的存储单元等,
            因为这些异常产生的后果不确定,所以不推荐使用这种处理方式
        2)  按系统默认方式处理,大多数信号的默认处理方式是终止该进程
        3)  提供一个函数,信号发生时调用该函数,这被称为捕捉该信号

    5、 时间值
        1\  日历时间
            time_t
        2\  进程时间(CPU时间)
            clock_t
            UNIX系统为一个进程维护了3个进程时间值:
            时钟时间        -   墙上时钟时间,它是进程运行的时间总量
            用户CPU时间     -   是执行用户指令所用的时间量
            系统CPU时间     -   是为该进程执行内核程序所经历的时间
            time 命令查看进程时间

    6、 系统调用和库函数
        1)  所有的操作系统都提供多种服务的入口点,由此程序向内核请求服务.各种版本的UNIX实现都提供
            良好定义、数量有限、直接进入内核的入口点,这些入口点被称为系统调用.

第二章、    UNIX标准及实现
    1、 sysconf、pathconf和fpathconf 函数   -   获取系统的运行时限制值
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        #include <unistd.h>
        long sysconf(int name);
        long pathconf(const char *pathname, int name);
        log  fpathconf(int fd, int name);
                                    3个函数返回值:成功返回相应值,出错,返回-1
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        后面两个函数的差别是:一个用路径名作为其参数,另一个则取文件描述符做为参数.
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        sysconf(int name) name的可传入值:
                限制名                  说明                        name参数
            ARG_MAX         exec函数的参数最大长度(字节)            _SC_ARG_MAX
            ATEXIT_MAX      可用atexit函数登记的最大函数个数        _SC_ATEXIT_MAX
            CHILD_MAX       每个实际用户ID的最大进程数              _SC_CHILD_MAX
            时钟滴答/秒     每秒时钟的滴答数                        _SC_CLK_TCK
            COLL_WEIGHTS_MAX在本地定义文件中可以赋予LC_COLLATE
                            顺序关键字项的最大权重数                _SC_COLL_WEIGHTS_MAX
            DELAYTIMER_MAX  定时器最大超限运行次数                  _SC_DELAYTIMER_MAX
            HOST_NAME_MAX   gethostname函数返回的主机名最大长度     _SC_HOST_NAME_MAX
            IOC_MAX         readv或writev函数可以使用最多的
                            iovec结构的个数                         _SC_IOV_MAX

            LINE_MAX        实用程序输入行的最大长度                _SC_LINE_MAX
            LOGIN_NAME_MAX  登录名的最大长度                        _SC_LOGIN_NAME_MAX
            NGROUPS_MAX     每个进程同时添加的最大进程组ID数        _SC_NGROUPS_MAX
            OPEN_MAX        每个进程最大打开的文件数                _SC_OPEN_MAX
            PAGESIZE        系统存储页长度(字节数)                  _SC_PAGESIZE
            PAGE_SIZE       系统存储页长度(字节数)                  _SC_PAGE_SIZE
            RE_DUP_MAX      regexec和regcomp允许的正则重复次数      _SC_RE_DUP_MAX
            RTSIG_MAX       为应用程序预留的实时信号的最大个数      _SC_RTSIG_MAX
            SEM_NSEMS_MAX   一个进程可使用的信号量最大个数          _SC_SEM_NSEMS_MAX
            SEM_VALUE_MAX   信号量的最大值                          _SC_SEM_VALUE_MAX
            SIGQUEUE_MAX    一个进程可排队信号的最大个数            _SC_SIGQUEUE_MAX
            STREAM_MAX      一个_SC_STREAM_MAX进程在任意给定时刻    _SC_STREAM_MAX
                            标准I/O流的最大个数,如果定义,必须与
                            FOPEN_MAX的值相同

            SYMLOOP_MAX     在解析路径名时,可遍历的符号链接数       _SC_SYMLOOP_MAX
            TIMER_MAX       每个进程的最大定时器个数                _SC_TIMER_MAX
            TTY_NAME_MAX    终端设备名长度,包括终止null字符         _SC_TTY_NAME_MAX
            TZNAME_MAX      时区名中的最大字节数                    _SC_TZNAME_MAX
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        pathconf() 和 fpathconf() 的限制及name参数:
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
                限制名              说明                                name参数
            FILESIZEBITS    以带符号整型值表示在指定目录中允许的    _PC_FILESIZEBITS
                            普通文件最大长度所需的最小位(bit)数     

            LINK_MAX        文件链接计数的最大值                    _PC_LINK_MAX
            MAX_CANON       终端规范输入队列的最大字节数            _PC_MAX_CANON
            MAX_INPUT       终端输入队列可用空间的字节数            _PC_MAX_INPUT
            NAME_MAX        文件名的最大字节数(不包括null)          _PC_NAME_MAX
            PATH_MAX        相对路径名的最大字节数,包括null         _PC_PATH_MAX
            PIPI_BUF        能原子的写到管道的最大字节数            _PC_PIPE_BUF
            SYMLINK_MAX     符号链接的字节数                        _PC_SYMLINK_MAX
            _POSIX_TIMESTAMP_RESOLUTION
                            文件时间戳的纳秒精度                    _PC_TIMESTAMP_RESOLUTION
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

    2、 基本系统数据类型
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
            类型                说明
        clock_t         时钟滴答计数器(进程时间)
        comp_t          压缩的时钟滴答
        dev_t           设备号(主和次)
        fd_set          文件描述符集
        fpos_t          文件位置
        gid_t           数值组ID
        ino_t           i节点编号
        mode_t          文件类型,文件创建模式
        nlink_t         目录项的链接计数
        off_t           文件长度和偏移量(带符号的)(lseek)
        pid_t           进程ID和进程组ID(带符号的)
        pthread_t       线程ID
        ptrdiff_t       两个指针相减的结果
        rlim_t          资源限制
        sig_atomic_t    能原子性的访问的数据类型
        sigset_t        信号集
        size_t          对象(如字符串)长度(不带符号的)
        ssize_t         返回字节计数的函数(不带符号的)(read write)
        time_t          日历时间的秒计数器
        uid_t           数值用户ID
        wchar_t         能表示所有不同的字符码
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

第三章、    文件I/O

    1、 函数open 和 openat
        调用open 或 openat 函数可以打开或创建一个文件

        #include <fcntl.h>
        int open(const char *path, int oflag, ... /* mode_t mode */);
        int openat(int fd, const char *path, int oflag, ... /* mode_t mode */);
        
        两个函数的返回值:
            成功,返回文件描述符
            失败,返回-1
        参数详解:
            path    -   要打开或者创建的文件名字
            oflag   -   用来说明函数的多个选项(文件的打开模式)
            fd      -   fd 参数把open和openat区别开,共有三种可能性:
                        1)  path参数指定的是绝对路径名,在这种情况下,fd参数被忽略,openat = open
                        2)  path是相对路径名,fd参数指出相对路径名在文件系统中的开始地址,fd参数是通过
                            打开相对路径名所在的目录来获取
                        3)  path指定相对路径名,fd参数具有特殊值AT_FDCWD,在这种情况下,路径名在当前工作
                            目录中获取,openat 函数在操作上与open 函数类似

            oflag 的可选值: (用下列一个或多个常量进行"或"运算来构成oflag参数)
                O_RDONLY    -   只读打开
                O_WRONLY    -   只写打开
                O_RDWR      -   读、写打开
                O_EXEC      -   只执行打开
                O_SEARCH    -   只搜索打开(应用于目录)  -   常量的目的在于在目录打开时验证它的搜索权限

                在以上5个常量中必须指定一个且只能指定一个,一下常量可选:

                O_APPEND    -   每次写时都追加到文件的末尾
                O_CLOEXEC   -   把FD_CLOEXEC常量设置为文件描述符标志
                O_CREAT     -   若此文件不存在则创建,使用此选项时,open函数需同时说明第3个参数mode
                                (openat函数需说明第4个参数mode),用mode指定该新文件的访问权限位
                O_DIRECTORY -   如果path引用的不是目录,则出错
                O_EXCL      -   如果同时指定了O_CREAT,而文件已经存在,则出错.用此可以测试一个文件是否
                                存在,如果不存在,则创建此文件,这使测试和创建两者成一个原子操作
                O_NOCTTY    -   如果path引用的是终端设备,则不将该设备分配作为此进程的控制终端
                O_NOFLLOW   -   如果path引用的是一个符号链接,则出错
                O_NONBLOCK  -   如果path引用的是一个FIFO、一个块特殊文件或一个字特殊文件,则此选项为
                                文件的本次打开操作和后续的I/O操作设置非阻塞方式
                O_SYNC      -   使每次write等待物理I/O操作完成,包括由该write操作引起的文件属性
                                更新所需的I/O
                O_TRUNC     -   如果此文件存在,而且为只写或读-写成功打开,则将其长度截断为0
                O_TTY_INIT  -   如果打开一个还未打开的终端设备,设置非标准termios参数值,使其符合
                                Single UNIX Specification.
                O_DSYNC     -   使每次write要等待物理I/O操作完成,但是如果该写操作并不影响读取
                                刚写入的数据,则不需要等待文件属性被更新 -   (与O_SYNC有区别)
                O_RSYNC     -   使每一个以文件描述符作为参数进行的read操作等待,直至所有对文件同一
                                部分挂起的写操作都完成

            openat() 函数希望解决的问题:
                1)  让线程可以使用相对路径名打开目录中的文件,而不再只能打开当前工作目录,在同一进程中
                    的所有线程共享相同的当前工作目录,因此很难让同一个进程的多个不同线程在同一时间工作
                    在不同的目录中
                2)  可以避免time-of-check-to-time-of-use(TOCTTOU)错误
                    TOCTTOU错误的基本思想是: 如果有两个基于文件的函数调用,其中第二个调用依赖于第一个
                    调用的结果,那么程序是脆弱的,因为两个调用并不是原子操作,在两个函数调用之间文件可能
                    改变了,这样也就造成了第一个调用的结果就不再有效,使得程序最终的结果是错误的.

    2、 create 函数 -   创建一个新文件
        
        #include <fcntl.h>
        int creat(const char *path, mode_t mode);

        此函数等效于 open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);
        返回值:
            成功,返回为只写打开的文件描述符
            失败,返回-1

        create的局限性在于创建的文件返回的文件描述符是以只写的方式打开的,如果对此文件有读的需求就
        必须通过open函数。

    3、 colse 函数  -   关闭一个打开的文件

        #include <unistd.h>
        int close(int fd);

        返回值:
            成功,返回0
            失败,返回-1

        关闭一个文件时,还会释放该进程加在该文件上的所有记录锁

    4、 lseek   函数    -   设置文件偏移量
        
        #include <unistd.h>
        off_t lseek(int fd, off_t offset, int whence);

        注:
            按系统默认的情况,当打开一个文件时,除非指定O_APPEND选项,否则该偏移量被设置为0
            如果文件描述符指向的是一个管道、FIFO或网络套接字时,lseek返回-1,并将errno设置为ESPIPE
        返回值:
            成功,返回新的文件偏移量
            失败,返回-1
        参数:
            若whence是 SEEK_SET, 则将该文件的偏移量设置为距文件开始处offset 个字节
            若whence是 SEEK_CUR, 则将该文件的偏移量设置为其当前值加offset,offset可为正值或负值
            若whence是 SEEK_END, 则将该文件的偏移量设置为文件长度加offset,offset可为正值或负值

            文件偏移量可大于文件的当前长度,这种情况下,对该文件的下一次写将加长该文件,并在文件中构成一个
        空洞,位于文件中但是没有写过的字节都被读为0.
            文件中的空洞并不要求在磁盘上占用存储区,具体处理方式与文件系统的实现有关,当定位超出文件尾端
        之后写时,对于新写的数据需要分配磁盘块,但是对于原文件尾端和新开始写位置之间部分不需要分配磁盘块

        od -c [filename]    -   查看文件的实际内容, -c 标志表示以字符方式打印文件内容

    5、 read 函数   -   从打开的文件中读数据

        #include <unistd.h>
        ssize_t read(int fd, void *buf, size_t nbytes);

        返回值:
            成功,读到的字节数,若已到文件末尾,返回0
            失败,返回-1
        有多种情况可能使实际读到的字节数少于预计读的字节数:
            1)  读普通文件时,在读到要求字节数之前已到达文件末尾
            2)  当从终端设备读时,通常一次最多读一行(可改变)
            3)  当从网络读时,网络中的缓冲机制可能造成返回值小于所要求读的字节数
            4)  当从管道或FIFO读时,如若管道包含的字节少于所需的数量,那么read返回实际可用字节数
            5)  当从某些面向记录的设备(如磁带)读时,一次最多返回一个记录
            6)  当一信号造成终端,而已经读了部分数据量时

    6、 write 函数  -   向打开的文件中写数据

        #include <unistd.h>
        ssize_t write(int fd, const void *buf, size_t nbytes);

        返回值:
            成功,返回已经写入的字节数
            失败,返回-1

        其返回值通常与参数nbytes的值相同,否则表示出错,write出错的一个常见原因是磁盘已经写满,或者
        超过一个给定进程的文件长度限制

    7、 进程之间文件共享机制
        1\  内核使用3种数据结构表示打开的文件,它们之间的关系决定了在文件共享方面一个进程对另一个进程
            可能产生的影响
            1)  每个进程在进程表中都有一个记录项,记录项中包含一张打开文件描述符表,每个文件描述符占用
                一项,与每个文件描述符相关联的是:
                a.  文件描述符标志(close_on_exec)
                b.  指向一个文件表项的指针
            2)  内核为所有打开的文件维持一张文件表,每个文件表项包含:
                a.  文件状态标志(读、写、添写、同步和非阻塞等)
                b.  当前文件偏移量
                c.  指向该文件v(i)节点表项的指针
            3)  每个打开的文件(或设备)都有一个v节点(v-node)结构,v节点包含了文件类型和对此文件进行各种
                操作函数的指针,对于大多数文件,v节点还包含了该文件的i节点(i-node, 索引节点).
                这些信息是在打开文件时从磁盘上读入内存的,所以文件的所有相关信息都是随时可用的,例如
                i节点包含了文件的所有者、文件长度、指向文件实际数据块在磁盘上所在位置的指针等
                (Linux 没有使用v节点,而是使用了通用的i节点结构)
        
        当两个独立进程各自打开同一文件时,两个进程各自的进程表项纪录的文件描述符会各自指向一个记录打开
        文件的文件表项,文件表项参上2),但是各自的文件表项纪录的v节点指针指向同一个v节点表项
        *即每个进程都有它自己对该文件的当前偏移量
            a.  在完成每个write后,在文件表项中的当前文件偏移量即增加所写入的字节数,如果这导致当前
                文件偏移量超出了当前文件长度,则将i节点表项中的当前文件长度设置为当前文件偏移量
            b.  如果用O_APPEND标志打开了一个文件,则相应标志也被设置到文件表项的文件状态标志中
                每次对这种具有追加写标志的文件执行写操作时,文件表项中的当前文件偏移量首先会被设置为
                i节点表项中的文件长度,这就使得每次写入的数据都追加到文件的当前尾端处
            c.  若一个文件用lseek定位到文件当前的尾端,则文件表项中的当前文件偏移量被设置为i节点表项
                中的当前文件长度
            d.  lseek函数只修改文件表项中的当前文件偏移量,不进行任何I/O操作

    8、 原子操作    -   在一个原子操作中,不允许发生内核切换进程
        1\  pread 和 pwrite 函数    -   原子性的定位(lseek)并执行I/O

            #include <unistd.h>
            ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);

            返回值:
                成功,读取到的字节数,若已到文件末尾,返回0
                失败,返回-1

            ssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset);

            返回值:
                成功,返回已经写入的字节数
                失败,返回-1

            注: 调用pread(pwrite)相当于调用lseek后调用read(write),但是pread又与这种顺序调用
                有下列重要区别:
                a.  调用pread时,无法中断其定位和读操作
                b.  不更新当前文件的偏移量

        2\  创建文件时 open(pathname, O_RDWR | O_CREAT, MODE) 为一个原子操作
            1)  先判断文件是否存在
            2） 不存在就创建并打开

    9、 dup 和 dup2 函数    -   复制一个现有的文件描述符
        
        #include <unistd.h>
        int dup(int fd);
        int dup2(int fd, int fd2);

        两个函数的返回值:
            成功,返回新的文件描述符
            失败,返回-1

        注:
            由dup返回的新文件描述符一定是当前可用文件描述符中的最小数值.
            对于dup2,可用fd2参数指定新文件描述符的值,如果fd2已经打开,则先将其关闭.
            如若fd等于fd2，则dup2返回fd2,而不关闭它,否则fd2的FD_CLOEXEC文件描述符标志就被清除,
            这样fd2在进程调用exec时是打开状态
            **这些函数返回的新文件描述符与参数fd共享同一个文件表项,所以他们共享同一文件状态标志(读、写
            追加等)以及同一文件偏移量

        每一个文件描述符都有它自己的一套文件描述符标志,新描述符的执行时关闭(close-on-exec)标志总是
        由dup函数清除.

        复制一个文件描述符的另一种方法是使用fcntl函数,实际上:
        调用
            dup(fd);
        等效于
            fcntl(fd, F_DUPFD, 0);
        调用
            dup2(fd, fd2);
        等效于
            close(fd2);
            fcntl(fd, F_DUPFD, fd2);
        在后一种情况下,dup2并不完全等同于close加上fcntl,它们之间的区别如下:
            a.  dup2是一个原子操作,而close和fcntl包括两个函数的调用,有可能在close和fcntl之间调用
                了信号捕捉函数,它可能修改文件描述符,如果不同的线程改变了文件描述符的话也会出现相同问题
            b.  dup2和fcntl有一些不同的errno

    10、    sync、fsync 和 fdatasync 函数   -   保证磁盘上实际文件系统与缓冲区中内容的一致性
    
            传统UNIX系统实现在内核中设有缓冲区高速缓存或页高速缓存,大多数磁盘I/O都是通过缓冲区进行.
        当我们向文件写入数据时,内核通常先将数据复制到缓冲区中,然后排入队列,晚些时候在写入磁盘,这种方式
        称为延时写(delayed write).
            通常当内核需要重用缓冲区来存放其他磁盘块数据时,他会把所有延迟写的数据写入到磁盘.

        #include <unistd.h>
        int fsync(int fd);
        int fdatasync(int fd);

        返回值:
            成功,返回0
            失败,返回-1

        void sync(void);

        注:
            sync 只是将所有修改过的块缓冲区排入到写队列,然后就返回,它并不等待实际写磁盘操作结束
            通常,称为update的系统守护进程周期性的调用(默认间隔30秒)sync函数,命令sync也是调用sync函数

            fsync函数只对由文件描述符fd指定的一个文件起作用,并且等待写磁盘操作结束才返回,可用于数据库
            这样的应用程序

            fdatasync函数类似fsync,但它只影响文件的数据部分,除数据外,fsync还会同步更新文件属性

    11、    fcntl 函数  -   可以改变已经打开文件的属性

        #include <fcntl.h>
        int fcntl(int fd, int cmd, ... /* int arg */);

        返回值:
            成功,则依赖于cmd
            失败,返回-1

        注:
            fcntl函数有以下5种功能:
            1)  复制一个已有的描述符(cmd = F_DUPFD 或 F_DUPFD_CLOEXEC)
            2)  获取/设置文件描述符标志(cmd = F_GETFD 或 F_SETFD)
            3)  获取/设置文件状态标志(cmd = F_GETFL 或 F_SETFL)
            4)  获取/设置异步I/O所有权(cmd = F_GETOWN 或 F_SETOWN)
            5)  获取/设置纪录锁(cmd = F_GETLK、F_SETLK 或 F_SETLKW)

        F_DUPFD -   复制文件描述符fd,新文件描述符作为函数值返回.返回尚未打开的描述符中大于或等于第3
                    个参数值中的最小值
        F_DUPFD_CLOEXEC -   复制文件描述符,设置与新描述符关联的FD_CLOEXEC文件描述符标志的值

        F_GETFD -   对应于fd的文件描述符标志作为函数值返回,当前只定义了一个文件描述符标志FD_CLOEXEC
        F_SETFD -   对于fd设置文件描述符标志,新标志值按第3个参数设置 0 在exec时不关闭,1 在exec时关闭

        F_GETFL -   对应fd的文件状态标志作为函数值返回,例如 O_RDONLY O_RDWR 等
                    获取方式要用屏蔽字O_ACCMODE取得位访问方式,然后结果与5个值比较
        F_SETFL -   将文件状态设置为第3个参数的值,可以更改的标志: O_APPEND O_NONBLOCK O_SYNC O_RSYNC
                                                                O_FSYNC 和 O_ASYNC

        F_GETOWN    -   获取当前接受SIGIO 和 SIGURG信号的进程ID或进程组ID
        F_SETOWN    -   设置接受SIGNO 和 SIGURG信号的进程ID或进程组ID,正的arg值指定一个进程ID
                                                                      负的arg绝对值指定一个进程组ID

第四章、    文件和目录
    
    1、 stat、fstat、fstatat 和 lstat 函数

        #include <sys/stat.h>
        int stat(const char *restrict pathname, struct stat *restrict buf);
        int fstat(int fd, struct stat *buf);
        int lstat(const char *restrict pathname, struct stat *restrict buf);
        int fstatat(int fd, const char *restrict pathname, struct stat *restrict bug, int flag);

        4个函数的返回值:
            成功,返回0
            失败,返回-1

        函数说明:
            stat    -   传入pathname, 函数返回与此文件有关的信息结构
            fstat   -   传入一个已打开的文件描述符,返回该文件的有关信息
            lstat   -   类似stat,但是当传入文件是一个符号链接时,lstat返回该符号链接的有关信息
            fstatat -   返回相对于当前打开目录的路径名文件统计信息
                        flag参数控制是否追踪一个符号链接,当AT_SYMLINK_NOFOLLOW标志被设置时,
                        fstatat不会追踪符号链接,直接返回符号链接本身的信息,否则在默认情况下,返回的
                        是符号链接所指向实际文件的信息.
                        fd参数的值为AT_FDCWD时,并且pathname是一个相对路径名,fstatat会计算相对于当前
                        目录的pathname参数;如果pathname是一个绝对路径,fd参数就会被忽略

                        buf参数是一个指针,它指向一个我们提供的结构
                        struct stat {
                            mode_t          st_mode;    /* file type & mode (permissions) */
                            ino_t           st_ino;     /* i_node number (serial number) */
                            dev_t           st_dev;     /* device number (file system) */
                            dev_t           st_rdev;    /* device number for special files(特殊文件) */
                            nlink_t         st_nlink;   /* number of links (链接数)*/
                            uid_t           st_uid;     /* user ID of owner */
                            gid_t           st_gid;     /* group ID of owner */
                            off_t           st_size;    /* size in bytes, for regular files
                                                            (常规文件的字节大小) */
                            struct timespec st_atime;   /* time of last access(使用) */
                            struct timespec st_mtime;   /* time of last modification(修改) */
                            struct timespec st_ctime;   /* time of last file status change(属性) */
                            blksize_t       st_blksize; /* best I/O block size(最佳I/O块大小) */
                            blkcnt_t        st_blocks;  /* number of disk blocks allocated
                                                            (分配的磁盘块数)*/
                        };
                        struct timespec {
                            time_t  tv_sec;     /* 秒 */
                            long    tv_nsec;    /* 纳秒 */
                        };

    2、 文件类型
        1)  普通文件(regular file)      -   包含文本或二进制数据的文件
        2)  目录文件(directory file)
        3)  块特殊文件(block special file)  -   这种类型的文件提供对设备(如磁盘)带缓冲的访问,
                                                每次以固定长度单位访问
        4)  字符特殊文件(character speaial file)    -   这种类型的文件提供对设备不带缓冲的访问,
                                                        每次访问长度可变.系统中所有的设备要么是
                                                        字符特殊文件,要么是块特殊文件
        5)  FIFO                    -   这种类型的文件用于进程间通信,也叫命名管道
        6)  套接字(socket)          -   这种类型的文件用于进程间的网络通信,也可用于本地
        7)  符号链接(symbolic link) -   这种类型的文件指向另一个文件   

        文件类型的信息包含在stat结构的st_mode成员中,可以用以下宏来确定文件类型,参数是st_mode:
            S_ISREG()   -   普通文件
            S_ISDIR()   -   目录文件
            S_ISCHR()   -   字符特殊文件
            S_ISBLK()   -   块特殊文件
            S_ISFIFO()  -   管道或FIFO
            S_ISLNK()   -   符号链接
            S_ISSOCK()  -   套接字

        IPC -   进程通信
        确定IPC对象类型的宏,参数是指向stat结构的指针:
            S_TYPEISMQ()    -   消息队列
            S_TYPEISSEM()   -   信号量
            S_TYPEISSHM()   -   共享存储对象

    3、 umask 函数      -   为进程设置文件模式创建屏蔽字
        
        #include <sys/stat.h>
        mode_t umask(mode_t cmask);

        返回值:
            之前的文件模式创建屏蔽字
            出错不返回
        注:
            这是少数几个没有出错返回函数中的一个
            在进程创建一个新文件或新目录时,就一定会使用文件模式创建屏蔽字.

        参数cmask 由下列列出的9个常量中的若干个按位“或”构成
                st_mode 屏蔽    -   含义
                S_IRUSR         -   用户读
                S_IWUSR         -   用户写
                s_IXUSR         -   用户执行
                S_IRGRP         -   组读
                S_IWGRP         -   组写
                S_IXGRP         -   组执行
                S_IROTH         -   其他读
                S_IWPTH         -   其他写
                S_IXOTH         -   其他执行
            想屏蔽什么权限就传入什么以上什么值.

        umask 命令打印当前shell进程的文件模式创建屏蔽字,其值是八进制表示,如下:
            屏蔽位      -       含义
            0400        -       用户读
            0200        -       用户写
            0100        -       用户执行
            0040        -       组读
            0020        -       组写
            0010        -       组执行
            0004        -       其他读
            0002        -       其他写
            0001        -       其他执行

    4、 chmod、fchmod 和 fchmodat 函数  -   更改现有文件的访问权限
        
        #include <sys/stat.h>
        int chmod(const char *pathname, mode_t mode);
        int fchmod(int fd, mode_t mode);
        int fchmodat(int fd, const char *pathname, mode_t mode, int flag);

        3个函数的返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            chmod   -   在指定的文件上操作
            fchmod  -   对已打开的文件操作
            fchmodat    -   在pathname参数为绝对路径时,fd参数取值为AT_FDCWD而pathname参数为相对路径时
                            与chmod函数无差别
                            否则fchmodat计算相对于打开目录(由fd参数指向)的pathname,
                            flag参数可以改变fchmodat的行为,当设置了AT_SYMLINK_NOFOLLOW标志时
                            函数不会追踪符号链接

    5、 chown、fchown、fchownat 和 lchown 函数  -   用于更改文件的用户ID和组ID

        #include <unistd.h>
        int chown(const char *pathname, uid_t owner, gid_t group);
        int fchown(int fd, uid_t owner, gid_t group);
        int fchownat(int fd, const char *pathname, uid_t owner, gid_t group, int flag);
        int lchown(const char *pathname, uid_t owner, gid_t group);

        4个函数的返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            两个参数owner 或 group 中的任意一个传入值是-1时,对应ID的不变.
            在传入文件是符号链接的情况下,lchown 和 fchownat(设置了AT_SYMLINK_NOFOLLOW标志)更改符号链接
            本身的所有者,不更改所指向文件

            fchown      -   改变fd参数所指向的打开文件的所有者,不能用于改变符号链接的所有者

    6、 文件长度
        stat结构成员st_size表示以字节为单位的文件长度,此字段只对普通文件、目录文件和符号链接有意义
        普通文件,文件长度可以是0,在读这种文件时,将得到文件结束(end-of-file)提示
        符号链接,文件长度是指向文件在文件名中的实际字节数 lib -> usr/lib 则lib的文件长度为7
        目录文件,文件长度通常是一个数(如16或512)的整倍数

    7、 文件截断
    
        #include <unistd.h>
        int truncate(const char *pathname, off_t length);
        int ftruncate(int fd, off_t length);

        两个函数的返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            用于截断文件,将现有的文件长度截断为length,如果该文件以前的长度大于length,则超过length以外
            的数据就不能访问了;如果文件长度小于length,文件的长度将增加,在以前文件尾端和新文件的尾端之间
            的数据将读作0,也就是有可能在文件中创建了一个空洞.

    8、 文件系统
        a.  对一个文件进行重命名操作时,不移动(在同一文件系统中)文件本身,只是创建一个指向现有i节点的
            新目录项,并删除旧的目录项   (mv命令)

        b.  任何一个不包含子目录的目录文件,它的链接计数都为2,新增一个子目录,链接计数加1
            一个链接是目录自己本身的名字,另一个是目录中的".",当新增子目录时,子目录中的".."也指向父目录

    9、 link、linkat、unlink、unlinkat 和 remove 函数

        #include <unistd.h>
        int link(const char *existingpath, const char *newpath);
        int linkat(int efd, const char *existingpath, int nfd, const char *newpath, int flag);

        两个函数的返回值:
            成功,返回0
            出错,返回-1
        
        函数说明:
            任何一个文件可以有多个目录项指向其i节点,上述函数可以创建一个指向现有文件的目录项

            参数newpath引用现有文件existingpath,如果newpath已经存在,则返回出错.只创建newpath中的
            最后一个分量,路径中的其他部分应当已经存在.

            对于linkat函数,现有文件是通过efd和existingpath参数指定的,新的路径名是通过nfd和newpath参数
            指定的.默认情况下,如果两个文件描述符中的任意一个是相对路径,那么它需要通过相对于对应的文件
            描述符进行计算;
            如果两个文件描述符中的任意一个设置为AT_FDCWD,那么相对应的路径名(相对路径)就通过相对于当前
            目录进行计算;
            如果任意一路径名是绝对路径,相对应的文件描述符参数就会被忽略.

            当现有文件是符号链接时,flag参数来控制linkat函数是创建指向现有符号链接的链接还是创建指向现有
            符号链接所指向文件的链接.设置AT_SYMLINK_FOLLOW标志,就创建指向原文件的链接.


        #include <unistd.h>
        int unlink(const char *pathname);
        int unlinkat(int fd, const char *pathname, int flag);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            删除一个现有的目录项,即链接计数减-

        *在一个文件有被任意一进程打开的情况下,即使链接计数为0,该文件也不会被立即删除
        *在删除一个文件时,内核会先检查的进程使用计数,当进程使用计数为0时,才会去检查链接计数
        *进程临时文件的做法
            创建一个临时文件,然后立即调用unlink,这样保证即使在程序崩溃的情况下,临时文件也会被删除

        #include <stdio.h>
        int remove(const char *pathname);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            解除对一个文件或目录的链接.对于文件remove的功能和unlink相同,对于目录,remove和rmdir功能相同.

    10、    rename 和 renameat 函数 -   对文件或目录进行重命名
        
        #include <stdio.h>
        int rename(const char *oldname, const char *newname);
        int renameat(int oldfd, const char *oldname, int newfd, const char *newname);

        返回值:
            成功,返回0
            出错,返回-1

        注:
            a.  如果oldname指的是一个文件(文件或符号链接)而不是目录,在这种情况下,如果newname已经存在,
                而且不是一个目录,则先将该文件删除然后将oldname重命名为newname

            b.  如果oldname指的是一个目录,如果newname已经存在,则它必须引用一个目录,而且该目录应当是空
                目录,如果newname存在,而且是一个空目录,则先将其删除,然后将oldname重命名为newname

            c.  如果oldname或newname引用符号链接,则处理的是符号链接本身,而不是它引用的文件

            d.  不能对.和..重命名

            e.  如果oldname 和 newname 引用同一文件,则函数不做任何改动而成功返回.

    11、    符号链接(软链接)
        符号链接是对一个文件的间接指针,硬链接直接指向文件的i节点.
        a.  硬链接通常要求链接和文件位于同一文件系统中.
        b.  只有超级用户才能创建指向目录的硬链接
        c.  符号链接不受文件系统的限制,且任何用户都可以创建指向目录的符号链接
        d.  符号链接一般用于将一个文件或整个目录结构移到系统中另一个位置

    12、    创建和读取符号链接

        #include <unistd.h>
        int symlink(const char *actualpath, const char *sympath);
        int symlinkat(const char *actualpath, int fd, const char *sympath);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            上述两个函数可以用来创建一个符号链接.
            函数创建了一个指向actualpath的新目录项sympath,在创建此符号链接时,并不要求actualpath已经存在
            并且actualpath和sympath并不需要位于同一个文件系统中.

        #include <unistd.h>
        ssize_t readlink(const char *restrict pathname, char *restrict buf, size_t bufsize);
        ssize_t readlinkat(int fd, const char *restrict pathname, char *restrict buf, size_t bufsize);

        返回值:
            成功,返回读取的字节数
            出错,返回-1

        函数说明:
            因为open函数会追踪符号链接,所以需要一种方法可以打开链接本身,并读取链接中的名字.
            两个函数组合了open、read和close的所有操作,如果函数执行成功,则返回读入buf的字节数

    13、    文件的时间
        每个文件维护了3个时间字段:
        st_atime    -   文件数据的最后访问时间,如read函数, ls -u查看
        st_mtime    -   文件数据的最后修改时间,如write函数, ls 默认显示
        st_ctime    -   i节点状态的最后更改时间(文件属性的修改时间),如chmod、chown, ls -c 可查看

    14、    futimens、utimensat 和 utimes 函数

        #include <sys/stat.h>
        int futimens(int fd, const struct timespec times[2]);
        int utimensat(int fd, const char *path, const struct timespec times[2], int flag);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            用于修改文件的访问时间的最后更改时间,所用数据结构是与stat函数族相同的timespec结构
            参数times数组第一个元素包含访问时间,第二个元素包含最后更改时间,这两个时间值是日历时间,
            自特定时间(1970年1月1日00:00:00)以来所经过的秒数,不足秒用纳秒表示
            tiems参数传入值按下列4种方式指定:
            a.  如果times参数是一个空指针,则修改访问时间和最后更改时间为当前时间
            b.  如果times参数指向两个timespec结构的数组,任一数组元素的tv_nsec字段值为UTIME_NOW,则修改
                相对应的时间戳为当前时间,忽略相应的tv_sec字段
            c.  如果times参数指向两个timespec结构的数组,任一数组元素的tv_nsec字段值为UTIME_OMIT,则
                相对应的时间戳保持不变,忽略相应的tv_sec字段
            d.  如果times参数指向两个timespec结构的数组,且tv_nsec字段既不是UTIME_NOW也不是UTIME_OMIT,
                则修改对应时间戳为相应的tv_sec 和 tv_nsec 字段的值

            futimens 函数需要打开文件来更改它的时间,utimensat函数提供了一种使用文件名更改文件时间的方法
            utimensat 函数的flag参数可用于进一步修改默认行为,如果设置了AT_SYMLINK_NOFOLLOW标志,则符号
            链接本身的时间就会被修改(如果路径名指向符号链接),默认的行为是追踪符号链接,并把文件的时间修改
            为符号链接的时间.

        #include <sys/time.h>
        int utimes(const char *pathname, const struct timeval times[2]);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            utimes参数包含的两个时间戳是struct timeval结构,使用秒和微妙表示的
            struct timeval {
                time_t tv_sec;  /* seconds */
                long tv_usec;   /* microseconds */
            };
            状态时间不能用指定值来修改,当调用utimes函数时,文件的状态时间会被自动更新

    15、    mkdir、mkdirat 和 rmdir 函数

        #include <sys/stat.h>
        int mkdir(const char *pathname, mode_t mode);
        int mkdirat(int fd, const char *pathname, mode_t mode);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            上述两函数可用于创建目录,所指定的文件访问权限mode由进程的文件模式创建屏蔽字修改

        #include <unistd.h>
        int rmdir(const char *pathname);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            用rmdir可以删除一个空目录,空目录是只包含.和..这两项的目录

    16、    读目录

        #include <dirent.h>
        DIR *opendir(const char *pathname);
        DIR *fdopendir(int fd);

        返回值:
            成功,返回指针
            出错,返回NULL
        
        struct dirent *readdir(DIR *dp);

        返回值:
            成功,返回指针
            出错或者在目录尾,返回NULL

        void rewinddir(DIR *dp);
        int closedir(DIR *dp);

        返回值:
            成功,返回0
            出错,返回-1

        long telldir(DIR *dp);

        返回值:
            返回与dp关联的目录中的当前位置

        void seekdir(DIR *dp, long loc);

        函数说明:
            fdopendir   -   可以把打开的文件描述符转换成目录处理函数需要的DIR结构
            readdir     -   读取目录中的第一个目录项

    17、    chdir、fchdir 和 getcwd 函数
        每个进程都有一个工作目录,此目录是搜索所有相对路径名的起点,当前工作目录是进程的一个属性.
        当用户登录到unix系统时,其当前目录通常是/etc/passwd中该用户登录项的第6个字段-用户的起始目录.

        #include <unistd.h>
        int chdir(const char *pathname);
        int fchdir(int fd);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            进程调用chdir或fchdir函数可以更改当前的工作目录.
            这两个函数中,分别用pathname或打开的文件描述符来指定新的当前工作目录

        #include <unistd.h>
        char *getcwd(char *buf, size_t size);

        返回值:
            成功,返回buf
            出错,返回NULL

        函数说明:
            返回进程当前工作目录完整的路径名.
            参数buf     -   缓冲区地址
            参数size    -   缓冲区长度

        注:
            chdir 追踪符号链接,但是getcwd不追踪符号链接
            当一个应用程序需要在文件系统中返回到它工作的出发点时,在更换工作目录之前先调用getcwd保存
            当前工作目录路径,在完成处理后把它传送个chdir,这样就返回到进程的出发点.

    18、    设备特殊文件
        st_dev  -   存储【非】字特殊文件和块特殊文件的主、次设备号
        st_rdev -   存储字特殊文件和块特殊文件次设备号

        每个文件系统所在的存储设备都是由主、次设备号表示.
        主设备号标识设备的驱动程序,有时编码为与其通信的外设备
        次设备号标识特定子设备.
        例如在同一磁盘驱动器上的各个文件系统通常具有相同的主设备号,但是次设备号却不同

        设备号的获取方法:
            major 宏,来访问主设备号     -   major(statbuf.st_dev) minor(statbuf.st_dev)
            minor 宏,来访问次设备号     -   major(statbuf.st_rdev) minor(statbuf.st_rdev)

        系统中也每个文件名关联的st_dev值是文件系统的设备号,该文件系统包含了这一文件名以及其对应i节点

        只有字符特殊文件和块特殊文件才有st_rdev值,此值包含实际设备的设备号

第五章、    标准I/O库

    1、 流和FILE对象
        对于ASCII字符集,一个字符用一个字节表示
        对于国际字符集,一个字符可以用多个字节表示
        标准I/O文件流可用于单字节或多字节("宽")字符集
        I/O函数分为多字节I/O函数(<wchar.h>)和单字节I/O函数

        fopen   -   打开一个流
        freopen -   清除一个流的定向
        fwide   -   设置或返回一个流的定向


        #include <stdio.h>
        #include <wchar.h>
        int fwide(FILE *fp, int mode);

        返回值:
            若流是宽定向的,返回正值
            若流是字节定向的,返回负值
            若流是未定向的,返回0

        函数说明:
            fwide函数可用于设置流的定向
            根据mode参数的不同值,fwide函数执行不同的工作:
                a.  mode参数值为负,fwide将试图将指定的流设置为字节定向的
                b.  mode参数值为正,fwide将试图将指定的流设置为宽定向的
                c.  mode参数值为0,fwide将返回指定流的定向方式

        注:
            fwide并不改变已定向流的定向,且无出错返回,使用时应先清除errno,然后调用后检查errno来判读是否成功

    2、 标准输入、标准输出和标准错误
                                            对应的文件指针
        STDIN_FILENO    -   标准输入    -       stdin
        STDOUT_FILENO   -   标准输出    -       stdout
        STDERR_FILENO   -   标准错误    -       stderr

    3、 缓冲
        标准I/O库提供缓冲的目的是尽可能的减少read和write的调用次数
        标准I/O提供了以下3种类型的缓冲:
        1)  全缓冲  -   在填满标准I/O的缓冲区后才进行实际I/O操作,对于驻留在磁盘上的文件通常是全缓冲的
                        在一个流上执行第一次I/O操作时,相关标准I/O函数通常调用malloc来获得缓冲区
                        调用fflush函数可以冲洗一个流,将缓冲区的数据冲洗到磁盘上

        2)  行缓冲  -   当在输入和输出中遇到换行符时,才执行实际的I/O操作,通常当流涉及到一个终端时,使用
                        行缓冲.

        3)  不带缓冲

        注:
            (系统默认)
            a.  标准错误流stderr通常是不带缓冲的
            b.  若是指向终端设备的流,则是行缓冲的;否则是全缓冲的

        #include <stdio.h>
        void setbuf(FILE *restrict fd, char *restrict buf);
        int setvbuf(FILE *restrict fd, char *restrict buf, int mode, size_t size);
    
        返回值:
            成功,返回0
            出错,返回非0

        函数说明:
            用于修改系统默认的流的缓冲类型
            这些函数一定要在流被打开以后使用

            setbuf  -   用以打开或关闭缓冲机制,参数buf指向一个长度为BUFSIZE的缓冲区(该常量定义
                        在<stdio.h>中).
                        关闭缓冲可以将buf设置为NULL

            setvbuf -   可以精确的设置缓冲类型,mode参数来说明:
                        _IOFBF  -   全缓冲
                        _IOLBF  -   行缓冲
                        _IONBF  -   不带缓冲
                        指定一个不带缓冲的流时,忽略buf和size参数
                        指定全缓冲或行缓冲时,buf和size可选择的指定一个缓冲区的及其长度
                        若指定流是带缓冲的,而buf传入NULL,则标准I/O库将自动的为该流分配适当长度的缓冲区,
                        通常是常量BUFSIZE的值
        
        #include <stdio.h>
        int fflush(FILE *fp);

        返回值:
            成功,返回0
            出错,返回EOF

        函数说明:
            强制冲洗一个流,此函数使该流所有未写的数据都被传送至内核
            当参数fp传入NULL时,将导致所有的输出流被冲洗.

    4、 打开流

        #include <stdio.h>
        FILE *fopen(const char *restrict pathname, const char *restrict type);
        FILE *freopen(const char *restrict pathname, const char *restrict type, FILE *restrict fp);
        FILE *fdopen(int fd, const char *type);

        返回值:
            成功,返回文件指针
            出错,返回NULL

        函数说明:
            以上3个函数用于打开一个标准I/O流
            3个函数的区别:
                1)  fopen函数打开路径名为pathname的一个指定的文件
                2)  freopen函数在一个指定的流上打开一个指定的文件,如果该流已经打开,则先关闭该流;
                    若流已经定向,则使用freopen清除该定向,此函数一般用于将一个指定的文件打开为一个
                    预定义的流:标准输入、标准输出或标准错误
                3)  fdopen函数取一个已有的文件描述符,并使一个标准的I/O流与该描述符相结合.
                    此函数常用于由创建管道和网络通信通道函数返回的文件描述符,因为这些特殊类型的文件不能
                    用标准I/O函数fopen打开.

        #include <stdio.h>
        int fclose(FILE *fp);

        返回值:
            成功,返回0
            出错,返回EOF

        函数说明:
            关闭一个打开的流

    5、 读和写流
        3种不同类型的非格式化I/O
            a.  每次一个字符的I/O
            b.  每次一行的I/O   -   fgets() fputs()
            c.  直接I/O     -   fread() fwrite()

        1\  输入函数

            #include <stdio.h>
            int getc(FILE *fp);
            int fgetc(FILE *fp);
            int getchar(voide);

            返回值:
                成功,返回下一个字符
                到达文件尾端或出错,返回EOF

            函数说明:
                上述函数用于一次读一个字符
                getchar = getc(stdin);
                注:
                    1)  getc的参数不应当是具有副作用的表达式,因为它可能被计算多次
                    2)  因为fgetc一定是个函数,所以可以得倒其地址,这就允许将fgetc的地址作为一个参数
                        传给另一个函数
                    3)  调用fgetc所需的时间可能比调用getc要长,因为调用函数所需时间通常长于宏

                    以上函数在到达文件末尾和出错时都将返回-1,为了区别这两种不同的情况,必须调用ferror 或
                    feof.
            #include <stdio.h>
            int ferror(FILE *fp);
            int feof(FILE *fp);
            void clearerr(FILE *fp);

            返回值:
                条件为真,返回非0
                否则,返回0

            函数说明:
                在大多数实现中,为每个流在FILE对象中维护了两个标志:
                a.  出错标志
                b.  文件结束标志
                调用clearerr可以清除这两个标志

            #include <stdio.h>
            int ungetc(int c, FILE *fp);

            返回值:
                成功,返回c
                出错,返回EOF

            函数说明:
                从流中读取数据以后再将字符压送回流中,压送回流中的字符又可以从流中读出,但读出的字符顺序与
                压送回的顺序相反.
                回送的字符不一定是上次读取到的字符,不能回送EOF

        2\  输出函数

            #include <stdio.h>
            int putc(int c, FILE *fp);
            int fputc(int c, FILE *fp);
            int putchar(int c);

            返回值:
                成功,返回c
                出错,返回EOF

            putchar(c) 等同于 putc(c, stdout);


    6、 每次一行I/O

        #include <stdio.h>
        char *fgets(char *restrict buf, int n, FILE *restrict fp);
        char *gets(char *buf);

        返回值:
            成功,返回buf
            若到达文件末尾或出错,返回NULL

        函数说明:
            这两个函数提供每次输入一行的功能
            这两个函数都指定了缓冲区的地址,读入的行将被送入其中,fgets是从标准输入读,而fgets是从指定的流读
            
            fgets   -   必须指定缓冲区的长度n,当超过缓冲区大小时,将返回一个不完整的行,
                        该缓冲区总是以字符null字节结尾,会将换行符存入缓冲区
            gets    -   是一个不被推荐的函数,其问题是调用者在使用gets时不能指定缓冲区的长度,这样有可能
                        造成缓冲区溢出,不会将换行符存入缓冲区

        #include <stdio.h>
        int fputs(const char *restrict str, FILE *restrict fp);
        int puts(const char *str);

        返回值:
            成功,返回非负值
            出错,返回EOF

        函数说明:
            提供一次输出一行的功能
            fputs   -   将一个以null字节终止的字符串写到指定流,尾端的终止符null不写出
            puts    -   将一个以null字节终止的字符串写到标准输出,终止符不写出,
                        但是puts会额外输出一个换行符

    7、 标准I/O的效率
        单字节读取时,fgetc要比直接调用read快,因为系统调用更加的耗费时间
        fgts实现方式使用汇编函数memccpy,比起一次读取一字节要快的多

    8、 二进制I/O   -   一次读写一个结构

        #include <stdio.h>
        size_t fread(void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);
        size_t fwrite(const void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);

        返回值:
            读或写的对象数

        函数说明:
            按结构大小读写或按块读写
            参数size应当是该结构的sizeof,参数nobj应是该数组中的元素个数

    9、 定位流
        
        有3种方法定位标准I/O流
        1)  ftell 和 fseek     函数 -   记录文件位置的数值为一个长整型,不能超过取值范围
        2)  ftello 和 fseeko   函数 -   使用off_t数据类型代替了长整型
        3)  fgetpos 和 fsetpos 函数 -   使用抽象数据类型fpos_t记录文件位置

        #include <stdio.h>
        long ftell(FILE *fp);       -   成功,返回当前文件位置指示;出错,返回-1L
        int fseek(FILE *fp, long offset, int whence);   -   成功,返回0;出错,返回-1
        void rewind(FILE *fp);
        off_t ftello(FILE *fp);     -   成功,返回当前文件位置;出错,返回(off_t)-1
        int fseeko(FILE *fp, off_t offset, int whence);     -   成功,返回0;出错,返回-1
        
        int fgetpos(FILE *restrict fp, fpos_t *restrict pos);
        int fsetpos(FILE *fp, const fpos_t *pos);

        返回值:
            成功,返回0
            出错,返回非0

    10、    格式化I/O
        1\  格式化输出

            #include <stdio.h>
            int printf(const char *restrict format, ...);
            int fprintf(FILE *restrict fp, const char *restrict format, ...);
            int dprintf(int fd, const char *restrict format, ...);

            返回值:
                成功,返回输出的字符数
                出错,返回负值

            int sprintf(char *restrict buf, const char *restrict format, ...);
            int snprintf(char *restrict buf, size_t n, const char *restrict format, ...);
    
            返回值:
                成功,返回存入数组的字符数
                出错,返回负值
    
            函数说明:
                fprintf -   输出到指定流
                dprintf -   输出到指定文件描述符
                sprintf -   将格式化的字符串存入数组buf(字符串)中,会在字符串尾端添加一个null字符
                            且有可能造成缓冲区溢出
                snprintf-   解决sprintf可能造成的缓冲区溢出问题,缓冲区的长度作为一个显示参数传入,
                            当字符串超出缓冲区长度时,超出部分就会被丢弃

                格式说明% 
                    %[flags][fldwidth][precision][lenmodifier]convtype
                    flages :
                        ,       -   将整数按千位分组字符
                        -       -   在字段内左对齐
                        +       -   总是显示带符号转换的正负号
                        (空格)  -   如果第一个字符不是正负号,则在前面加上一个空格
                        #       -   指定另一种转换形式(例如转十六进制,加上0x前缀)
                        0       -   添加前导0(代替空格)进行填充
                    
                    fldwidth    -   说明最小字段宽度,转换后参数字符若小于宽度,则多余位置用空格填充

                    precision   -   说明整型抓换后最小输出数字位数、浮点数转换后的小数点后位数、字符
                                    串转换后最大字节数.精度是一个(.),其后跟随一个可选的非负十进制数或
                                    一个星号(*)
            
                    lenmodifier :   说明参数长度,如下
                        hh  -   将相应的参数按signed 或 unsigned char 类型输出
                        h   -   将相应的参数按signed 或 unsigned short 类型输出
                        l   -   将相应的参数按signed 或 unsigned long 或宽字符类型输出
                        ll  -   将相应的参数按signed 或 unsigned longlong类型输出
                        j   -   intmax_t 或 uintmax_t
                        z   -   size_t
                        t   -   ptrdiff_t
                        L   -   long double

                    convtype    :   必选
                        d、i    -   有符号十进制
                        o       -   无符号八进制
                        u       -   无符号十进制
                        x、X    -   无符号十六进制
                        f、F    -   双精度浮点数
                        e、E    -   指数格式双精度浮点数
                        g、G    -   根据转换后的值解释为f、F、e或E
                        a、A    -   十六进制指数格式双精度浮点数
                        c       -   字符
                        s       -   字符串
                        p       -   指向void的指针
                        %       -   %字符
                        C       -   宽字符,等效于lc
                        S       -   宽字符串,等效于ls
                        n       -   到目前为止,此printf调用输出的字符数将被写入到指针所
                                    指向的带符号整型中
                        
            5中printf族的变体:
            #include <stdarg.h>
            #include <stdio.h>
            int vprintf(const char *restrict format, va_list arg);
            int vfprintf(FILE *restrict fp, const char *restrict format, va_list arg);
            int vdprintf(int fd, const char *restrict format, va_list arg);

            返回值:
                成功,返回输出字符数
                出错,返回负值

            int vsprintf(char *restrict buf, const char *restrict format, va_list arg);
            int vsnprintf(char *restrict buf, size_t n, const char *restrict format, va_list arg);

            返回值:
                成功,返回存入数组的字符数
                出错,返回负值

        2\  格式化输入
            
            #include <stdio.h>
            int scanf(const char *restrict format, ...);
            int fscanf(FILE *restrict fp, const char *restrict format, ...);
            int sscanf(const char *restrict buf, const char *restrict format, ...);

            返回值:
                成功,赋值的输入项数
                输入出错或在任一转换前已达到文件尾端,返回EOF

    11、    实现细节

        #include <stdio.h>
        int fileno(FILE *fp);   -   返回与该流相关联的文件描述符

        见Chapter_5 printStdioCached.c 测试程序

    12、    临时文件

        #include <stdio.h>
        char *tmpnam(char *ptr);    -   返回指向唯一路径名的指针
        FILE *tmpfile(void);        -   成功,返回文件指针;出错,返回NULL

        函数说明:
            用来创建临时文件.
            tmpnam  -   长生一个与现有文件名不同的一个有效路径名字符串,每次调用都会产生一个不同的
                        路径名,最多调用次数是TMP_MAX,定义在<stdio.h>中

            tmpfile -   创建一个临时二进制文件(类型wb+),在关闭该文件或程序结束时将自动删除这种文件.

        见Chapter_5 tmpfile.c 测试程序
        警告：the use of `tmpnam' is dangerous, better use `mkstemp'

        tmpfile函数通常是先调用tmpnam产生一个唯一的路径名,然后用该路径名创建一个文件,并立即unlink它

        #include <stdio.h>
        char *mkdtemp(char *template);  -   成功,返回指向目录名的指针;出错,返回NULL
        int mkstemp(char *template);    -   成功,返回文件描述符;出错,返回-1

        函数说明:
            mkdtemp -   创建了一个目录,该目录有一个唯一的名字;
            mkstemp -   创建了一个文件,该文件有一个唯一的名字,创建并打开文件
        注:
            mkstemp创建的临时文件不会自动删除
            使用tmpnam 和 tempnam有一个缺点,在返回唯一的路径名和用该名字创建文件之间有一个时间窗口
            在这个时间窗口内,另一个进程可以使用相同的名字创建文件,谨慎使用
            tmpfile和mkstemp函数不会存在这个问题.
        见Chapter_5 mkstemp.c 测试程序

    13、    内存流  -   使用FILE指针访问,没有底层文件,通过缓存和主存之间传送字节,类似文件流

        内存流的创建,3个函数

        #include <stdio.h>
        FILE *fmemopen(void *restrict buf, size_t size, const char *restrict type);

        返回值:
            成功,返回流指针
            出错,返回NULL

        函数说明:
            fmemopem 函数允许调用者提供缓冲区用于内存流:
                buf参数指向缓冲区的开始位置,
                size参数指定了缓冲区大小的字节数.
                如果buf参数为空,fmemopen函数分配size字节数的缓冲区,这种情况下,流关闭时,缓冲区会自动释放
                type参数控制如何使用流:
                    r/rb    -   为读而打开
                    w/wb    -   为写而打开
                    a/ab    -   追加
                    r+/rb+  -   读写
                    w+/wb+  -   把文件截断为0,读写
                    a+/ab+  -   追加,读写
            注:
                任何时候需要增加流缓冲区中数据量以及调用fclose、fflush、fseek、fseeko以及fsetpos时,
                都会在当前位置写入一个null字节.

        其他两个函数:
        #include <stdio.h>
        FILE *open_memstream(char **bufp, size_t *sizep);
        #include <wchar.h>
        FILE *open_wmemstream(wchar_t **bufp, size_t *sizep);

        返回值:
            成功,返回流指针
            出错,返回NULL

        函数说明:
            open_memstream 函数创建的流是面向字节的
            open_wmemstream函数创建的流是面向宽字节的
            这两个函数与fmemopen的不同在于:
                a.  创建的流只能写打开
                b.  不能指定自己的缓冲区,但是可以分别通过bufp和sizep参数访问缓冲区地址和大小
                c.  关闭流后需要自行释放缓冲区
                d.  对流添加字节会增加缓冲区的大小

第六章、系统数据文件和信息
    1、 口令文件(用户数据库)
        <pwd.h>中的passwd结构:
            char    *pw_name    -   用户名
            char    *pw_passwd  -   加密口令
            uid_t   pw_uid      -   数值用户ID
            gid_t   pw_gid      -   数值组ID
            char    *pw_gecos   -   注释字段
            char    *pw_dir     -   初始工作目录
            char    *pw_shell   -   初始shell
            char    *pw_class   -   用户访问类
            time_t  pw_change   -   下次口令修改时间
            time_t  pw_expire   -   账户有效期时间

        #include <pwd.h>
        struct passwd *getpwuid(uid_t uid);
        struct passwd *getpwnam(const char *name);

        返回值:
            成功,返回指向struct passwd结构的指针
            出错,返回NULL

        函数说明:
            在给出用户登录名或数值用户ID后,获取相关的struct passwd结构
            getpwuid函数由ls程序使用,它将i节点中的用户ID映射为用户登录名
            在输入登录名时,getpwnam函数由login程序使用

        #include <pwd.h>
        struct passwd *getpwent(void);  -   成功,返回指针;出错或到达文件尾端,返回NULL
        void setpwdent(void);
        void endpwent(void);

        函数说明:
            查看整个口令文件
            getpwent    -   返回口令文件中的下一个记录项,在第一次调用时,它打开它所使用的各个文件
            setpwent    -   
            endpwent    -   关闭getpwnet打开的文件,一般在调用getpwent结束之后调用

    2、 阴影口令    -   shadow password
        /etc/shadow文件中的字段和struct spwd结构中的成员:
        用户登录名                  -   char    *sp_namp
        加密口令                    -   char    *sp_pwdp
        上次更改口令以来经过的时间  -   int     sp_lstchg
        经多少天后允许更改          -   int     sp_min
        要求更改剩余天数            -   int     sp_max
        超期警告天数                -   int     sp_warn
        账户不活动之前的剩余天数    -   int     sp_inact
        账户超期天数                -   int     sp_expire
        保留字段                    -   unsigned int sp_flag

        #include <shadow.h>
        struct spwd *getspnam(const char *name);
        struct spwd *getspent(void);
        void setspent(void);
        void endspent(void);

        前两个函数的返回值:
            成功,返回指针
            出错,返回NULL

        函数说明:
            用于访问阴影口令文件/etc/shadow

    3、 组文件  -   /etc/group
        
        /etc/group文件中的字段,包含在<grp.h>中所定义的group结构中
        char    *gr_name    -   组名
        char    *gr_passwd  -   加密口令
        int     gr_gid      -   数值组ID
        char    **gr_mem    -   指向各用户名指针的数组,其中每个指针指向一个属于该组的用户名

        #include <grp.h>
        struct group *getgrgid(gid_t gid);
        struct group *getgrnam(const char *name);

        返回值:
            成功,返回指向struct group的指针,该指针指向静态变量,每次调用时重写该静态变量
            出错,返回NULL

        函数说明:
            传入gid 或 组名,获取struct group结构体

        #include <grp.h>
        struct group *getgrent(void);   -   成功,返回下一个组信息的指针;出错或到达文件尾端,返回NULL
        void setgrent(void);
        void endgrent(void);

        函数说明:
            获取整个组文件
            setgrent    -   打开组文件并反绕它(?)
            getgrent    -   从组文件中读出下一个记录,如果该文件尚未打开,就先打开它
            endgrent    -   关闭组文件

    4、 附属组ID
        每个用户除了属于口令文件记录项中组ID所对应的组之外,还可以属于16个另外的组

        #include <unistd.h>
        int getgroups(int gidsetsize, gid_t grouplist[]);   -   成功,返回附属组ID数量;出错,返回-1

        #include <grp.h>    /* on Linux */
        #include <unistd.h> /* on FreeBSD, Mac OS X, and Solaris */
        int setgroups(int ngroups, const gid_t grouplist[]);

        #include <grp.h>    /* on Linux and Solaris */
        #include <unistd.h> /* on FreeBSD and Mac OS X */
        int initgroups(const char *username, gid_t basegid);

        后两个函数的返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            getgroups   -   将进程所属用户的各个附属组ID填写到数组grouplist中,填写入该数组的附属组ID数
                            最多为gifsetsize个;实际填写到数组中的附属组ID数由函数返回值返回.
                            当gidsetsize传入为0时,函数只返回附属组ID数

            setgroups   -   可由超级用户调用以便为调用进程设置附属组ID表
                            grouplist是组ID数组;
                            ngroups说明数组中的元素个数,且ngroups值不能大于NGROUPS_MAX

            initgroups  -   通常只有initgroups函数调用setgroups,initgroups读整个组文件(用getgrent、
                            setgrent和endgrent),然后对username确定其组的成员关系.然后调用setgroups,
                            以便为该用户初始化附属组ID表

    5、 时间和日期例程

        #include <time.h>
        time_t time(time_t *calptr);

        返回值:
            成功,返回当前时间值
            出错,返回-1

        函数说明:
            time函数返回当前时间和日期
            时间值作为函数值返回,如果参数非空,则时间值也存放在由calptr指向的单元内

        时钟通过clockid_t 类型标识:
        CLOCK_REALTIME                                              -   实时系统时间
        CLOCK_MONOTONIC             -   _POSIX_MONOTONIC_CLOCK      -   不带负跳数的实时系统时间
        CLOCK_PROCESS_CPUTIME_ID    -   _POSIX_CPUTIME              -   调用进程的CPU时间
        CLOCK_THREAD_CPUTIME_ID     -   _POSIX_THREAD_CPUTIME       -   调用线程的CPU时间

        #include <sys/time.h>
        int clock_gettime(clockid_t clock_id, struct timespec *tsp);

        返回值:
            成功,返回0
            出错,返回-1
        
        函数说明:
            clock_gettime函数可用于获取指定时钟的时间,返回的时间在timespec结构中,表示为秒和纳秒
            当clock_id设置为CLOCK_REALTIME时,与time函数类似,精度更高

        #include <sys/time.h>
        int clock_getres(clockid_t clock_id, struct timespec *tsp);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            clock_getres函数把参数tsp指向的timespec结构初始化为与clock_id参数对应的时钟精度

        #include <sys/time.h>
        int clock_settime(clockid_t clock_id, const struct timespec *tsp);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            对特定的时钟设置时间

        struct tm {         /* 存放时间的结构体 */
            int     tm_sec;     /* seconds after the minute: [0 - 60] */
            int     tm_min;     /* minutes after the hour: [0 - 59] */
            int     tm_hour;    /* hours after midnight: [0 - 23] */
            int     tm_mday;    /* day of the month: [1 - 31] */
            int     tm_mon;     /* months since January: [0 - 11] */
            int     tm_year;    /* years since 1900 */
            int     tm_wday;    /* days since Sunday: [0 - 6] */
            int     tm_yday;    /* days since January 1: [0 - 365] */
            int     tm_isdst;   /* daylight saving time flag: <0, 0, >0 */
        };

        #include <time.h>
        struct tm *gmtime(const time_t *calptr);
        struct tm *localtime(const time_t *calptr);

        返回值:
            成功,指向分解的tm结构指针
            出错,返回NULL

        函数说明:
            localtime   -   将日历时间转换为本地时间(考虑到本地时区和夏令时标志)
            gmtime      -   将日历时间转换为协调统一时间的年、月、日、时、分、秒、周日分解结构

        #include <time.h>
        time_t mktime(struct tm *tmptr);

        返回值:
            成功,返回日历时间
            出错,返回-1

        函数说明:
            mktime函数以本地时间的年、月、日等作为参数,将其转换成time_t值

        size_t strftime(char *restrict buf, size_t maxsize, const char *restrict format,
                        const struct tm *restrict tmptr);
        size_t strftime_l(char *restrict buf, size_t maxsize, const char *restrict format,
                        const struct tm *restrict tmptr, locale_t locale);
        char *strptime(const char *restrict buf, const char *restrict format, 
                        struct tm *restrict tmptr);

第七章、    进程环境
    1、 进程终止
        进程终止的8种方式:
            正常终止:
                1)  从main返回
                2)  调用exit
                3)  调用_exit 或 _Exit
                4)  最后一个线程从其启动例程返回
                5)  从最后一个线程调用pthread_exit
            异常终止:
                6)  调用abort
                7)  接到一个信号
                8)  最后一个线程对取消请求做出响应

        1\  退出函数

            #include <stdlib.h>
            void exit(int status);
            void _Exit(int status);
            #include <unistd.h>
            void _exit(int status);

            函数说明:
                3个函数用于正常终止一个程序
                _exit 和 _Exit 立即进入内核
                exit 则先执行一些清理处理,然后返回内核;执行一个标准I/O库的清理关闭操作,
                        对所有打开的流调用fclose函数.

                3个函数都带一个整型参数,称为终止状态(exit status)

        2\  函数 atexit
            ISO C规定,一个进程最多可以登记32个函数,这些函数将由exit自动调用.
            我们称这些函数为终止处理程序(exit handler),并调用atexit函数来登记这些函数

            #include <stdlib.h>
            int atexit(void (*func)(void));

            返回值:
                成功,返回0
                出错,返回非0

            函数说明:
                atexit的参数是一个函数地址,当调用此函数时无需向他传递任何参数,也不期望它返回一个值.
                exit调用这些函数的顺序与它们登记的时候的顺序相反,同一函数如若登记多次,也会被调用多次.

            一个C程序如何启动:
                1)  内核开始,调用exec函数族中一个,启动一个C启动例程
                2)  C启动例程调用main函数,main函数再调用其他用户函数
            C程序的终止方式:
                3)  C启动例程、main函数和用户函数调用exit函数,
                    然后exit函数调用终止处理程序和标准I/O清理程序,
                    清理程序返回之后,由exit函数返回内核,_exit或_Exit
                4)  也可由mian函数或用户函数直接调用_exit或_Exit直接返回内核

            atexit函数测试程序,见Chapter_7/atexit.c

    2、 命令行参数  char *argv[]
        当执行一个程序时,调用exec的进程可将命令行参数传递给该新程
        ISO C和POSIX.1要求argv[argc]是一个空指针,即argv数组以NULL结尾

    3、 环境表
        每个程序都接收到一张环境表,与参数表一样,环境表也是一个字符指针数组,其中每个指针包含一个
        以null结束的C字符串的地址,全局变量environ则包含了该指针数组的地址
            extern char **environ;
        可使用getenv 和 putenv函数来访问特定的环境变量,当要查看整个环境时,使用environ指针

    4、 C程序的存储空间布局
        C程序的组成部分:
            1)  正文段  -   这是由CPU执行的机器指令部分,通常是可共享的,频繁被执行的程序在存储器中
                            只需要保留一个副本,只读属性,防止被修改
            2)  初始化数据段    -   也称为数据段,包含了程序中需明确的赋初值的变量
            3)  未初始化数据段  -   也称为bss(block started by symbol)段,在程序开始执行之前,内核通过
                                    exec将此段中的数据初始化为0或空指针

            4)  栈      -   自动变量以及每次函数调用时所需保存的信息都存放在此段中.
                            每次函数调用时,其返回地址以及调用者的环境信息(如某些机器寄存器的值)都存放
                            在栈中,然后,最近被调用的函数在栈上为其自动和临时变量分配存储空间.
                            递归函数每次调用自身时,就用一个新的栈帧,因此一次函数调用实例中的变量集不会
                            影响另一次函数调用实例中的变量.

            5)  堆      -   通常在堆中进行动态存储分配,位于未初始化数据段和栈之间

        注:
            栈从高地址向低地址方向增长,堆从低地址向高地址方向增长,
            通常,堆顶和栈顶之间未使用的虚拟地址空间很大
            未初始化数据段的内容并不存在在磁盘程序文件中,需要存放在磁盘程序文件中的段只有正文段
            和初始化数据段

            size 命令报告正文段、数据段、和未初始化数据段的长度
            size /usr/bin/cc    执行结果:
            text       data     bss     dec     hex filename
            755125     8536   81856  845517   ce6cd /usr/bin/cc

            text    -   正文段
            data    -   初始化数据段
            bss     -   未初始化数据段
            dec     -   十进制3段总长度
            hex     -   十六进制3段总长度

    5、 共享库
        可执行文件中不再需要包含公用的库函数,只需要在所有进程都可以引用的存储区中保存这种库例程的一个
        副本,程序第一次执行或者第一次调用某个库函数时,用动态链接方法将程序与共享库函数相链接.
        特点:
            1)  减少了每个可执行文件的长度
            2)  增加了第一次运行时间的开销
            3)  当共享库发生变换时,无需重新编译可执行文件

        gcc -static 选项组织gcc使用动态共享库

    6、 存储空间分配
        3个用于存储空间动态分配的函数
        1)  malloc  -   分配指定字节数的存储区,此存储区中的初始值不确定
        2)  calloc  -   为指定数量指定长度的对象分配存储空间,该空间中的每一位(bit)都初始化为0
        3)  realloc -   增加或减少以前分配区的长度,当增加长度时,可能需要将以前分配区的内容移动到
                        另一个足够大的区域,以便在尾端提供增加的存储区,而新增区域内的初始值则不确定.

        #include <stdlib.h>
        void *malloc(size_t size);
        void *calloc(size_t nobj, size_t size);
        void *realloc(void *ptr, size_t newsize);
        void free(void *ptr);

        前3个函数返回值:
            成功,返回非空指针
            出错,返回NULL

        函数说明:
            这3个函数所返回的指针一定是适当对齐的,使其可用于任何数据对象

        替代的存储空间分配程序
            1)  libmalloc   -   libmalloc库包括mallopt函数,它使进程可以设置一些变量,并用他们来控制存储
                                空间分配程序的操作,还可以使用另一个名为mallinfo的函数,以对存储空间分配
                                程序的操作进行统计.
            2)  vmalloc
            3)  quick-fit   -   快速分配,标准malloc算法是最佳适配或首次适配存储分配策略,quick-fit算法
                                比上述两种算法快,但会使用较多的存储空间.
                                该算法基于将存储空间分裂成各种长度的缓冲区,并将未使用的缓冲区按其长度
                                组成不同的空闲区列表
            4)  jemalloc    -   jemalloc函数实现是FreeBSD 8.0中的默认存储空间分配程序,它是库函数malloc
                                族在FreeBSD中的实现,它的设计具有良好的可扩展性,可用于多处理器系统中多
                                线程的应用程序
            5)  TCMalloc    -   Google-perftools开源工具中的一个,用来替代malloc函数族以提供高性能、高
                                扩展性和高存储效率;从高速缓存中分配缓冲区以及释放缓冲区到高速缓存中,
                                它使用线程-本地高速缓存来避免锁开销;它还有内置的堆检查程序和堆分析程序
                                帮助调试和分许动态存储的使用.
            6)  alloca函数  -   它的调用序列与malloc相同,但是它是在当前函数的栈帧上分配存储空间
                                优点: 当函数返回时,自动释放它所使用的栈帧
                                缺点: alloca函数增加了栈帧的长度,而某些系统在函数已被调用后不能增加栈
                                      帧长度,于是就不支持alloca函数

    7、 环境变量
        环境变量的解释权完全取决于各个应用程序,内核不关注环境变量
        name=value
        环境表和环境字符串通常存放在进程存储空间的顶部(栈之上),修改和新增环境变量很复杂

        #include <stdlib.h>
        char *getenv(const char *name);

        返回值:
            找到,返回指向与name关联的value的指针
            未找到,返回NULL

        函数说明:
            指定环境变量的name,获取当前进程环境变量的value值
    
        #include <stdlib.h>
        int putenv(char *str);      -   成功,返回0;出错,返回非0
        int setenv(const char *name, const char *value, int rewrite);
        int unsetenv(const char *name);

        后2个函数返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            putenv      -   取形式为name=value的字符串,将其输出到环境列表中;
                            如果name已经存在,则先删除原来value值
            setenv      -   将name设置为value;如果name已经存在:
                            a.  参数rewrite非0,则先删除其原有value值
                            b.  参数rewrite为0,则不删除原有值,name也不设置新值,返回也不出错
            unsetenv    -   删除name的value值,name不存在也不会报错


        POSIX.1定义的某些环境变量:
            COLUMNS         -   终端宽度
            DATEMSK         -   getdate模版文件路径名
            HOME            -   起始目录
            LANG            -   本地字符集
            LC_ALL          -   本地名
            LC_COLLATE      -   排序习惯
            LC_CTYPE        -   本地字符分类类型
            LC_MESSAGES     -   本地消息名
            LC_MONETARY     -   本地货币编辑名
            LC_NUMERIC      -   本地数字编辑名
            LC_TIME         -   本地日期/时间格式名
            LINES           -   终端高度
            LOGNAME         -   登录名
            MSGVERB         -   fmtmsg处理的消息组成部分
            NLSPATH         -   消息类模版序列
            PATH            -   搜索可执行文件的路径前缀列表
            SHELL           -   用户首选的shell名
            TERM            -   终端类型
            TMPDIR          -   在其中创建临时文件的目录路径名
            TZ              -   时区信息
           
    8、 setjmp 和 longjmp 函数

        #include <setjmp.h>
        int setjmp(jmp_buf env);
            返回值: 若直接调用,返回0;若从longjmp返回,则为非0
        void longjmp(jmp_buf env, int val);

        函数说明:
            在C中,goto语句是不能跨越函数的,执行跨越函数的跳转函数setjmp 和 longjmp
            setjmp  -   设置程序的返回点
            longjmp -   使用返回点,使程序进行跳转,参数val是跳转回返回点之后setjmp的返回值
                        一个setjmp可以有多个longjmp,longjmp的参数val可用于判断是哪个longjmp返回

            注:
                上述函数适合于,在C语言函数的深层嵌套层时,出现非致命性错误的处理方式
                无需逐层检查返回值的返回,本质是直接进行函数栈帧跳转,直接在栈上跳过若干调用帧
                
            见Chapter_7/jump.c 测试程序

    问题:
        自动变量、寄存器变量和易失变量
            当调用longjmp跳转返回点后,longjmp和返回点之间压入的栈帧会被丢弃,此时,各个函数的变量值
            不会自动回滚到调用setjmp之前,值是不确定的.
   
            gcc -O 编译时进行编译器优化
            在编译时不进行编译器优化时,在调用longjmp之后,各个变量的值是最近所呈现的值(最近一次赋值)
            在编译时进行编译器优化之后,存放在存储器中的变量将具有调用longjmp时的值,
            而存放在CPU和浮点寄存器中的变量则恢复为调用setjmp时的值.

            编译器不进行优化时,所有种类的变量都存放在存储器中,即忽略了register的类型说明
            而进行编译器优化后,自动变量和register类型变量都会存放在寄存器中,
            volatitle声明的变量仍然存放在存储器中

        重点:
            如果要编写使用非局部跳转的可移植程序,必须使用volatile属性,禁止编译器对该属性变量进行优化

            见Chapter_7/longjmp.c 测试程序,测试longjmp对各类变量的影响

    9、 getrlimit 和 setrlimit 函数     -   查询和更改资源限制
        
        #include <sys/resource.h>
        int getrlimit(int resource, struct rlimit *rlptr);
        int setrlimit(int resource, const struct rlimit *rlptr);

        返回值:
            成功,返回0
            出错,返回非0

        函数说明:
            进程的资源限制通常是在系统初始化时由0进程建立,然后由后续进程继承
            对这两个函数的每一次调用都指定一个资源以及一个指向下列结构的指针:
                struct rlimit {
                    rlim_t rlim_cur;    /* soft limit: current limit */
                    rlim_t rlim_max;    /* hard limit: maximum value for rlim_cur */
                };
            在更改资源限制时,须遵守以下规则:
                a.  任何一个进程都可将一个软限制值更改为小于或等于其硬限制值
                b.  任何一个进程都可降低其硬限制值,但它必须大于或等于其软限制值;
                    这种降低对普通用户而言是不可逆向的
                c.  只有超级用户进程可以提高硬限制值

            常量RLIM_INFINITY指定一个无限量的限制
            resource参数取下列值之一:
                RLIMIT_AS       -   进程总的可用存储空间的最大长度(字节数),这影响到sbrk函数和mmap函数
                                    sbrk(动态内存分配) mmap(创建共享内存映射)
                RLIMIT_CORE     -   core文件的最大字节数,若值为0则阻止该进程创建core文件
                RLIMIT_CPU      -   CPU时间的最大量值(秒),若超过此软限制时,向该进程发送SIGXCPU信号
                RLIMIT_DATA     -   数据段的最大字节数,初始化数据段、非初始化数据段和堆的总和
                RLIMIT_FSIZE    -   创建的文件的最大字节长度;当超过该限制时,向该进程发送SIGXFSZ信号
                RLIMIT_MEMLOCK  -   一个进程使用mlock能够锁定在存储空间中的最大字节数
                RLIMIT_MSGQUEUE -   进程为POSIX消息队列可分配的最大存储字节数
                RLIMIT_NICE     -   此值影响进程调度的优先级,nice可设置的最大限制
                RLIMIT_NOFILE   -   每个进程能打开的最大文件数;更改此限制将影响到sysconf函数在参数
                                    _SC_OPEN_MAX 中的返回值
                RLIMIT_NPROC    -   每个实际用户ID可拥有的最大子进程数;更改此限制将影响到sysconf函数
                                    在参数_SC_CHILD_MAX中的返回值
                RLIMIT_NPTS     -   用户可以打开的伪终端最大数量
                RLIMIT_RSS      -   最大驻内存集字节长度(resident set size in bytes,RSS)
                                    如果可用的物理存储器非常少,则内核将从进程处取回超过RSS的部分
                RLIMIT_SBSIZE   -   在任一给定时刻,一个用户可以占用的套接字缓冲区的最大长度
                RLIMIT_SIGPENDING   一个进程可排队的信号最大数量;这个限制是sigqueue函数实施的
                RLIMIT_STACK    -   栈的最大字节长度
                RLIMIT_SWAP     -   用户可消耗的交换空间的最大字节数
                RLIMIT_VMEM     -   RLIMIT_AS的同义词
            资源限制影响到调用进程并由其子进程继承,所以为了影响一个用户的后续所有进程,需将资源限制
            的设置构造在shell之中.
                ulimit 命令可查看当前shell

第八章、    进程控制
    1、 进程标识
        
        #include <unistd.h>
        pid_t getpid(void);         -   返回调用进程的进程ID
        pid_t getppid(void);        -   返回调用进程的父进程ID
        uid_t getuid(void);         -   返回调用进程的实际用户ID
        uid_t geteuid(void);        -   返回调用进程的有效用户ID
        gid_t getgid(void);         -   返回调用进程的实际组ID
        gid_t getegid(void);        -   返回调用进程的有效组ID

    2、 fork 函数       -   创建一个新进程

        #include <unistd.h>
        pid_t fork(void);

        返回值:
            子进程,返回0
            父进程,返回子进程ID
            出错,返回-1

        函数说明:
            写时复制(Copy-On-Write)
        
        注:
            fork函数会将缓冲区的数据同样复制一份给子进程,所以在fork之前要考虑缓冲区内容问题
            可调用fflush冲洗缓冲区
            fork函数创建的子进程会中的已经打开的文件描述符会和父进程共享同一个文件表项,所以父子进程
            会共享同一个文件偏移量

        子进程会继承父进程的属性:
            文件描述符表
            实际用户ID、实际组ID、有效用户ID、有效组ID
            附属组ID
            进程组ID
            会话ID
            控制终端
            设置用户ID标志和设置组ID标志
            当前工作目录
            根目录
            文件模式创建屏蔽字
            信号屏蔽和安排
            对任一打开文件描述符的执行时关闭标志(close-on-exec)
            环境变量
            连接的共享存储段
            存储映像
            资源限制

        子进程与父进程之间的区别:
            子进程的tms_utime、tms_stime、tms_cutime 和 tms_ustime的值设置为0
            子进程不会继承父进程设置的文件锁
            子进程的未处理闹钟被清除
            子进程的未处理信号集设置为空集

        fork函数可能调用失败的两个主要原因:
            a.  系统中已经存在太多进程
            b.  该实际用户ID的进程总数超过了系统限制    CHILD_MAX

        fork的两种用法:
            a.  一个父进程希望复制自己,使父进程和子进程同时执行不同的代码段
            b.  一个进程要执行不同的程序,这种情况下,子进程从fork返回后立即调用exec(组合在一起叫做spawn)

    2、 vfork 函数
        
        pid_t vfork(void);      -   与fork函数的调用序列和返回值相同(在可移植程序中不建议使用)

        函数说明:
            vfork函数用于创建一个新进程,而该新进程的目的是exec一个新程序
            vfork在创建子进程后,并不将父进程的地址空间完全复制到子进程中,因为子进程会立即调用exec
            vfork 与 fork 之间的另一个区别是:
                vfork 保证子进程先运行,在它调用exec 或 exit之后父进程才可能被调度运行,当子进程调用这
                两个函数中的任意一个时,父进程才会恢复运行,如果在调用这两个函数之前子进程依赖于父进程
                的进一步动作,则会导致死锁
            在vfork创建的子进程中修改变量的值会导致父进程中的变量值发生改变

    3、 exit 函数
        在进程终止方式中:
            a.  调用exit函数,次函数由ISO C定义,其操作包括调用各种终止处理程序(atexit函数登记的处理函数),
                然后关闭所有标准I/O流等
            b.  调用_exit 或 _Exit 函数,ISO C定义_Exit,其目的是为进程提供一种无需运行终止处理程序或
                信号处理程序就能终止的方法,在UNIX系统中,_Exit 和 _exit是同义,并不冲洗标准I/O流.
                在UNIX系统的实现中,exit() 是标准C库中的一个函数,而_exit()是一个系统调用

    4、 wait 和 waitpid 函数
        当调用wait 或 waitpid 的进程会产生的3种情况:
            a.  如果其所有子进程都还在运行呢,则阻塞
            b.  如果一个子进程已终止,正等待父进程获取其终止状态,则取得该子进程的终止状态后立即返回
            c.  如果该进程没有任何子进程,则出错返回

        #include <sys/wait.h>
        pid_t wait(int *statloc);
        pid_t waitpid(pid_t pid, int *statloc, int options);

        返回值:
            成功,返回进程ID
            出错,返回0或-1

        函数说明:
            在一个子进程终止前,wait 使其调用者阻塞,而waitpid有一选项,可使调用者不阻塞
            waitpid 并不等待在其调用之后的第一个终止子程序,可以控制它所等待的进程

            参数statloc 是一个整型指针,如果statloc不是一个空指针,则终止进程的终止状态就存放在它所指向
            的单元内;传NULL则不关心终止进程的返回状态

            终止状态用定义在<sys/wait.h>中的各个宏来查看,有4个互斥的宏可用来取得进程终止的原因:
            WIFEXITED(status)       -   若为正常终止子进程返回的状态,则为真.可执行WEXITSTATUS(status)
                                        获取子进程传送给exit 或 _exit 参数的低8位

            WIFSIGNALED(status)     -   若为异常终止子进程返回的状态,则为真(接到一个不捕捉的信号);
                                        可执行WTERMSIG(status),获取使子进程终止的信号编号

            WIFSTOPPED(status)      -   若为当前暂停子进程的返回状态,则为真;
                                        可执行WSTOPSIG(status),获取使子进程暂停的信号编号

            WIFCONTINUED(status)    -   若在作业控制暂停后已经继续的子进程返回了状态,则为真

            见src/pr_exit.c and Chapter_8/printExit.c

            waitpid 函数pid参数:
                pid == -1   -   等待任一子进程,此时,waitpid 和 wait 等效 
                pid >  0    -   等待进程ID 与 pid 相等的子进程
                pid == 0    -   等待组ID等于调用进程组ID的任一子进程
                pid <  -1   -   等待组ID等于pid绝对值的任一子进程
            options 参数:
                WCONTINUED  -   若实现作业控制,那么由pid指定的任一子进程在停止后已经继续,返回其状态
                WNOHANG     -   若由pid指定的子进程并不是立即可用的,则waitpid不阻塞,此时返回值为0
                WUNTRACED   -   子进程停止且未报告状态,返回其状态

            见 Chapter_8/waitpid.c

    5、 waitid 函数

        #include <sys/wait.h>
        int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);

        返回值:
            成功,返回0
            出错,返回-1
        函数说明:
            与waitpid相似,waitid允许一个进程指定要等待的子进程.
            waitid 可以使用两个单独的参数表示要等待的子进程所属的类型
            id参数的值与idtype的值相关,idtype的类型如下:
                P_PID   -   等待一个特定进程:id包含要等待子进程的进程ID
                P_PGID  -   等待一个特定进程组的任一子进程:id包含要等待子进程的进程组ID
                P_ALL   -   等待任一子进程:忽略id 
            options参数是如下各标志的按位或运算,这些标志指示调用者关注哪些状态变化.
                WCONTINUED  -   等待一进程,它以前曾被停止,此后又已继续,但其状态尚未报告
                WEXITED     -   等待已退出的进程
                WNOHANG     -   如无可用的子进程退出状态,立即返回而非阻塞等待
                WNOWAIT     -   不破坏子进程退出状态,该子进程退出状态可由后续的wait、waitpid 获得
                WSTOPPED    -   等待一进程,它已经停止,但其状态尚未报告.
            infop参数是指向siginfo结构的指针,该结构包含了造成子进程状态改变有关信号的详细信息

    6、 wait3 和 wait4 函数 
        
        #include <sys/types.h>
        #include <sys/wait.h>
        #include <time.h>
        #include <sys/resource.h>
        
        pid_t wait3(int *statloc, int options, struct rusage *rusage);
        pid_t wait4(pid_t pid, int *statloc, int options, struct rusage *rusage);

        返回值:
            成功,返回进程ID
            出错,返回-1

        函数说明:
            相比wait\waitpid\waitid所提供的功能多一个,这与附加参数有关.
            该参数允许内核返回由终止进程及其所有子进程使用的资源概况.
            资源统计信息包括用户CPU时间总量、系统CPU时间总量、缺页次数、接收到信号的次数等

    7、 竞序条件


    8、 exec 函数
        exec函数的作用是用磁盘上的一个新程序替换当前进程的正文段、数据段、堆段、和栈段

        #include <unistd.h>
        int execl(const char *pathname, const char *arg0, ... /* (char *)0 */);
        int execv(const char *pathname, char *const argv[]);
        int execle(const char *pathname, const char *arg0, ... /* (char *)0, char *const envp[] */);
        int execve(const char *pathname, char *const argv[], char *const envp[]);
        int execlp(const char *filename, const char *arg0, ... /* (char *)0 */);
        int execvp(const char *filename, char *const arhv[]);
        int fexecve(int fd, char *const argv[], char *const envp[]);

        返回值:
            成功,不返回
            出错,返回-1

        函数说明:
            前4个函数取路径名作为参数,后两个函数则取文件名作为参数,最后一个函数取文件面舒服作为参数
            当指定filename作为参数时:
                a.  如果filename中包含/,就将其视为路径名
                b.  否则就按PATH环境变量在它所指定的各个目录中搜寻可执行文件

            参数表传递的方式(l表示列表list,v表示矢量vector),函数execl/execlp/execle要求将新程序的
            每个命令行参数都说明为一个单独的参数,这种参数表以空指针结尾
            对于另外4个函数,则应先构造一个指向各参数的指针数组,然后将该数组地址作为这4个函数的参数

            传递环境表的方式,以e结尾的3个函数(execle\execve\fexecve)可以传递一个指向环境字符串指针数组
            指针,当需要子进程不完全继承父进程环境变量时使用.
            其他4个函数则使用调用进程中的environ变量为新程序复制现有的环境

        注:
            这7个函数中只有execve是内核的系统调用,另外6个是库函数,这6个最终都会调用execve

        见Chapter_8/execExample.c

    9、 更改用户ID和更改组ID
        目的:访问控制,当需要访问当前并不允许访问的资源是,我们需要更换自己的用户ID或组ID,使新ID具有
            合适的访问权限

        #include <unistd.h>
        int setuid(uid_t uid);
        int setgid(gid_t gid);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            更改ID的规则:
                a.  若进程具有超级用户权限,则setuid函数将实际用户ID、有效用户ID以及保存的
                    设置用户ID(saved set-user-ID)设置为uid.
                b.  若进程没有超级用户权限,但是uid等于实际用户ID或保存的设置用户ID,则setuid 
                    只将有效用户ID设置为uid,不更改实际用户ID和保存的设置用户ID 
                c.  以上条件都不满足,则errno设置为EPERM,并返回-1

        关于内核所维护的3个用户ID:
            a.  只有超级用户进程可以更改实际用户ID;通常,实际用户ID是在用户登录时,由login程序设置的,
                而且绝不会改变它;因为login是个超级用户进程,当它调用setuid时,设置所有3个用户ID
            b.  仅当对程序文件设置了设置用户ID位时,exec函数才设置有效用户ID;如果没有设置,则
                exec函数不会改变有效用户ID,而维持现有值.
            c.  保存的设置用户ID是由exec复制有效用户ID得到的

        #include <unistd.h>
        int setreuid(uid_t ruid, uid_t euid);
        int setregid(gid_t rgid, gid_t egid);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            交换实际用户(组)ID 和有效用户ID的值
            如果其中任一参数的值为-1,则表示相应的ID应当保持不变
            一个非超级用户总能交换实际用户ID和有效用户ID

        #include <unistd.h>
        int seteuid(uid_t uid);
        int setegid(gid_t gid);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            只更改有效用户ID和有效组ID
    
    10、    system 函数

        #include <stdlib.h>
        int system(const char *cmdstring);

        函数说明:
            当cmdstring是一个空指针,则当命令处理程序可用时,system返回非0值,这一特征可以确定在一个给定
            的操作系统上是否支持system函数.
            因为system在其实现中调用了fork、exec和waitpid,因此有3种返回值
            1)  fork失败或者waitpid返回除EINTR之外的错误,则system返回-1,并且设置errno以指示错误类型
            2)  如果exec失败(表示不能执行shell),则其返回值如同shell执行了exit一样
            3)  否则所有3个函数都成功,那么system的返回值是shell的终止状态

    11、    用户标示
        一个用户可以在口令文件中有多个登录项,它们的用户ID相同,但登录shell不同

        #include <unistd.h>
        char *getlogin(void);

        返回值:
            成功,返回指向登录名字符串的指针
            出错,返回NULL 

        函数说明:
            获取用户登录名
            如果调用此函数的进程没有连接到用户登录时所用的终端,则函数会调用失败,
            通常称这些进程为守护进程

    12、    进程调度
        进程通过调整nice值来降低它对CPU的占有,nice值越小,优先级越高
        (你越友好,你的调度优先级就越低)

        #include <unistd.h>
        int nice(int incr);

        返回值:
            成功,返回新的nice值NZERO
            出错,返回-1

        函数说明:
            进程可以通过nice函数获取或更改它的nice值,使用此函数,进程只能影响自己的
            nice值,不能影响任何其他进程的nice值
            
            参数incr被增加到调用进程的nice值上,如果incr太大,系统直接把它降低到最大合法值
            如果,incr太小,系统也会把它提高到最小合法值
            由于-1是合法的成功返回值,在调用nice之前需要清空errno,在nice返回-1时,需要检查
            errno的值.

        #include <sys/resource.h>
        int getpriority(int which, id_t who);

        返回值:
            若成功,返回-NZERO~NZERO-1 之间的nice值
            出错,返回-1

        函数说明:
            getpriority函数可以像nice函数那样用于获取进程的nice值,还可以获取一组相关进程的nice值

            which参数可以取以下三个值之一:
                PRIO_PROCESS    -   表示进程
                PRIO_PGRP       -   表示进程组
                PRIO_USER       -   表示用户ID
            which参数控制who参数是如何解释的,who参数选择感兴趣的一个或多个进程
            如果who参数为0,表示调用进程、进程组或者用户,取决于which参数的值 
            当which设为PRIO_USER并且who为0时,使用调用进程的实际用户ID
            如果which参数作用于多个进程,则返回所有作用进程中优先级最高的(最小的nice值)

        #include <sys/resource.h>
        int setpriority(int which, id_t who, int value);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            setpriority函数可用于为进程、进程组和属于特定用户ID的所有进程设置优先级
            参数which和who 与getpriority函数中相同,value增加到NZERO上,然后变为新的nice值

        nice值影响,见Chapter_8/niceTest.c

    13、    进程时间

        #include <sys/times.h>
        clock_t times(struct tms *buf);

        返回值:
            成功,返回流逝的墙上时钟时间(以时钟滴答数为单位)
            出错,返回-1

        函数说明:
            任何一个进程都可以调用times函数获得它自己以及已终止子进程的3个时间值(墙上时钟时间、
                    用户CPU时间和系统CPU时间)

            参数buf是一个指向tms结构的指针,传入参数
                struct tms {
                    clock_t tms_utime;  /* user CPU time */
                    clock_t tms_stime;  /* system CPU time */
                    clock_t tms_cutime; /* user CPU time,terminated children */
                    clock_t tms_cstime; /* system CPU time,terminated children */
                }
            此结构没有墙上时钟时间,times函数将墙上时钟时间作为函数返回值返回
            获取墙上时钟时间方式(调用times,保存返回值,在以后某个时间再次调用,两次相减)
            
            所有有此函数返回的clock_t值都用_SC_CLK_TCK(有syscong函数返回的每秒时钟滴答数)转换成秒数

            测试程序见Chapter_8/timesTest.c

第9章、 进程关系
    
    1、 终端登录
        登录过程:
            1)  init进程读取/etc/ttys, 为每个个终端执行fork,创建空环境
            2)  fork的子进程成调用exec gettty,getty 调用open函数打开终端设备,
                然后getty输出"login:"之类的信息,并等待用户输入,读取用户名,初始化环境集
            3)  getty 再次exec login (execle("/bin/login", "login", "-p", username, (char *)0, envp));
            4)  login 调用getpwnam 取得相应用户的口令文件登录项,然后调用getpass以显示提示"Password:",
                接着读取用户输入,与阴影口令文件作比较

        用户正确登录后,login将执行以下工作:
            a.  将当前工作目录更改为该用户的起始目录(chdir)
            b.  调用chown更改该终端的所有权,使登录用户成为它的所有者
            c.  将对该终端设备的访问权限改变成"用户读和写"
            d.  调用setgid 及 initgroups 设置进程的组ID
            e.  用login得到的所有信息初始化环境:起始目录(HOME)、shell(SHELL)、
                用户名(USER和LOGNAME)以及一个系统默认路径(PATH)
            f.  login 进程更改为登录用户的用户ID(setuid)并调用该用户的登录shell,其方式类似于:
                execl("/bin/sh", "-sh", (char *)0);

    2、 网络登录
        在网络登录的情况下,login仅仅是一种可用的服务
        网络连接时,所有的登录都经由内核的网络接口驱动程序(如以太网驱动程序),因此必须等待一个网络连接请求的到达
        伪终端处理网络登录

        当通过终端或者网络登录时,我们得到了一个登录shell,其标准输出、标准输入和标准错误要么连接到一个终端设备
        要么连接到一个伪终端设备上.
        登录到一个shell将是一个POSIX.1会话的开始,而此终端或伪终端则是会话的控制终端.

    3、 进程组 

        进程组是一个或多个进程的集合,同一进程组中的各个进程接受来自同一终端的各种信号.

        #include <unistd.h>
        pid_t getpgrp(void);

        返回值:
            调用进程的进程组ID

        #include <unistd.h>
        pid_t getpgid(pid_t pid);

        返回值:
            成功,返回进程组ID 
            出错,返回-1

        函数说明:
            若参数pid是0,则返回调用进程的进程组ID
            getpgid(0); 等效于 getpgrp();

        每个进程组有一个组长进程,组长进程的进程组ID等于其进程ID
        进程组组长可以创建一个进程组、创建该组中的进程,然后终止

        #include <unistd.h>
        int setpgid(pid_t pid, pid_t pgid);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            进程调用setpgid可以加入现有的进程组或者创建一个新进程组
            setpgid函数将pid进程的进程组ID设置为pgid,如果这两个参数相等,则由pid指定的进程
            变成进程组组长
            如果pid是0,则使用调用者的进程ID;如果pgid是0,则由pid指定的进程ID用作进程组ID.
            一个进程只能为它自己或它的子进程设置进程组ID,在它的子进程调用exec之后,它就不能
            在更改该子进程的进程组ID.

    4、 会话(session)
        会话是一个或多个进程组的集合

        #include <unistd.h>
        pid_t setsid(void);

        返回值:
            成功,返回进程组ID
            出错,返回-1

        函数说明:
            进程调用setsid函数建立一个新会话
            如果调用此函数的进程不是一个进程组的组长,则此函数创建一个新会话,调用之后会发生的3件事:
                a.  该进程变成新会话的会话首进程(session leader),此时,该进程是新会话中的唯一进程
                b.  该进程成为一个新进程组的组长进程,新进程组ID是该调用进程的进程ID
                c.  该进程没有控制终端.

            注:
                进程组组长进程不可调用此函数,会出错返回.

        #include <unistd.h>
        pid_t getsid(pid_t pid);

        返回值:
            成功,返回会话首进程的进程组ID
            出错,返回-1

        函数说明:
            getsid函数返回会话首进程的进程组ID(可理解为会话ID)
            若pid是0,getsid返回调用进程的会话首进程的进程组ID
            不能返回pid不属于调用者所在会话的首进程的进程组ID

    5、 控制终端
        会话和进程组还有一些其他特性:
            a.  一个会话可以有一个控制终端(controlling terminal),终端设备或伪终端设备
            b.  建立与控制终端连接的会话首进程被称为控制进程(controlling process)
            c.  一个会话中的几个进程组可被分成一个前台进程组(foreground process group)以及 
                或多个后台进程组(background process group)
            d.  如果一个会话有一个控制终端,则它有一个前台进程组,其他进程组为后台进程组
            e.  无论何时键入终端的中断键,都会将中断信号发送至前台进程组的所有进程
            f.  无论何时键入终端的退出键,都会将退出信号发送至前台进程组的所有进程.
            g.  如果终端接口检测到调制解调器(或网络)已经断开连接,则将挂断信号发送至控制进程(会话首进程)
    
    6、 tcgetpgrp、tcsetpgrp 和 tcgetsid 函数
        
        #include <unistd.h>
        pid_t tcgetpgrp(int fd);
        返回值:
            成功,返回前台进程组ID
            出错,返回-1

        int tcsetpgrp(int fd, pid_t pgrpid);
        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            需要有一种方法来通知内核哪一个进程组是前台进程组,这样,终端设备驱动程序就能知道
            将终端输入和终端产生的信号发送到何处

            函数tcgetpgrp返回前台进程组ID,它与在fd上打开的终端相关联
            如果进程有一个控制终端,则该进程可以调用tcsetpgrp将前台进程组ID设置为pgrpid;pgrpid值
            应当是在同一会话中的一个进程组的ID,fd必须引用该会话的控制终端

        #include <termios.h>
        pid_t tcgetsid(int fd);

        返回值:
            成功,返回会话首进程的进程组ID
            出错,返回-1

        函数说明:
            给出控制TTY的文件描述符,通过tcgetsid函数,应用程序就能获得会话首进程的进程组ID
            需要管理控制终端的应用程序可以调用tcgetsid函数识别出控制终端的会话首进程的会话ID

    7、 作业控制
        作业控制允许在一个终端上启动多个作业(进程组),它控制哪一个作业可以访问该终端以及哪些作业在后台运行
        作业控制要求以下3种形式的支持:
            a.  支持作业控制的shell
            b.  内核中的终端驱动程序必须支持作业控制
            c.  内核必须提供对某些作业控制信号的支持
    
    8、 shell执行程序
    
    9、 孤儿进程组

第10章、    信号
    1、 概念
        信号是软件中断,信号提供了一种处理异步事件的方法
        在头文件<signal.h>中,信号名都被定义为正整数常量(信号编号),信号的实现定义在<bits/signum.h>中(linux)
        不存在编号为0的信号
        
        产生信号的条件:
            1)  当用户按某些终端键时,引发终端产生信号
            2)  硬件异常产生信号: 除数为0、无效的内存引用等
                这些条件通常由硬件检测到,并通知内核;然后内核为该条件发生时正在运行的进程产生适当的心海
            3)  进程调用kill函数可将任意信号发送给另一个进程或进程组
                接受信号进程和发送信号进程的所有者必须相同,超级用户发送信号无限制
            4)  用户可以使用kill命令将信号发送给其他进程;此命令只是kill函数的接口
            5)  当检测到某种软件条件已经发生,并应将其通知有关进程时也产生信号
                如在网络连接上传来带外的数据产生的SIGURG、在管道的读进程已经终止后,一个进程写此管道
                产生的SIGPIPE、进程设置的定时器超时产生的SIGALRM

        当信号随机产生时,可以告诉内核的3种处理方式:
            1)  忽略此信号  -   大多数信号都可以使用这种方式处理,但有两种信号不能被忽略(SIGKILL和SIGSTOP)
                                不能被忽略的原因是:它们向内核和超级用户提供了使进程终止或停止的可靠方法

            2)  捕捉信号    -   为了做到这一点,要通知内核在某种信号发生时,调用一个用户函数
                                SIGKILL 和 SIGSTOP 不能被捕捉

            3)  执行系统默认动作    -   对大多数信号的系统默认动作是终止该进程

        信号类型及说明:
            SIGABRT     -   异常终止(abort)         abort 函数产生
            SIGALRM     -   定时器超时(alarm)       alarm 函数和 setitimer函数
            SIGBUS      -   硬件故障                某些类型的内存故障
            SIGCANCEL   -   线程库内部使用      
            SIGCHID     -   子进程状态发生改变
            SIGCONT     -   使暂停进程继续          此作业控制发送给需要继续运行但当前处于停止状态的进程
            SIGEMT      -   硬件故障
            SIGFPE      -   算术异常                如除以0、浮点溢出等
            SIGFREEZE   -   检查点冻结
            SIGHUP      -   连接断开                检查到连接断开后将此信号发送给该终端的会话首进程
            SIGILL      -   非法硬件指令
            SIGINFO     -   键盘状态请求
            SIGINT      -   终端中断符              当用户按终端键,终端驱动程序产生此信号并发送至前台进程组
            SIGIO       -   异步I/O                 指示一个异步I/O事件
            SIGIOT      -   硬件故障                
            SIGKILL     -   终止 
            SIGPIPE     -   写至无读进程的管道      SOCK_STREAM类型的套接字已不再连接时,进程写该套接字也产生
            SIGPOLL     -   可轮询事件(poll)
            SIGPROF     -   硬概时间超时(setitimer)
            SIGPWR      -   电源失效/重启动         主要用于具有不间断电源(UPS)的系统
            SIGQUIT     -   终端退出符              用户按键,终端驱动程序产生,发送给前台进程组中的所有进程
            SIGSEGV     -   无效内存引用            通常说明程序有错,如访问了一个未初始化的指针
            SIGSTKFLT   -   协处理器栈故障
            SIGSTOP     -   停止
            SIGSYS      -   无效系统调用
            SIGTRAP     -   硬件故障 
            SIGTSTP     -   终端停止符              停止交互,挂起信号  
            SIGTERM     -   终止                    kill命令发送的系统默认终止信号,让程序优雅的退出(做清理工作)
            SIGTTIN     -   后台读控制tty
            SIGTTOU     -   后台写向控制tty
            SIGURG      -   紧急情况(套接字)
            SIGUSR1     -   用户定义信号
            SIGUSR2     -   用户定义信号 
            SIGVTALRM   -   虚拟时间闹钟(setitimer) setitimer函数设置的虚拟间隔时间已经超时时产生
            SIGWINCH    -   终端窗口大小改变        内核维持与每个终端或伪终端相关联窗口的大小,可用ioctl设置
            SIGXCPU     -   超过CPU限制(setrlimit)
            SIGFSZ      -   超过文件长度限制(setrlimit)
        下列条件下不产生core文件:
            a.  进程是设置用户ID的,而且当前用户并非程序文件的所有者
            b.  进程是设置组ID的,而且当前用户并非程序文件的组所有者
            c.  用户没有写当前工作目录的权限
            d.  文件已经存在,而且用户对该文件没有写权限
            e.  文件太大,超过最大文件限制(RLIMIT_CORE)

    2、 signal 函数 
        
        #include <signal.h>
        void (*signal(int signo, void (*func)(int)))(int);

        返回值:
            成功,返回以前的信号处理配置
            出错,返回SIG_ERR

        函数说明:
            UNIX系统信号机制最简单的接口函数
            不可靠信号语义函数,应当使用sigaction代替

            signo参数是信号名,func参数的值是常量SIG_IGN、常量SIG_DFL或当接到此信号要调用的函数地址
            指定SIG_IGN,则向内核表示忽略此信号
            指定SIG_DFL,则向内核表示接到此信号后的动作是系统默认动作
            指定函数地址时,则在信号发生时,调用该函数,称此函数为信号处理函数(signal handler),
                            或称为信号捕捉函数(signal-catching function)

            signal函数原型说明此函数要求有两个参数,返回一个函数指针,而该指针所指向的函数无返回值(void)
            signal函数的返回值是一个函数地址,该函数有一个整型参数(即最后的(int));即signal的返回函数指针
            指向的是在此之前的信号处理程序的指针
            typedef void Sigfunc(int);      -   Sigfunc(int) 是一个拥有一个int参数且无返回值的函数类型
            Sigfunc *signal(int, Sigfunc *);
            等效于:
            void (*signal(int, void(*func)(int)))(int);

            <signal.h>中:
                #define SIG_ERR (void (*)())-1
                #define SIG_DFL (void (*)())0
                #define SIG_IGN (void (*)())1
            表示:   指向函数的指针,该函数要求一个整型参数,而且无返回值

            见Chapter_9/signalTest.c

            注:
                当一个进程调用fork时,其子进程继承父进程的信号处理方式,因为子进程在开始时复制了父进程的
                内存映像,所以信号捕捉函数的地址在子进程中是有意义的
                当子进程执行exec后,则不继承父进程的信号处理方式,exec函数将原有设置为捕捉的信号都更改为
                默认处理动作

    3、 不可靠的信号    -   可能会丢失的信号
        
        当进行信号捕捉操作时,每个信号第一次被捕捉处理以后,随即将该信号动作重置为默认处理动作

    4、 中断的系统调用
        当进程在执行一个低速系统调用而阻塞期间捕捉到一个信号,则该系统调用就被中断返回不再继续执行;
        该系统调用返回出错,其errno被设置为EINTR

        注:
            当捕捉到某个信号时,被中断的是内核中执行的[系统调用].
        系统调用可以分为两类: 低速系统调用和其他系统调用
            低速系统调用    -   是可能会使进程永远阻塞的一类系统调用

            4.2BSD引进了某些被中断系统调用的自动重启动
            自动重启动的系统调用包括:
                ioctl、read、readv、write、writev、wait、waitpid
            POSIX.1要求只有中断信号的SA_RESTART标志有效时,实现才重启动系统调用

    5、 可重入函数
        可重入  -   在进程正在执行正常指令序列时被信号处理程序临时中断,它首先执行该信号处理程序中的指令
                    如果在信号处理程序中返回(没有调用exit或longjmp),则继续执行在捕捉到信号时进程正在执行
                    的正常指令序列(类似于硬件中断)

        不可重入函数的特点:
            a.  已知它们使用静态数据结构
            b.  它们调用malloc 或 free
            c.  它们是标准I/O函数,标准I/O库的很多实现都以不可重入方式使用全局数据结构

            注:
                信号处理程序有可能会中断主程序中的printf函数调用,所以产生的结果是不可预期的
                信号处理程序应当调用可重入函数,但是由于每个线程只有一个errno变量,所以信号处理程序有可能
                修改其原有值,因此,【应当在信号处理程序调用函数之前先保存errno的值,在调用之后恢复errno】
        
        见Chapter_10测试程序arlarmTest.c

    6、 SIGCLD 语义 (Centos 8 不支持此信号)
        对于SIGCLD信号的处理方式:
            如果进程明确的将该信号的配置设置为SIG_IGN,则调用进程的子进程将不产生僵死进程

        SIGCHLD信号可以被忽略,在被忽略时,4.4BSD总是产生僵死进程;
        在SVR4中,如果调用signal或sigset将SIGCHLD的配置设置为忽略,则绝不会产生僵尸进程
        使用sigaction可设置SA_NOCLDWAIT标志以避免进程僵死

    7、 可靠信号术语和语义
        当造成信号的[事件]发生时,为进程产生一个信号(或向一个进程发生一个信号)
        事件可以是硬件异常(如除以0)、软件条件(如alarm定时器超时)、终端产生的信号或调用kill函数
        当一个信号产生时,内核通常在进程表中以某种形式设置一个标志

        当对信号采取了某种动作时,称为向进程[递送]了一个信号;
        在信号产生(generation)和递送(delivery)之间的时间间隔内,称信号是未决的(pending)

        进程可以选用[阻塞信号递送];如果为进程产生了一个阻塞的信号,而且对该信号的动作是系统默认动作
        或捕捉该信号,则为该进程将此信号保持在未决状态,直到该进程对此信号解除阻塞,或者将对此信号的动作
        更改为忽略

        内核在[递送]一个原来被阻塞的信号给进程时,才决定对它的处理方式,而不是在信号产生时决定处理方式.
        所以,进程在信号递送给它之前仍可改变对该信号的动作
        进程调用sigpending函数来判定哪些信号是设置为阻塞并处于未决状态的

        如果在进程解除对某个信号的阻塞之前,这个信号发生了多次,POSIX.1允许系统递送该信号一次或多次
        如果递送该信号多次,则称这些信号进行了排队.

        每个进程都有一个信号屏蔽字(signal mask),它规定了当前要阻塞递送到该进程的信号集;对于没中可能的信号,
        该屏蔽字都有一位与之对应,对于某种信号,若其对应位置已设置,则它当前是被阻塞的
        进程可以调用sigprocmask来检测和更改其当前信号屏蔽字

        信号编号可能会超过一个整型所包含的二进制位数,因此POSIX.1定义了一个新数据类型sigset_t,
        它可以容纳一个信号集.

    8、 kill 函数和 raise 函数
        
        #include <signal.h>
        int kill(pid_t pid, int signo);
        int raise(int signo);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            kill函数将信号发送给进程或进程组
            raise函数则允许进程向自身发送信号
            
            调用raise(signo) 等价于 kill(getpid(), signo);

            kill的pid参数有以下4种不同的情况:
                pid >  0    -   将该信号发送给进程ID为pid的进程
                pid == 0    -   将该信号发送给于发送进程属于同一进程组的所有进程
                pid <  0    -   将该信号发送给其进程组ID等于pid绝对值,
                                而且发送进程具有权限向其发送信号的所有进程
                pid == -1   -   将该信号发送给发送进程有权限向它们发送信号的所有进程(不包括系统进程集中的进程)

            进程将信号发送给其他进程需要权限,超级用户可以将信号发送给任一进程
            对于非超级用户,其基本规则是发送者的实际用户ID或有效用户ID必须等于接收者的实际用户ID或有效ID
            如果实现支持_POSIX_SAVED_IDS,则检查接收者的保存设置用户ID(而不是有效ID)

            权限特例:
                如果被发送的信号是SIGONT,则进程可将它发送给属于同一会话的任一其他进程

            POSIX.1将信号编号0定义为空信号,如果参数signo为0,则kill仍执行正常的错误检查,但不发送信号,
            这常被用来确定一个特定进程是否仍然存在,如果向一个不存在的进程发送空信号,则kill返回-1,
            errno被设置为ESRCH

    9、 alarm 和 pause 函数
        
        #include <unistd.h>
        unsigned int alarm(unsigned int seconds);

        返回值:
            返回0或以前设置的闹钟时间的剩余秒数

        函数说明:
            使用alarm函数可以设置一个定时器(闹钟),在将来的某个时刻该定时闹钟会超时;当闹钟
            定时器超时时,产生一个SIGALRM信号,如果忽略或不捕捉此信号,则其默认动作是终止调用该函数的进程

            参数seconds的值是产生信号SIGALRM需要经过的时钟秒数,当这一时刻到达时,信号由内核产生

            每个进程只能有一个闹钟时间,如果在调用alarm时,之前已为该进程注册的闹钟时间还没有超时,则该
            闹钟时间的剩余值作为本次alarm函数调用的值返回,以前注册的闹钟时间则被新值代替

            如果有以前注册的尚未超时的闹钟时间,而且本地调用的seconds值是0,则取消以前的闹钟时间,剩余值
            作为函数返回值返回

            注:
                先注册信号处理程序再调用alarm,否则在注册信号处理程序之前接收到SIGALRM信号,程序将终止

        #include<unistd.h>
        int pause(void);

        返回值:
            返回-1,errno设置为EINTR

        函数说明:
            pause函数使调用进程挂起直到捕捉到一个信号
            只有执行了一个信号处理程序并从其返回时,pause才会返回.

        见Chapter_10/sleep1.c sleep2.c    使用函数alarm 和 pause

        除了用来实现sleep函数外,alarm还常用于对可能阻塞的操作设置时间上限值
        在程序中慢速系统调用在阻塞期间,我们希望超过一定时间值后就停止等待
        见Chapter_10/limitRead.c    带时间限制的read函数

    10、    信号集  -   表示多个信号的数据类型(singnal set)

        #include <signal.h>
        int sigemptyset(sigset_t *set);
        int sigfillset(sigset_t *set);
        int sigaddset(sigset_t *set, int signo);
        int sigdelset(sigset_t *set, int signo);

        返回值:
            成功,返回0
            出错,返回-1

        int sigismember(const sigset_t *set, int signo);

        返回值:
            若真,返回1
            若假,返回0

        函数说明:
            sigemptyset -   初始化由set指向的信号集,清除其中所有信号
            sigfillset  -   初始化由set指向的信号集,使其包括所有信号
            sigaddset   -   将一个信号添加到已有的信号集中
            sigdelset   -   将一个信号从已有的信号集中删除
            sigismember -   判断一个信号在不在集合内

        函数实现原理:   见Chapter_10/sigset.c

    11、    sigprocmask 函数    -   检测和更改进程的信号屏蔽字

        #include <signal.h>
        int sigprocmask(int how, const sigset_t *restrict set, sigset_t *restrict oset);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            若参数oset是非空指针,则进程的当前信号屏蔽字通过oset返回
            若参数set 是一个非空指针,则参数how指示如何修改当前的信号屏蔽字,how的可选值如下:
                SIG_BLOCK   -   该进程新的信号屏蔽字是其[当前信号屏蔽字和set指向信号集的并集],
                                set包含了希望[阻塞]的附加信号
                
                SIG_UNBLOCK -   进程新的信号屏蔽字是[当前信号屏蔽字和set所指向信号集补集的交集],
                                set包含了希望[解除阻塞]的信号

                SIG_SETMASK -   该进程新的信号屏蔽字是[set指向的值]

            如果set是个空指针,则不改变该进程的信号屏蔽字,how的值也无意义
            注:
                在调用sigprocmask后,如果有任何未决的、不再阻塞的信号,则在sigprocmask返回前至少将其中之一递送给进程
                sigprocmask 仅是单线程进程定义的,不可用在处理多线程进程中的信号屏蔽.

            见src/pr_mask.c

    12、    sigpending 函数 -   返回当前未决信号集

        #include <signal.h>
        int sigpending(sigset_t *set);

        返回值:
            成功,返回0
            出错,返回-1

        见Chapter_10/signalSet.c

    13、    sigaction 函数  -   检查或修改与指定信号相关的处理动作(代替signal函数)

        #include <signal.h>
        int sigaction(int signo, const struct sigaction *restrict act, struct sigaction *restrict oact);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            参数signo是要检测或修改其具体动作的信号编号
            若act指针不为空,则要修改其处理动作
            若oact指针非空,则系统经由oact指针返回该信号的上一个动作
            此函数使用下列数据结构:
                struct sigaction {
                    void     (*sa_handler)(int);    /* addr of signal handler, or SIG_IGN, or SIG_DFL*/
                    sigset_t sa_mask;               /* additional signals to block */
                    int         sa_flags;           /* signal options */

                    void (*sa_sigactionn)(int, siginfo_t *, void *);    /* alternate handler */
                }
            当更改信号处理动作时,如果sa_handler字段包含一个信号捕捉处理函数的地址,则sa_mask字段说明了一个信号集,
            在调用该信号捕捉函数之前,这一信号集要加到进程的信号屏蔽字中
            当从信号捕捉函数返回时,再将进程的信号屏蔽字恢复为原有值

            一旦对给定的信号设置了一个处理动作,那么在调用sigaction显式改变它之前,该设置就一直有效

            act结构的sa_flags字段指定对信号进行处理的各个选项,如下:
                SA_INTERRUPT    -   由此信号中断的系统调用不自动重启动(sigaction默认处理方式)
                SA_NOCLDSTOP    -   若signo是SIGCHLD,当子进程停止(作业控制),不产生此信号;当子进程终止仍旧产生此信号
                SA_NOCLDWAIT    -   若signo是SIGCHLD,则当调用进程的子进程终止时,不创建僵尸进程;
                                    若调用进程随后调用wait,则阻塞到它所有子进程都终止,此时返回-1,errno设置ECHILD
                SA_NODEFER      -   当捕捉到此信号时,在执行其信号捕捉函数时,系统不自动阻塞该信号(除非sa_mask包括了
                                    此信号)
                SA_ONSTACK      -   若用sigaltstack已声明了一个替换栈,则此信号传递送给替换栈上的进程
                SA_RESETHAND    -   在此信号捕捉函数的入口处,将此信号的处理方式重置为SIG_DFL,并清除SA_SIGINFO标志;
                                    但是不能自动重置SIGILL和SIGTRAP这两个信号的配置
                SA_RESTART      -   由此信号中断的系统调用自动重启动
                SA_SIGINFO      -   此选项对信号处理程序提供了附加信息:一个指向siginfo结构的指针以及一个指向
                                    进程上下文标识符的指针

            sa_sigaction字段是一个替代信号处理程序,在sigaction结构中使用了SA_SIGINFO标志时,使用该信号处理程序.
            对于sa_sigaction字段和sa_handler字段两者,实现可能使用同一存储区,所以应用只能一次使用这两个字段中的一个
            通常,按下列方式调用信号处理程序:
                void handler(int signo);
            但是,当设置了SA_SIGINFO标志时,按下列方式调用:
                void handler(int signo, siginfo_t *info, void *context);

            siginfo结构体:
                struct siginfo {
                    int         si_signo;       /* signal number */
                    int         si_errno;       /* if nonzero, errno value from <errno.h> */
                    int         si_code;        /* additional info (depends on signal) */
                    pid_t       si_pid;         /* sending process ID */
                    uid_t       si_uid;         /* sending process real user ID */
                    void        *si_addr;       /* address that caused the fault */
                    int         si_status;      /* exit value or signal number */
                    union sigval si_value;      /* application-specific value */
                    /* possibly other fields also */
                };
            sigval 联合体包含以下字段:
                int   sival_int;
                void  *sival_ptr;
            应用程序在递送信号时,在si_value.sival_int中传递一个整型数或在si_value.sival_ptr中传递一个指针值.

            若信号是SIGCHLD,则将设置si_pid、si_status和si_uid字段;
            若信号是SIGBUS、SIGILL、SIGFPRE或SIGSEGV,则si_addr包含造成故障的根源地址(该地址可能不准确),
            si_errno字段包含错误编号,对应造成信号产生的条件

            信号处理程序的context参数是无类型指针,它可被强制类型转换为ucontext_t结构类型,该结构标识信号传递时进程的
            上下文,该结构包含的字段:    
                ucontext_t      *uc_link;       /* pointer to context resumed when */
                                                /* this context returns */
                sigset_t        uc_sigmask;     /* signals blocked when this context is active */
                stack_t         us_stack;       /* stack used by this context */
                mcontext_t      uc_mcontext;    /* machine-specific representation of saved context */

                uc_stack 字段描述了当前上下文使用的栈,包括以下成员:
                    void    *ss_sp;     /* stack base or pointer */
                    size_t  ss_size;    /* stack size */
                    int     ss_flags;   /* flags */

        见src/signal.c  用sigaction实现signal函数

    14、    sigsetjmp 和 siglongjmp 函数

        调用longjmp有一个问题,当捕捉到一个信号时,进入信号捕捉函数,此时当前信号被自动的加到进程的信号屏蔽字中,
        这阻止了后来产生的这种信号中断该信号处理程序

        #include <setjmp.h>
        int sigsetjmp(sigjmp_buf env, int savemask);

        返回值:
            若直接调用,返回0
            若从siglongjmp调用返回,则返回非0

        void siglongjmp(sigjmp_buf env, int val);

        函数说明:
            在信号处理程序中进行非局部转移调用上述函数.
            这两个函数和setjmp、longjmp之间的唯一区别是sigsetjmp增加了一个参数
            如果savemask非0,则sigsetjmp在env中保存进程的当前信号屏蔽字
            调用siglongjmp时,如果带非0savemask的sigsetjmp调用已经保存了env,则siglongjmp从其中恢复保存的信号屏蔽字

        见Chapter_10/sigsetjmp.c 演示了在信号处理程序被调用时,系统所设置的信号屏蔽字如何自动的包括刚被捕捉到的信号
        也说明如何使用sigsetjmp和siglongjmp函数

        注:
            在siglongjmp返回时,会恢复在sigsetjmp处保存的进程屏蔽字,而setjmp达不到这种效果

    15、    sigsuspend 函数 -   原子操作(先恢复信号屏蔽字,解除阻塞,然后使进程休眠(pause))
        
        #include <signal.h>
        int sigsuspend(const sigset_t *sigmask);

        返回值:
            返回-1,并将errno设置为EINTR

        函数说明:
            进程的信号屏蔽字设置为由参数sigmask指向的值
            在捕捉到一个信号或发生了一个会终止该进程的信号之前,该进程被挂起
            如果捕捉到一个信号而且从该信号的处理程序中返回,则sigsuspend返回,
            并且该进程的信号屏蔽字设置为调用sigsuspend之前的值

        见Chapter_10/sigsuspend.c   保护代码临界区,使其不被特定信号中断的正确方法
        见Chapter_10/sigsuspend2.c  等待一个信号处理程序设置一个全局变量
        见Chapter_10/sigsuspend3.c  用信号实现父、子进程之间的同步

    16、    abort 函数  -   使调用程序异常终止

        #include <stdlib.h>
        void abort(void);

        函数说明:
            此函数将SIGABRT信号发送给调用进程,调用abort将向主机环境递送一个未成功终止的通知,其方法是
            调用raise(SIGABRT)函数

            ISO C要求若捕捉到此信号而且相信信号处理程序返回,abort仍不会返回到其调用者
            如果捕捉到此信号,则信号处理程序不能返回的唯一方法是调用exit、_exit、_Exit、longjmp或siglongjmp
            POSIX.1说明abort并不会理会进程对此信号的阻塞和忽略

            让进程捕捉SIGABRT的意图是:在进程终止之前由其执行所需的清理操作;
            如果进程并不在信号处理程序中终止自己,POSIX.1声明当信号处理程序返回时,abort终止该进程

            见Chpater_10/abort.c    abort的POSIX.1实现
    
    17、    system 函数
        POSIX.1 要求system忽略SIGINT和SIGQUIT,阻塞SIGCHLD
        见Chpater_10/systemTT.c   

        由此程序可知:
            当在父进程创建子进程时,终端发送SIGINT信号时,将发送给整个前台进程组每个进程(shell、父进程、子进程)
            但是,当调用system运行另一个程序时,不应使父、子进程两者都捕捉终端产生的两个信号:中断和退出
            这两个信号只应该发送给正在运行的程序:子进程.
            因为由system执行的命令可能是交互式命令,以及因为system的调用者在程序执行时放弃了控制,等待该执行程序的结束
            所以system的调用者就不应该接受这两个终端产生的信号

            所以,POSIX.1规定system的调用者在等待命令完成时应当忽略这两个信号

        见Chapter_10/sigSystem.c    进行了所要求的信号处理的system函数实现

    18、    sleep、nanosleep 和 clock_nanosleep 函数

        #include <unistd.h>
        unsigned int sleep(unsigned int seconds);

        返回值:
            0或未休眠完的秒数

        函数说明:
            此函数使调用进程被挂起直到满足下面两个条件之一:
                a.  已经过了seconds所指定的墙上时钟时间             -   返回0
                b.  调用进程捕捉到一个信号并从信号处理程序返回      -   返回剩余秒数

        见Chapter_10/sigSleep.c 是一个POSIX.1 sleep函数的实现,可以可靠的处理信号,避免了竞序条件

        #include <time.h>
        int nanosleep(const struct timespec *reqtp, struct timespec *remtp);

        返回值:
            若休眠到要求的时间,返回0
            出错,返回-1

        函数说明:
            nanosleep 函数与sleep函数类似,但提供了纳秒级的精度
            此函数挂起调用进程,直到要求的时间已经超时或者某个信号中断了该函数;
            reqtp参数用秒和纳秒指定了需要休眠的时间长度
            如果某个信号中断了休眠间隔,进程并没有终止,remtp参数指向的timespec结构就会被设置为
            剩余的休眠时间长度,可以传NULL

        #include <time.h>
        int clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *reqtp, struct timespec *remtp);

        返回值:
            若休眠到要求的时间,返回0
            出错,返回错误码

        函数说明:
            随着多个系统时钟的引入,需要使用相对于特定时钟的延迟时间来挂起调用线程
            clock_id参数指定了计算延迟时间基于的时钟(时钟标识符查看第6章)
            flags 参数用于控制延迟是相对还是绝对的;
                flags为0时表示休眠时间是相对的(例如,希望休眠的时间长度)
                flags设置为TIMER_ABSTIME,表示休眠时间是绝对的(例如,希望休眠到时钟到达某个特定的时间)
            reqtp 和 remtp参数与nanosleep函数中相同
            使用绝对时间时,remtp参数未使用

    19、    sigqueue 函数
        通常一个信号带有一个位信息:信号本身
        除了对信号排队以外,这些扩展允许应用程序在递交信号时传递更多的信息,这些信息嵌入在siginfo结构中
        除了系统提供的信息,应用程序还可以向信号处理程序传递整数或者指向包含更多信息的缓冲区指针
        使用排队信号必须做以下几个操作:
            1)  使用sigaction函数安装信号处理程序时指定SA_SIGINFO标志,如果没有给出这个标志,信号会延迟
                但信号是否进入队列要取决于具体实现

            2)  在sigaction结构的sa_sigaction成员中提供信号处理程序,实现可能允许用户使用sa_handler字段,
                但是不能获取sigqueue函数发送出来的额外信息

            3)  使用sigqueue函数发送信号

        #include <signal.h>
        int sigqueue(pid_t pid, int signo, const union sigval value);

        返回值:
            若成功,返回0
            出错,返回-1

        函数说明:
            sigqueue函数只能把信号发送给单个进程,可以使用value参数向信号处理程序传递整数和指针值
            除此之外,sigqueue函数与kill函数类似

        信号不能被无限排队,取决于系统限制SIGQUEUE_MAX,到达相应的限制以后,sigqueue就会失败,将errno设为EAGIN

        随着实时信号的增强,引入了用于应用程序的独立信号集,这些信号的编号在SIGRTMIN~SIGRTMAX之间,包括这两个
        限制值,这些信号的默认行为是终止进程

    20、    作业控制信号
        POSIX.1 认为与作业控制有关的6个信号:
            SIGCHLD     -   子进程已停止或终止
            SIGCONT     -   如果进程已停止,则使其继续运行
            SIGSTOP     -   停止信号(不能被捕捉或忽略)
            SIGTSTP     -   交互式停止信号
            SIGTTIN     -   后台进程组成员读控制终端
            SIGTTOU     -   后台进程组成员写控制终端
        除SIGCHLD以外,大多数应用程序并不处理这些信号,交互式shell则通常会处理这些信号的所有工作

        见Chapter_10/SIGTSTP.c  实现如何处理SIGTSTP信号

    21、    信号名和编号    -   如何在信号编号和信号名之间映射

        #include <signal.h>
        void psignal(int signo, const char *msg);

        函数说明:
            可移植的打印与信号编号对应的字符串
            字符串msg(通常是程序名)输出到标准错误文件,后面跟随一个冒号和一个空格,在后面对该信号的说明,
            最后是一个换行符;如果msg为NULL,只有信号说明部分输出到标准错误文件,该函数类似于perror

        #include <signal.h>
        void psiginfo(const sigingo_t *info, const char *msg);

        函数说明:
            如果在sigaction信号处理程序中有siginfo结构,可以使用psiginfo函数打印信号信息

        #include <string.h>
        char *strsignal(int signo);

        返回值:
            指向描述该信号的字符串的指针

        函数说明:
            如果只需要信号的字符描述部分,也不需要把它写到标准错误文件中(可以写到日志文件中),可以使用
            strsignal函数,它类似于strerror
            给出一个信号编号,strsignal将返回描述该信号的字符串,应用程序可用该字符串打印关于接收到信号的出错信息.

        #include <signal.h>
        int sig2str(int signo, char *str);
        int str2sig(const char *str, int *signop);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            一个将信号编号映射为信号名,另一个反之

第十一章、  线程

    1、线程概念
        线程的优点:
            a.  通过为每种事件类型分配单独的处理线程,可以简化处理异步事件的代码;
                每个线程在进行事件处理时可以采用同步编程模式,同步编程模式要比异步编程模式简单

            b.  多个进程必须使用操作系统提供的复杂机制才能实现内存和文件描述符的共享,而多个线程
                在同一进程下可以访问相同存储地址空间和文件描述符

            c.  有些问题可以分解从而提高整个程序的吞吐量
                在只有一个控制线程的情况下,一个单线程要完成多个任务,只需要把这些任务串行化;
                在有多个控制线程时,相互独立的任务处理就可以交叉进行,此时只需要为每个任务分配一个单独的线程

            d.  交互的程序同样可以通过使用多线程来改善响应时间,多线程可以把程序中处理用户输入输出的部分与
                其他部分分开

        每个线程都包含有表示执行环境所必需的信息,其中包括进程中标识线程的线程ID、一组寄存器值、栈、调度优先级和
        策略、信号屏蔽字、errno变量以及线程私有数据
        
        一个进程的所有信息对该进程中的所有线程都是共享的,包括可执行程序的代码、程序的全局内存和堆内存、栈以及
        文件描述符

    2、 线程标识    -   线程id(pthread_t tid)
        线程ID只有在它所属的进程上下文中才有意义
        线程ID的数据类型是pthread_t, 该结构不能把它作为整数处理(不同系统实现方式不同)

        #include <pthread.h>
        int pthread_equal(pthread_t tid1, pthread_t tid2);

        返回值:
            若相等,返回非0数值
            不想等,返回0

        函数说明:
            用来比较两个线程ID是否相等

        #include <pthread.h>
        pthread_t pthread_self(void);

        返回值:
            调用线程的线程ID

        函数说明:
            获取自身的线程ID

    3、 线程创建
        
        #include <pthread.h>
        int pthread_create(pthread_t *restrict tidp, const pthread_attr_t *restrict attr,
                            void *(*start_rtn)(void *), void *restrict arg);

        返回值:
            成功,返回0
            出错,返回错误编号

        函数说明:
            当pthread_create成功返回时,新创建线程的线程ID会被设置成tidp指向的内存单元
            attr参数用于定制各种不同的线程属性
            新创建的线程从start_rtn函数的地址开始运行,该函数只有一个无类型指针参数arg
            线程创建时并不能保证哪个线程会先运行

            新创建的线程可以访问进程的地址空间,并且继承调用线程的浮点环境和信号屏蔽字,但是该线程的
            挂起信号集会被清除

            pthread函数在调用失败时通常会返回错误码,并不像其他的POSIX函数一样设置errno

            见Chapter_11/pthread_create.c  创建并打印线程ID

    4、 线程终止
        进程中任意线程调用了exit、_Exit 或者 _exit,那么整个进程就会终止
        单个线程可以通过3种方式退出:
            1)  线程可以简单的从启动例程中返回,返回值是线程的退出码
            2)  线程可以被同一进程中的其他线程取消
            3)  线程调用pthread_exit

        #include <pthread.h>
        void pthread_exit(void *rval_ptr);

        函数说明:
            rval_ptr参数是一个无类型指针,与传给启动例程的单个参数类似
            进程中的其他线程也可以通过调用pthread_join函数访问到这个指针

        #include <pthread.h>
        int pthread_join(pthread_t thread, void **rval_ptr);

        返回值:
            成功,返回0
            出错,返回错误编号

        函数说明:
            调用此函数的线程将一直阻塞,直到指定的线程调用pthread_exit、从启动例程中返回或者被取消
            如果线程从它的启动例程中返回,rval_ptr就包含了返回码
            如果线程被取消,由rval_ptr指定的内存单元就设置为PTHREAD_CANCELED

            可以通过调用pthread_join自动把线程设置为分离状态,这样资源就会被自动释放
            如果线程已经处于分离状态,pthread_join调用就会失败返回,返回EINVAL

            如果对线程的返回值并不感兴趣可以把rval_ptr设置为NULL,这种情况下,调用pthread_join函数可以等待
            指定的线程终止,但不获取线程的终止状态

            见Chapter_11/getExitCode.c  获取已终止线程的退出码
            见Chapter_11/pthread_exit.c pthread_exit参数的不正确使用

        #include <pthread.h>
        int pthrenad_cancel(pthread_t tid);

        函数返回值:
            成功,返回0
            出错,返回错误编号

        函数说明:
            线程通过调用pthread_cancel函数来请求取消同一进程中的其他线程

            注:
                pthread_cancel函数并不等待线程终止,它仅仅提出请求

        #include <pthread.h>
        void pthread_cleanup_push(void (*rtn)(void *), void *arg);
        void pthread_cleanup_pop(int execute);

        函数说明:
            线程可以安排它退出时需要调用的函数,类似于进程退出时可以用atexit函数安排退出
            这样的函数称为线程清理处理程序(thread cleanup handler),一个线程可以建立多个清理处理程序
            处理程序记录在栈中,也就是说,它们的执行顺序与它们的注册时间相反

            当线程执行一下动作时,清理函数rtn是由pthread_cleanup_push函数调度的,调用时只有一个参数arg:
                a.  调用pthread_exit时
                b.  响应取消请求时
                c.  用非零execute参数调用pthread_cleanup_pop时
            如果execute参数设置为0,清理函数将不被调用
            不管发生上述哪种情况,pthread_cleanup_pop都将删除上次pthread_cleanup_push调用建立的清理处理程序

        注:
            当线程是从启动例程中返回而终止的话,它的清理处理程序就不会被调用

            这些函数有一个限制,由于它们可以实现为宏,所以必须在与线程相同的作用域以匹配对的形式使用
            pthread_cleanup_push的宏定义可以包含字符{,这种情况下,在pthread_cleanup_pop的定义中要有
            对应的匹配字符}.

        见Chapter_11/cleanupPth.c   使用线程清理处理程序的例子

        默认情况下,线程的终止状态会保存直到对该线程调用pthread_join;
        如果线程已经被分离,线程的底层存储资源可以在线程终止时立即被收回,
        在线程分离后,我们不能用pthread_join函数等待它的终止状态,因为对分离状态的线程调用pthread_join会
        产生未定义行为

        #include <pthread.h>
        int pthread_detach(pthread_t tid);

        返回值:
            成功,返回0
            出错,返回错误号

        函数说明:
            调用pthread_detach分离线程

    5、 线程同步
        变量增量操作步骤:
            a.  从内存单元读入寄存器
            b.  在寄存器中对变量做增量操作
            c.  把新的值写回内存单元

        1)  互斥量  -   mutex
            互斥量是用pthread_mutex_t类型表示
            初始化方式:
                PTHREAD_MUTEX_INITIALIZER   -   适用于静态分配的互斥量
                pthread_mutex_init          -   适用所有

            #include <pthread.h>
            int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr)
            int pthread_mutex_destroy(pthread_mutex_t *mutex);

            返回值:
                成功,返回0
                出错,返回错误编号

            函数说明:
                pthread_mutex_init()    -   用于初始化环境变量,参数attr传入NULL时,使用默认属性初始化
                pthread_mutex_destroy() -   用于销毁互斥量

            #include <pthread.h>
            int pthread_mutex_lock(pthread_mutex_t *mutex);
            int pthread_mutex_trylock(pthread_mutex_t *mutex);
            int pthread_mutex_unlock(pthread_mutex_t *mutex);

            返回值:
                成功,返回0
                出错,返回错误编号

            函数说明:
                pthread_mutex_lock      -   对互斥量进行加锁,如果获取不到锁,调用线程将阻塞直到获得锁
                pthread_mutex_trylock   -   试图对互斥量进行加锁,获取不到立即返回,返回EBUSY
                pthread_mutex_unlock    -   解锁

            见Chapter_11/mutex.c    使用互斥量保护数据结构

        2)  避免死锁
            死锁产生方式:
                a.  线程试图对同一个互斥量加锁两次
                b.  A线程持有第一个互斥量获取第二个,B线程持有第二个互斥量获取第一个

            控制互斥量加锁的顺序来避免死锁的发生:
                如对AB两个互斥量进程加锁时,总是要求在对互斥量B加锁之前锁住A

            使用pthread_mutex_trylock来避免死锁,当获取多个锁时,获取不到指定锁时就释放自身所
            占有的所有锁,过一段时间再尝试重新获取
            
            见Chapter_11/mutex2.c   更新mutex.c,使用两个互斥量
            见Chapter_11/mutex3.c   2的简化版

        3)  pthread_mutex_timedlock 函数

            #include <pthread.h>
            #include <time.h>
            int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex, 
                                        const struct timespec *restrict tsptr);

            返回值:
                若成功,返回0
                出错,返回错误编号

            函数说明:
                当一个线程试图获取一个已经加锁的互斥量时,pthread_mutex_timedlock互斥量原语允许绑定线程阻塞
                时间,pthread_mutex_timedlock函数与pthread_mutex_lock是基本等价的,但是在达到超时时间值时,
                pthread_mutex_timedlcok不会对互斥量进行加锁,而是返回错误码ETIMEDOUT

            见Chapter_11/timedlock.c    演示pthread_mutex_timedlock使用

        4)  读写锁(共享互斥锁)
            读写锁可以有3种状态:
                a.  读模式下加锁
                b.  写模式下加锁
                c.  不加锁
            一次只有一个线程可以占有写模式,但是可以有多个线程同时占有读模式
            写模式的加锁竞序条件应高于读模式,防止锁一直被读占用
            适用于对数据结构读的次数远大于写的情况

            #include <pthread.h>
            int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,
                                    const pthread_rwlockattr_t *restrict attr);
            int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);

            返回值:
                成功,返回0
                出错,返回错误编号

            函数说明:
                pthread_rwlock_init     -   读写锁初始化
                pthread_rwlock_destroy  -   读写锁销毁

                PTHREAD_RWLOCK_INITIALIZER  -   读写锁的静态初始化方式,使用锁的默认属性

            #include <pthread.h>
            int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
            int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
            int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);

            返回值:
                成功,返回0
                出错,返回错误编号

            函数说明:
                pthread_rwlock_rdlock   -   在读模式下加锁
                pthread_rwlock_wrlock   -   在写模式下加锁
                pthread_rwlock_unlock   -   解锁

            #include <pthread.h>
            int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
            int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);

            返回值:
                成功,返回0
                出错,返回错误编号

            函数说明:
                可以获取锁时,这两个函数返回0,否则,他们返回错误EBUSY

            见Chapter_11/RWlock.c   读写锁实例

        5)  带有超时的读写锁
            
            #include <pthread.h>
            #include <time.h>
            int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict rwlock,
                                            const struct timespec *restrict tsptr);
            int pthread_rwlock_timedwlock(pthread_rwlock_t *restrict rwlock,
                                            const struct timespec *restrict tsptr);

            返回值:
                成功,返回0
                出错,返回错误编号

            函数说明:
                如果不能获取锁,那么超时到期时,这两个函数将返回ETIMEDOUT错误

        6)  条件变量

            由pthread_cond_t数据类型表示条件变量
            使用前需初始化,初始化的两种方式:
                a.  PTHREAD_COND_INITIALIZER    -   赋值给静态分配的条件变量
                b.  pthread_cond_init

            #include <pthread.h>
            int pthread_cond_init(pthread_cond_t *restrict cond,
                                    const pthread_condattr_t *restrict attr);
            int pthread_cond_destroy(pthread_cond_t *cond);

            返回值:
                成功,返回0
                出错,返回错误编号

            函数说明:
                除非需要创建一个具有非默认属性的条件变量,否则pthread_cond_init函数的attr参数
                可以设置为NULL

            #include <pthread.h>
            int pthread_cond_wait(pthread_cond_t *restrict cond,
                                    pthread_mutex_t *restrict mutex);
            int pthread_cond_timedwait(pthread_cond_t *restrict cond,
                                        pthread_mutex *restrict mutex,
                                        const struct timespec *restrict tsptr);

            返回值:
                成功,返回0
                出错,返回错误编号

            函数说明:
                使用pthread_cond_wait函数阻塞等待条件变量变为真
                传递给pthread_cond_wait的互斥量对条件进行保护,调用者把锁住的互斥量传给函数,函数然后
                自动把调用线程放到等待条件的线程列表上,对互斥量解锁

                pthread_cond_wait函数所做的3个作用:
                    a.  阻塞等待一个条件变量满足
                    b.  释放已掌握的互斥锁,相当于解锁
                        (前两步为一个原子操作)
                    c.  当被唤醒时,函数返回,解除阻塞并重新申请获取互斥锁

                pthread_cond_timedwait函数的第3个参数传入绝对时间(当前时间+等待时间)
                可以使用clock_gettime函数获取timespec结构表示的当前时间
                也可使用gettimeofday获取timeval结构表示的当前时间


            #include <pthread.h>
            int pthread_cond_signal(pthread_cond_t *cond);
            int pthread_cond_broadcast(pthread_cond_t *cond);

            返回值:
                成功,返回0
                出错,返回错误编号

            函数说明:
                pthread_cond_signal     -   至少唤醒一个等待该条件的线程
                pthread_cond_broadcast  -   唤醒等待该条件的所有线程

            见Chapter_11/condTest.c

        7)  自旋锁
            自旋锁与互斥量类似,但它不是通过休眠使进程阻塞,而是在获取锁之前一直处于忙轮询阻塞状态
            自旋锁适用于一下情况:
                a.  锁被持有的时间短,而且线程并不希望在重新调度上花费太多成本

            #include <pthread.h>
            int pthread_spin_init(pthread_spinlock_t *lock, int pshared);
            int pthread_spin_destroy(pthread_spinlock_t *lock);

            返回值:
                成功,返回0
                出错,返回错误编号

            函数说明:
                pshared参数表示进程共享属性,表明自旋锁是如何获取的
                如果它设置为PTHREAD_PROCESS_SHARED,则自旋锁能被可以访问锁底层内存的线程获取
                设置为PTHREAD_PROCESS_PRIVATE,自旋锁只能被初始化该锁的进程内部的线程访问

            #include <pthread.h>
            int pthread_spin_lock(pthread_spinlock_t *lock);
            int pthread_spin_trylock(pthread_spinlock_t *lock);
            int pthread_spin_unlock(pthread_spinlock_t *lock);

            返回值:
                成功,返回0
                出错,返回错误编号

            函数说明:
                pthread_spin_lock       -   对自旋锁进行加锁,在获取锁之前一直自旋(忙轮询)
                pthread_spin_trylock    -   如果不能获取锁,就立即返回EBUSY错误
                pthread_spin_unlock     -   解锁

        8)  屏障
            屏障(barrier)是用户协调多个线程并行工作的同步机制
            屏障允许每个线程等待,直到所有的合作线程都到达某一点,然后从该点继续执行
            pthread_join函数就是一种屏障

            #include <pthread.h>
            int pthread_barrier_init(pthread_barrier_t *restrict barrier,
                                    const pthread_barrierattr_t *restrict attr,
                                    unsigned int count);
            int pthread_barrier_destroy(pthread_barrier_t *barrier);

            返回值:
                成功,返回0
                出错,返回错误编号

            函数说明:
                初始化屏障时,可以使用count参数指定在允许所有线程继续运行之前,必须到达屏障的线程数目
                使用attr参数指定屏障对象的属性,传NULL使用默认属性

            #include <pthread.h>
            int pthread_barrier_wait(pthread_barrier_t *barrier);

            返回值:
                成功,返回0或者PTHREAD_BARRIER_SERIAL_THREAD
                出错,返回错误编号

            函数说明:
                使用pthread_barrier_wait函数来表明,线程已完成工作,准备等待其他线程赶上来
                调用pthread_barrier_wait的线程在屏障计数未满足条件时,会进入休眠状态;
                如果该线程是最后一个调用pthread_barrier_wait的线程,则所有的线程都会被唤醒

            对于一个任意线程,pthread_barrier_wait函数返回了PTHREAD_BARRIER_SERIAL_THREAD,其余的线程
            看到的返回值是0,这使得一个线程可以作为主线程,它可以工作在其他所有线程已完成的工作结果上

            一旦达到屏障计数值,而且线程处于非阻塞状态,屏障就可以被重用,且屏障计数不会变化

            见Chapter_11/barrierTest.c

第12章、    线程控制
    1、 线程限制
        可通过sysconf函数查询的线程相关限制(最后是name参数):
            PTHREAD_DESTRUCTOP_ITERATIONS   -   线程退出时操作系统实现试图  -   _SC_THREAD_DESTRUCTOR_
                                                销毁线程特定数据的最大次数      ITERATIONS
            PTHREAD_KEYS_MAX        -   进程可以创建的键的最大数目          -   _SC_THREAD_KEYS_MAX
            PTHREAD_STACK_MIN       -   一个线程的栈可用的最小字节数        -   _SC_THREAD_STACK_MIN
            PTHREAD_THREADS_MAX     -   进程可以创建的最大线程数            -   _SC_THREAD_THREADS_MAX
    
    2、 线程属性
        pthread接口允许我们通过设置每个对象关联的不同属性来细调线程和同步对象的行为
        pthread_attr_t 结构表示线程属性

        #include <pthread.h>
        int pthread_attr_init(pthread_attr_t *attr);
        int pthread_attr_destroy(pthread_attr_t *attr);

        返回值:
            成功,返回0
            出错,返回错误编号

        函数说明:
            在调用pthread_attr_init以后,pthread_attr_t结构所包含的就是操作系统实现支持的
            所有线程属性的默认值

            操作系统支持的线程属性:
                detachstate     -   线程的分离状态属性
                guardsize       -   线程栈末尾的警戒缓冲区大小(字节数)
                stackaddr       -   线程栈的最低地址
                stacksize       -   线程栈的最小长度(字节数)
        
        
        如果在创建线程时就知道不需要了解线程的终止状态,就可以修改pthread_att_t结构中的detastate线程属性,
        让线程一开始就处于分离状态

        #include <pthread.h>
        int pthread_attr_getdetachstate(const pthread_attr_t *restrict attr, int *detachstate);
        int pthread_attr_setdetachstate(pthread_attr_t *attr, int *detachstate);

        返回值:
            成功,返回0
            出错,返回错误编号

        函数说明:
            使用pthread_attr_setdetachstate函数把线程属性detachstate设置成以下两个合法值之一:
                PTHREAD_CREATE_DETACHED -   以分离状态启动线程
                PTHREAD_CREATE_JOINABLE -   正常启动线程

            调用pthread_attr_getdetachstate函数获取当前的detachstate线程属性
            第二个参数所指向的整数要么设置成PTHREAD_CREATE_DETACHED,要么设置成PTHREAD_CREATE_JOINABLE,
            具体要取决于给定pthread_attr_t结构中的属性值

        见Chapter_12/detach.c   以分离状态创建线程

        对与遵循Single UNIX Specification 中XSI选项的系统来说,必须支持线程栈属性
        可以在编译阶段使用_POSIX_THREAD_ATTR_STACKADDR和_POSIX_THREAD_ATTR_STACKSIZE符号来检查系统是否
        支持每一个线程栈属性;
        也可以在运行阶段把_SC_THREAD_ATTR_STACKADDR和_SC_THREAD_ATTR_STACKSIZE参数传给syscong函数,检查
        运行时系统对线程栈属性的支持情况

        #include <pthread.h>
        int pthread_attr_getstack(const pthread_attr_t *restrict attr,
                                void **restrict stackaddr,
                                size_t *restrict stacksize);
        int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr, size_t stacksize);

        返回值:
            成功,返回0
            出错,返回错误编号

        函数说明:
            线程栈属性的管理函数

            对于进程来说,虚拟地址空间的大小是固定的,因为进程中只有一个栈,所以它的大小通常不是问题
            对于线程来说,同样大小的虚拟地址空间必须被所有的线程共享,当一个进程中创建了许多线程时,
            这些线程栈的累积大小超过了可用的虚拟地址空间,就需要减少默认的线程栈大小;
            另一方面,如果线程调用的函数分配了大量的自动变量,或者调用的函数涉及许多很深的栈帧(stack frame),
            那么需要的栈大小可能要比默认的大

            如果线程栈的虚拟地址空间都用完了,那可以使用malloc或者mmap来为可替代的栈分配空间,并用
            pthread_attr_setstack函数来改变新建线程栈的位置;
            由stackaddr参数指定的地址可以用作线程栈的内存范围中最低可寻址地址,该地址与处理器结构相应的
            边界应对齐;
            stackaddr线程属性被定义为栈的最低内存地址,但这并不一定是栈的开始位置

        #include <pthread.h>
        int pthread_attr_getstacksize(const pthread_attr_t *restrict attr, size_t *restrict stacksize);
        int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);

        返回值:
            成功,返回0
            出错,返回错误编号

        函数说明:
            应用程序可以通过pthread_attr_getstacksize和pthread_attr_setstacksize函数读取或设置线程栈属性
            stacksize.

            如果希望改变默认的栈大小,但又不想自己处理线程栈的分配问题,这时使用pthread_attr_setstacksize函数
            设置stacksize属性时,选择的stacksize不能小于PTHREAD_STACK_MIN

        线程属性guardsize控制着线程栈末尾之后用以避免栈溢出的扩展内存的大小,这个属性的默认值是由具体
        实现来定义的,常用值是系统页大小;
        可以把guardsize线程的属性设置为0,不允许属性的这种特征行为发生:
            在这种情况下,不会提供警戒缓冲区
        当修改了线程属性stackaddr,系统就认为我们将自己管理栈,进而使栈警戒缓冲区机制无效,这等同于
        把guardsize线程属性设置为0

        #include <pthread.h>
        int pthread_attr_getguardsize(const pthread_attr_t *restrict attr,
                                        size_t *restrict guardsize);
        int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize);

        返回值:
            成功,返回0
            出错,返回错误编号

        函数说明:
            如果guardsize线程属性被修改了,操作系统可能会把它取为页大小的整数倍,如果线程的栈指针溢出到
            警戒区域,应用程序就可能通过信号接收到出错信息

    3、 同步属性
        线程的同步对象也有属性,如互斥量属性、读写锁属性、条件变量属性和屏障属性

        1)  互斥量属性
            互斥量属性是用pthread_mutexattr_t结构表示的

            #include <pthread.h>
            int pthread_mutexattr_init(pthread_mutexattr_t *attr);
            int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);

            返回值:
                成功,返回0
                出错,返回错误编号
    
            函数说明:
                pthread_mutexattr_init函数将使用默认的互斥量属性初始化pthread_mutexattr_t结构
                值得注意的3个属性是:
                    进程共享属性、健壮属性以及类型属性

            可以通过检查系统中是否定义了_POSIX_THREAD_PROCESS_SHARED符号来判断这个平台是否支持进程
            共享这个属性,也可以在运行时把_SC_THREAD_PROCESS_SHARED参数传给sysconf函数进行检查

            在进程中,多个线程可以访问同一个同步对象,这是默认的行为,在这种情况下,进程共享互斥量属性
            需要设置为PTHREAD_PROCESS_PRIVATE;
            当使用共享内存时,多个进程访问共享数据通常也需要同步,如果进程共享互斥量属性设置为
            PTHREAD_PROCESS_SHARED,从多个进程彼此之间共享的内存数据块中分配的互斥量就可以用于
            这些进程的同步

            #include <pthread.h>
            int pthread_mutexattr_getpshared(const pthread_mutexattr_t *restrict attr,
                                                int *restrict pshared);
            int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr, int pshared);

            返回值:
                成功,返回0
                出错,返回错误编号

            函数说明:
                可以使用pthread_mutexattr_getpshared函数查询pthread_mutexattr_t结构,得到它的进程共享
                属性;使用pthread_mutexattr_setpshared函数修改进程共享属性

                进程共享互斥量属性设置为PTHREAD_PROCESS_PRIVATE时,允许pthread线程库提供更有效的互斥量实现,
                这在多线程应用程序中是默认的情况;在多个线程共享多个互斥量的情况下,pthread线程库可以限制开销
                较大的互斥量实现

            互斥量健壮属性与在多个进程间共享的互斥量有关,这意味着当持有互斥量的进程终止时,需要解决互斥量
            状态恢复的问题.

            #include <pthread.h>
            int pthread_mutexattr_getrobust(const pthread_mutexattr_t *restrict attr,
                                            int *restrict robust);
            int pthread_mutexattr_setrobust(pthread_mutexattr_t *attr, int robust);

            返回值:
                成功,返回0
                出错,返回错误编号

            函数说明:
                pthread_mutexattr_getrobust函数用来获取健壮的互斥量属性的值
                pthread_mutexattr_setrobust函数用来设置健壮的互斥量的值

                健壮属性取值有两种可能的情况:
                    a.  默认值是PTHREAD_MUTEX_STALLED,这意味着持有互斥量的进程终止时不需要采取特别
                        的动作,这种情况下,使用互斥量后的行为是未定义的,等待该互斥量解锁的应用程序会
                        被有效的"拖住"
                    b.  另一个取值是PTHREAD_MUTEX_ROBUST,这个值将导致线程调用pthread_mutex_lock获取锁,
                        而该锁的被另一个进程持有,但它终止时并没有对该锁进行解锁,此时线程会阻塞,从
                        pthread_mutex_lock返回的值为EOWNERDEAD而不是0

                使用健壮的互斥量改变了我们使用pthrea_mutex_lock的方式,因为现在必须要检查3个返回值:
                    a.  不需要恢复的成功
                    b.  需要恢复的成功
                    c.  失败

            如果应用状态无法恢复,在线程对互斥量解锁以后,该互斥量将处于永久不可用状态,为了避免这样的问题,
            线程可以调用pthread_mutex_consistent函数,指明与该互斥量相关的状态在与互斥量解锁之前是一致的

            #include <pthread.h>
            int pthread_mutex_consistent(pthread_mutex_t *mutex);

            返回值:
                成功,返回0
                出错,返回错误编号

            函数说明:
                如果线程没有先调用pthread_mutex_consistent就对互斥量进行了解锁,那么其他试图获取该互斥量
                的阻塞线程就会得到错误码ENOTRECOVERABLE,如果发生这种情况,互斥量将不再可用
                线程通过提前调用pthread_mutex_consistene,能让互斥量正常工作,这样互斥量可以持续被使用


        类型互斥量控制着互斥量的锁定特性,POSIX.1定义了4种类型:
            PTHREAD_MUTEX_NORMAL        -   一种标准互斥量类型,不做任何特殊的错误检查或死锁检测
            PTHREAD_MUTEX_ERRORCHECK    -   此互斥量类型提供错误检查
            PTHREAD_MUTEX_RECURSIVE     -   此互斥量类型允许同一线程在互斥量解锁之前对该互斥量进行多次加锁.
                                            递归互斥量维护锁的计数,在解锁次数和加锁次数不相同的情况下,不会
                                            释放锁;所以,如果对一个递归互斥量加锁两次,然后解锁一次,那么这个
                                            互斥量依然处于加锁状态,对它再次解锁以前不能释放该锁
            PTHREAD_MUTEX_DEFAULT       -   此互斥量类型可以提供默认特性和行为,操作系统在实现它的时候可以
                                            把这种类型自由的映射到其他互斥量类型中的一种

        4种互斥量的一些处理行为:
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
            互斥量类型      *   没有解锁时重新加锁  *   不占用时解锁    *   在已解锁时解锁
        PTHREAD_MUTEX_NORMAL        死锁                    未定义              未定义
        PTHREAD_MUTEX_ERRORCHECK    返回错误                返回错误            返回错误
        PTHREAD_MUTEX_RECURSIVE     允许                    返回错误            返回错误
        PTHREAD_MUTEX_DEFAULT       未定义                  未定义              未定义
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

            #include <ptread.h>
            int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict attr, int *restrict type);
            int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);

            返回值:
                成功,返回0
                出错,返回错误编号

            函数说明:
                pthread_mutexattr_gettype函数来获得互斥量类型属性
                pthread_mutexattr_settype函数来修改互斥量类型属性

            见Chapter_12/recMutex.c     使用递归互斥量

        2)  读写锁属性
            读写锁支持的唯一属性是进程共享属性,与互斥量的进程共享属性是相同的

            #include <pthread.h>
            int pthread_rwlockattr_init(pthread_rwlockattr_t *attr);
            int pthread_rwlockattr_destroy(pthread_relockattr_t *attr);

            返回值:
                成功,返回0
                出错,返回错误编号

            函数说明:
                pthread_rwlockattr_init -   初始化pthread_rwlockattr_t 结构
                pthread_rwlockattr_destroy  -   销毁pthread_rwlockattr_t结构(反初始化)


            #include <pthread.h>
            int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *restrict attr,
                                                int *restrict pshared);
            int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *attr, int pshared);

            返回值:
                成功,返回0
                出错,返回错误编号

            函数说明:
                用于读取和设置读写锁的进程共享属性

        3)  条件变量属性
            Single UNIX Specification目前定义了条件变量的两个属性:进程共享属性和时钟属性

            #include <pthread.h>
            int pthread_condattr_init(pthread_condattr_t *attr);
            int pthread_condattr_destroy(pthread_condattr_t *attr);

            返回值:
                成功,返回0
                出错,返回错误编号

            函数说明:
                pthread_condattr_t结构的初始化和反初始化

            同步属性:   条件变量支持进程同步属性,它控制着条件变量是可以被单进程的多个线程使用,还是可以被
                        多进程的线程使用

            #include <pthread.h>
            int pthread_condattr_getpshared(const pthread_condattr_t *restrict attr,
                                            int *restrict pshared);
            int pthread_condattr_setpshared(pthread_condattr_t *attr, int pshared);

            返回值:
                成功,返回0
                出错,返回错误编号

            函数说明:
                pthread_condattr_getpshared -   获取进程共享属性的当前值
                pthread_condattr_setpshared -   设置进程共享属性的值

            时钟属性:   控制计算pthread_cond_timewait函数的超时参数(tsptr)时采用的是哪个时钟

            #include <pthread.h>
            int pthread_condattr_getclock(const pthread_condattr_t *restrict attr,
                                            clockid_t *restrict clock_id);
            int pthread_condattr_setclock(pthread_condattr_t *attr, clockid_t clock_id);

            返回值:
                成功,返回0
                出错,返回错误编号

            函数说明:
                pthread_condattr_getclock   -   获取可被用于pthread_cond_timedwait函数的时钟ID
                                                在使用pthread_cond_timedwait函数前需要用pthread_condattr_t
                                                对象对条件变量进行初始化
                pthread_condattr_setclock   -   用于对时钟ID进行修改

        4)  屏障属性
            目前定义的屏障属性只有进程共享属性,它控制着屏障是可以被多进程的线程使用,还是只能被初始化屏障
            的进程内的多线程使用。

            #include <pthread.h>
            int pthread_barrierattr_init(pthread_barrierattr_t *attr);
            int pthread_barrierattr_destroy(pthread_barrierattr_t *attr);

            返回值:
                成功,返回0
                出错,返回错误编号

            函数说明:
                对pthread_barrierattr_t结构的初始化和反初始化

            #include <pthread.h>
            int pthread_barrierattr_getpshared(const pthread_barrierattr_t *restrict attr, 
                                                int *restrict pshared);
            int pthread_barrierattr_setpshared(pthread_barrierattr_t *attr, int pshared);

            返回值:
                成功,返回0
                出错,返回错误编号

            函数说明:
                pthread_barrierattr_getpshared  -   获取属性值
                pthread_barrierattr_setpshared  -   设置属性值

    4、 重入
        如果一个函数在相同的时间点可以被多个线程安全的调用,则称该函数是线程安全的

        POSIX.1提供了以线程安全的方式管理FILE对象的方法,可以使用flockfile和ftrylockfile获取给定
        FILE对象关联的锁,这个锁是递归的:当你把占有这把锁时,可以再次获取锁,不会导致死锁

        #include <stdio.h>
        int ftrylockfile(FILE *fp);     成功,返回0;若不能获取锁,返回非0数值
        void flockfile(FILE *fp);
        void funlockfile(FILE *fp);

        如果标准I/O例称都能获取它们各自的锁,那么在做一次一个字符的I/O时就会出现严重的性能下降;
        在这种情况下,需要对每一个字符的读写操作进行获取锁和释放锁的动作,为了避免这种开销,出现了不加锁
        版本的基于字符的标准I/O例程。

        #include <stdio.h>
        int getchar_unlocked(void);
        int getc_unlocked(FILE *fp);
        
        返回值:
            成功,返回下一个字符;若遇到文件尾或出错,返回EOF
        
        int putchar_unlocked(int c);
        int putc_unlocked(int c, FILE *fp);
        
        返回值:
            成功,返回c
            出错,返回EOF

        注:
            除非被flcokfile(或ftrylockfile)和funlockfile的调用包围,否则尽量不要调用这4个函数,
            因为它们会导致不可预期的结果

        见Chapter_12/getEnv.c   -   不可重入版本
        见Chapter_12/getEnv_r.c -   可重入版本(线程安全版本)

    5、 线程特定数据(thread-specific data)
        线程特定数据,也称为线程私有数据(thread-private data),是存储和查询某个特定线程相关数据的一种机制。
        一个进程中的所有线程都可以访问这个进程的整个地址空间,除了使用寄存器以外,一个线程没办法阻止另
        一个线程访问它的数据。
        所以管理线程特定数据的函数可以提高线程间的数据独立性

        在分配线程特定数据之前,需要创建于该数据关联的键,这个键将用于获取对线程特定数据的访问,使用
        pthread_key_create创建一个键

        #include <pthread.h>
        int pthread_key_create(pthread_key_t *keyp, void (*destructor)(void *));

        返回值:
            成功,返回0
            出错,返回错误编号

        函数说明:
            创建的键存储在keyp指向的内存单元中,这个键可以被进程中的所有线程使用,但每个线程把这个键与不同
            的线程特定数据地址进行关联,创建新键时,每个线程的数据地址设置为空值。
            
            除了创建键以外,pthread_key_create可以为该键关联一个可选择的析构函数,当这个线程退出时,如果数据
            地址已经被置为非空值,那么析构函数就会被调用,它唯一的参数就是该数据地址。
            如果传入的析构函数为空,就表明没有析构函数与这个键关联

        当线程调用pthread_exit或者线程执行返回,正常退出时,析构函数就会被调用;
        线程取消时,只有在最后的清理处理程序返回之后,析构函数才会被调用;
        如果线程调用了exit、_exit、_Exit或abort,或者出现其他非正常的退出,就不会调用析构函数

        线程可以为线程特定数据分配多个键,每个键都可以有一个析构函数与它关联,每个键的析构函数可以互
        不相同,所有的键也可以使用相同的析构函数;
        每个操作系统实现可以对进程可分配的键的数量进行限制(PTHREAD_KEYS_MAX)

        线程退出时,线程特定数据的析构函数将按照操作系统实现中的定义顺序被调用,析构函数可能会调用另一个函数,
        该函数可能会创建新的线程特定数据,并且把这个数据与当前的键关联起来;
        当所有的析构函数都调用完成以后,系统会检查是否还有非空的线程特定数据值与键关联,如果有的话,再次调用
        析构函数;这个过程将会一直重复直到线程所有的键都为空线程特定数据值,或者已经做了PTHREAD_DESTRUCTOR
        _ITERATIONS中定义的最大次数的尝试

        #include <pthread.h>
        int pthread_key_delete(pthread_key_t key);

        返回值:
            成功,返回0
            出错,返回错误编号

        函数说明:
            用来取消键与线程特定数据值之间的关联关系

        #include <pthread.h>
        pthread_once_t initflag = PTHREAD_ONCE_INIT;
        int pthread_once(pthread_once_t *initflag, void (*initfn)(void));

        返回值:
            成功,返回0
            出错,返回错误编号

        函数说明:
            initflag必须是一个非本地变量(如全局变量或静态变量),而且必须初始化为PTHREAD_ONCE_INIT
            如果每个线程都调用pthread_once,系统就能保证初始化例程initfn只被调用一次

        pthread_once示例程序:
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        void destructor(void *);    /* 析构函数 */

        pthread_key_t key;
        pthread_once_t init_done = PTHREAD_ONCE_INIT;
        
        void thread_init(void)
        {
            err = pthread_key_create(&key, destructor);  
        }

        int threadfunc(void *arg)
        {
            pthread_once(&init_done, thread_init);
            .
            .
            .
        }
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

        键一旦创建以后,就可以通过pthread_setspecific函数把键和线程特定数据关联起来

        #include <pthread.h>
        void *pthread_getspecific(pthread_key_t key);   返回线程特定数据值;若没有值与该键关联,返回NULL
        int pthread_setspecific(pthread_key_t key, const void *value);  成功,返回0;出错,返回错误编号

        函数说明:
            pthread_getspecific -   获取线程特定数据的地址,如果没有线程特定数据值与键关联,将返回NULL
            pthread_setspecific -   将键和线程特定数据关联起来

        见Chapter_12/specific.c     使用线程特定数据的示例程序

    6、 取消选项
        有两个线程属性并没有包含在pthread_attr_t结构中,它们是可取消状态和可取消类型;
        这两个属性影响着线程在相应pthread_cancel函数调用时所呈现的行为

        可取消状态属性可以是PTHREAD_CANCEL_ENABLE,也可以是PTHREAD_CANCEL_DISABLE
        线程可以通过调用pthread_setcancelstate修改它的可取消状态

        #include <pthread.h>
        int pthread_setcancelstate(int state, int *oldstate);

        返回值:
            成功,返回0
            出错,返回错误编号

        函数说明:
            pthread_setcancelstate把当前的可取消状态设置为atate,把原来的可取消状态存储在由oldstate指向的
            内存单元,这两步是一个原子操作

        线程启动时默认的可取消状态是PTHREAD_CANCEL_ENABLE,当状态设为PTHREAD_CANCEL_DISABLE时,对pthread_cancel
        调用并不会杀死线程,当取消状态再次变为PTHREAD_CANCEL_ENABLE时,线程将在下一个取消点上对所有挂起的取消
        请求进行处理.

        如果程序很长的一段时间内都不会调用取消点程序,那么可以调用pthread_testcnacel添加取消点。

        #include <pthread.h>
        void pthread_testcancel(void);

        函数说明:
            为线程添加一个取消检查点

        以上所描述的默认的取消类型也称为推迟取消,调用pthread_cancel以后,在线程到达取消点之前,并不会出现
        真正的取消;
        调用pthread_setcanceltype来修改取消类型

        #include <pthread.h>
        int pthread_setcanceltype(int type, int *oldtype);

        返回值:
            成功,返回0
            出错,返回错误编号

        函数说明:
            修改取消类型
            把取消类型设置为type(类型参数可以是PTHREADCANCEL_DEFERED,也可以是PTHREAD_CANCEL_ASYNCHRONOUS),
            把原来的取消类型返回到oldtype指向的整型单元

        异步取消和推迟取消不同,使用异步取消时,线程可以在任意时间撤销,不是非得遇到取消点才能被取消

    7、 线程和信号
        每个线程都有自己的信号屏蔽字,但是信号的处理是进程中所有线程共享的:
            这意味着单个线程可以阻止某些信号,但当某个线程修改了与某个给定信号相关的处理行为后,所有的线程
            都必须共享这个处理行为的改变

        进程中的信号是递送到单个线程的,如果一个信号与硬件故障相关,那么该信号一般会被发送到引起该事件的线程
        中去,而其他的信号则被发送到任意一个线程

        #include <signal.h>
        int pthread_sigmask(int how, const sigset_t *restrict set, sigset_t *restrict oset);

        返回值:
            成功,返回0
            出错,返回错误编号

        函数说明:
            sigprocmask函数(阻止信号发送)的行为在多线程的进程中并没有定义,线程必须是要pthread_sigmask
            pthread_sigmask函数与sigprocmask函数基本相同,how参数的取值有3个:
                SIG_BLOCK       -   把信号集添加到线程信号屏蔽字的信号集
                SIG_SETMASK     -   用信号集替换线程的信号屏蔽字
                SIG_UNBLOCK     -   从线程信号屏蔽字中移除信号集
            线程可以把set参数设置为NULL,并把oset参数设置为sigset_t结构的地址,来获取当前信号屏蔽字,这种
            情况下how参数会被忽略

        #include <signal.h>
        int sigwait(const sigset_t *restrict set, int *restrict signop);

        返回值:
            成功,返回0
            出错,返回错误编号

        函数说明:
            线程通过调用sigwait等待一个或多个信号的出现
            set参数指定了线程等待的信号集,返回时,signop指向的整数将包含发送信号的数量

        如果某个信号在sigwait调用的时候处于挂起状态,那么sigwait将无阻塞的返回;
        在返回之前,sigwait将从进程中移除那些处于挂起等待状态的信号。
        如果具体实现支持信号排队,并且信号的多个实例被挂起,那么sigwait将会移除该信号的一个实例,其他继续排队

        #include <signal.h>
        int pthread_kill(pthread_t thread, int signo);

        返回值:
            成功,返回0
            出错,返回错误编号

        函数说明:
            将信号发送给指定线程.
            可以传一个0值的signo来检查线程是否存在
            如果信号的默认处理动作是终止该进程,那么把信号传递给某个线程仍然会杀死整个进程

        见Chapter_12/pthreadSignal.c

    8、 线程和fork
        子进程通过继承整个地址空间的副本,还从父进程那儿继承了每个互斥量、读写锁和条件变量的状态。
        如果父进程包含一个以上的线程,子进程在fork返回以后,如果紧接着不是马上调用exec的话,就需要
        清理锁状态

        在子进程内部,只存在一个线程,它是由父进程中调用fork的线程的副本构成的,如果父进程中的线程占有锁,
        子进程将同样占有这些锁;问题是子进程并不包含占有锁的线程的副本,所以子进程就没有办法知道它占有了
        哪些锁、需要释放哪些锁

        要清除锁状态,可以通过调用pthread_atfork函数建立fork处理程序

        #include <pthread.h>
        int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void));

        返回值:
            成功,返回0
            出错,返回错误编号

        函数说明:
            用pthread_atfork函数最多可以安装3个帮助清理锁的函数。
            prepare fork处理程序由父进程在fork创建子进程之前调用,这个fork处理程序的任务是获取父进程定义的
            所有锁
            parent fork处理程序是在fork创建子进程以后、返回之前在父进程上下文中调用,这个fork处理程序的任务
            是对prepare fork处理程序获取的所有锁进行解锁
            child fork处理程序在fork返回之前在子进程上下文中调用,与parent fork处理程序一样,child fork处理
            程序也必须释放prepare fork处理程序获取的所有锁

        可以多次调用pthread_atfork函数从而设置多套fork处理程序;
        使用多个fork处理程序的调用顺序并不相同,parent和child fork处理程序是以它们注册时顺序进行调用的,
        而prepare fork处理程序的调用顺序与注册时的顺序相反,这样可以允许多个模块注册它们自己的fork处理程序,
        从而保持锁的层次

        见Chapter_12/atFork.c   使用pthread_atfork和fork处理程序的示例

    9、 线程和I/O
        使用pread和pwrite函数,见第3章

第13章、    守护进程
    1、 守护进程(daemon)
        守护进程没有控制终端,它们执行日常事务活动

    2、 守护进程的特征
        在Linux中:
            a.  kswapd守护进程  -   也称为内存换页守护进程,它支持虚拟内存子系统在经过一段时间后将脏页面
                                    慢慢写回磁盘来回收这些页面
            b.  flush守护进程   -   在可用内存达到设置的最小阀值时将脏页面冲洗至磁盘,它也定期的将脏页面
                                    冲洗回磁盘来减少在系统出现故障时发生的数据丢失。多个冲洗守护进程可以
                                    同时存在,每个写回的设备都有一个冲洗守护进程
            c.  sync_supers     -   定期将文件系统元数据冲洗至磁盘

            d.  rpcbind守护进程 -   提供将远程过程调用(Remote Procedure Call, RPC)程序号映射为网络端口号
                                    的服务
            e.  rsyslogd        -   可以被由管理员启用的将系统消息记入日志的任何程序使用

            f.  inetd守护进程   -   侦听系统网络接口,以便取得来自网络的对各种网络服务进程的请求

    3、 编程规则
        编写守护进程程序时要遵循的一些基本规则:
            1)  调用umask将文件模式创建屏蔽字设置为一个已知值(通常是0).
                由继承得来的文件模式创建屏蔽字可能会被设置为拒绝某些权限,如果守护进程要创建文件,那么
                它可能要设置特定的权限。

            2)  调用fork,然后父进程exit。
                这样做实现了以下几点:第一,如果该守护进程是作为一条简单的shell命令启动的,那么父进程终止
                会让shell认为这条命令已经执行完毕;  第二,虽然子进程继承了父进程的进程组ID,但获得了一个
                新的进程ID,这就保证了子进程不是一个进程组的组长进程,这是下面将要进行的setsid调用的先决
                条件。

            3)  调用setsid创建一个新会话,然后执行3个步骤:   
                a.  成为新会话的首进程
                b.  成为一个新进程组的组长进程
                c.  没有控制终端

            4)  将当前目录更改为根目录
                从父进程继承过来的当前工作目录可能是在一个挂载的文件系统中

            5)  关闭不再需要的文件描述符
                这使守护进程不再持有从其父进程继承来的任何文件描述符
                可以使用open_max函数或getrlimit函数来判定最高文件描述符值,并关闭直到该值的所有描述符

            6)  某些守护进程打开/dev/null使其具有文件描述符0、1、2,这样一个试图读标准输入、写标准输出或
                标准错误的库例程都不会产生任何效果

            见Chapter_13/daemonize.c

    4、 出错记录(日志)
        有以下3种产生日志消息的方法:
            a.  内核例程可以调用log函数。
                任何一个用户进程都可以通过打开(opne)并读取(read)/dev/klog设备来读取这些消息
            
            b.  大多数用户进程(守护进程)调用syslog函数来产生日志消息,这使消息被发送至UNIX域数据报
                套接字/dev/log

            c.  无论一个用户进程是在此主机上,还是在通过TCP/IP网络连接到此主机的其他主机上,都可将日志
                消息发向UDP端口514. syslog函数从不产生这些UDP数据报,它们要求产生此日志消息的进程进行
                显式的网络编程.

        通常,syslogd守护进程读取所有3种格式的日志消息。此守护进程在启动时读一个配置文件,其文件名一般为
        /etc/syslog.conf,该文件决定了不同种类的消息应送向何处。

        #include <syslog.h>
        void openlog(const char *ident, int option, int facility);
        void syslog(int priority, const char *format, ...);
        void closelog(void);
        int setlogmask(int maskpri);

        返回值:
            当前日志记录优先级屏蔽字值

        函数说明:
            调用openlog是可选择的,如果不调用openlog,则在第一次调用syslog时,自动调用openlog;
            调用closelog也是可选择的,它只是关闭曾被用于与syslogd守护进程进行通信的描述符

            调用openlog使我们可以指定一个ident,以后,此ident将被加至每则日志消息中,一般是程序名称
            option参数是指定各种选项的位屏蔽:
                LOG_CONS    -   若日志消息不能通过UNIX域数据报送至syslogd,则将该消息写至控制台
                LOG_NDELAY  -   立即打开至syslogf守护进程的UNIX域数据报套接字,不要等到第一条消息已经被
                                记录时再打开,通常,在记录第一条消息之前,不打开该套接字
                LOG_NOWAIT  \   LOG_ODELAY  \   LOG_PERROR  \   LOG_PID
            调用syslog产生一个日志消息,其priority参数是facility和level的组合,level级别:
                LOG_EMERG   -   紧急(系统不可用)
                LOG_ALERT   -   必须立即修复的情况
                LOG_CRIT    -   严重情况
                LOG_ERR     -   出错情况
                LOG_WARNING -   警告情况
                LOG_NOTICE  -   正常但重要的情况
                LOG_INFO    -   信息性消息
                LOG_DEBUG   -   调试消息
            
            将format参数以及其他所有参数传至vsprintf函数以便进行格式化,在format中,每个出现的%m字符都先
            被替换成与errno值对应的出错消息字符串strerror

            setlogmask函数用于设置进程的记录优先级屏蔽字

        #include <syslog.h>
        #include <stdarg.h>
        void vsyslog(int priority, const char *format, va_list arg);

        大多数syslog实现将使消息短时间处于队列中,如果在此段时间中有重复消息到达,那么syslog守护进程不会
        把它写到日志记录中,而是会打印输出一条类似于"上一条消息重复了N次"的消息

    5、 单实例守护进程
        在任何时刻只运行该守护进程的一个副本
        文件和记录锁机制为一种方法提供了基础,该方法保证一个守护进程只有一个副本在运行。
        如果每一个守护进程创建一个有固定名字的文件,并在该文件的整体上加一把锁,那么只允许创建一把这样
        的写锁,在此之后创建写锁的尝试都会失败,这向后续守护进程副本指明已经有一个副本正在运行。

        文件和记录锁提供了一种方便的互斥机制,如果守护进程在一个文件的整体得到一把写锁,那么在该守护进程
        终止时,这把锁将被自动删除,这就简化了复原所需的处理,去除了对以前守护进程实例需要进行清理的有关
        操作

        见Chapter_13/daemonExample.c

    6、 守护进程的惯例
        在UNIX系统中,守护进程遵循下列通用惯例:
        a.  若守护进程使用锁文件,那么该文件通常存储在/var/run目录中。然而需要注意的是,守护进程可能需要
            具有超级用户权限才能在此目录下创建文件,锁文件的名字通常是name.pid,其中name是该守护进程或服
            务的名字

        b.  若守护进程支持配置选项,那么配置文件通常放在/etc目录中。配置文件的名字通常是name.conf

        c.  守护进程可用命令行启动,但通常它们是由系统初始化脚本之一(/etc.rc*或/etc/init.d/*)启动的
            如果在守护进程终止时,应当自动的重新启动它们,则我们可以在/etc/inittab中为该守护进程包括
            respawn记录项,这样init就将重新启动该守护进程

        d.  若一个守护进程有一个配置文件,那么当该守护进程启动时会读该文件,但在此之后一般就不会再
            查看它,若想配置文件修改之后不重启守护进程读取,某些守护进程将捕捉SIGHUP信号,当它们接收
            到该信号时,重新读取配置文件;
            因为守护进程不与终端相结合,它们或者是无控制终端的会话首进程,或者是孤儿进程组的成员,所
            以守护进程没有理由期望接收SIGHUP,于是守护进程可以安全的重复使用SIGHUP

        见Chapter_13/readConf.c 守护进程重读配置文件的一种实现

    7、 客户进程-服务器进程模型
        见src/tools.c   set_cloexec(int fd) 函数

第14章、 高级I/O

    1、前言
        本章涵盖的概念和函数:
            非阻塞I/O、记录锁、I/O多路转接(select和poll函数)、异步I/O、readv和writev函数
            以及存储映射I/O(mmap)

    2、非阻塞I/O
        系统调用分为两类:   低速系统调用和其他
        低速系统调用是可能会使进程永远阻塞的一类系统调用
        非阻塞I/O使我们可以发出open、read和write这样的I/O操作,并使这些函数在调用后不能立即完成时,立即
        出错返回,表示该操作如继续执行将阻塞

        对于一个给定的描述符,有两种为其指定非阻塞I/O的方法:
        1)  如果调用open获得描述符,则可指定O_NONBLOCK标志
        2)  对于已经打开的一个文件描述符,则可以调用fcntl,由该函数打开O_NONBLOCK文件状态标志

    3、 记录锁(record locking)
        记录锁的功能是: 当第一个进程正在读或修改某个文件的某个部分时,使用记录锁可以阻止其他进程修改同一
                        文件区。
        记录锁更准确的说法是字节范围锁(byte-range locking),因为它锁定的只是文件中的一个区域(也可能是整个文件)

        #include <fcntl.h>
        int fcntl(int fd, int cmd, ... /* struct flock *flockptr */);

        返回值:
            成功,依赖于cmd
            出错,返回-1

        函数说明:
            对于记录锁,cmd是F_GETLK、F_SETLK 或 F_SETLKW; 第三个参数(我们将调用flockptr)是一个指向flock结构
            的指针:
                struct flock {
                    short   l_type;         /* F_RDLCK, F_WRLCK, or F_UNLCK */
                    short   l_whence;       /* SEEK_SET, SEEK_CUR, or SEEK_END */
                    off_t   l_start;        /* offset in bytes, relative to l_whence */
                    off_t   l_len;          /* length, in bytes; 0 means lock to EOF */
                    pid_t   l_pid;          /* returned with F_GETLK */
                };
            flock 结构说明:
                l_type  -   锁类型: F_RDLCK(共享读锁)、F_WRLCK(独占性写锁)或F_UNLCK(解锁一个区域)
                l_len   -   区域的字节长度
                l_pid   -   进程的ID持有的锁能阻塞当前进程(仅由F_GETLK返回)
                l_start和l_whence   -   要加锁或解锁区域的起始字节偏移量

            关于加锁解锁区域的注意事项:
                a.  指定区域起始偏移量的两个元素与lseek函数中最后两个参数类似
                b.  锁可以在当前文件尾端处开始或越过尾端处开始,但是不能在文件起始位置之前开始
                c.  若l_len为0,则表示锁的范围可以扩展到最大可能偏移量;这意味着不管向该文件追加写了多少
                    数据,它们都可以处于锁的范围内,而且起始位置可以是文件中的任意一个位置
                d.  为了对整个文件加锁,我们设置l_start和l_whence指向文件的起始位置,并且指定长度(l_len)为0
                    (有多种方法可以指定文件起始处,但常用的方法是将l_start指定为0,l_whence指定为SEEK_SET)

            共享读锁(L_EDLCK)和独占性写锁(L_WRLCK)的规则是:
                任意多个进程在一个给定的字节上可以有一把共享的读锁,但是在一个给定字节上只能有一个进程有一把
                独占写锁;
                进一步而言,如果在一个给定字节上已经有一把或多把读锁,则不能在该字节上再加写锁;
                如果在一个字节上已经有一把独占性写锁,则不能再对它加任何读锁

            上面说明的兼容性规则适用于不同进程提出的锁请求,并不适用于单个进程提出的多个锁请求。
            如果一个进程对一个文件区间已经有了一把锁,后来该进程又企图在同一个文件区间再加一把锁,那么新锁将
            替换已有锁。
            加读锁时,该描述符必须是读打开的;加写锁时,该描述符必须是写打开的

            fcntl函数的3种命令:
                F_GETLK     -   判断由flockptr所描述的锁是否会被另外一把锁排斥(阻塞)
                F_SETLK     -   设置由flockptr所描述的锁
                F_SETLKW    -   这个命令是F_SETLK的阻塞版本(命令名中的W表示等待wait)

            用F_GETLK测试能否建立一把锁,然后用F_SETLK或F_SETLKW试图建立那把锁

        锁的隐含继承和释放
            关于记录锁的自动继承和释放有3条规则:
            a.  锁与进程和文件两者相关联
                第一,当一个进程终止时,它所建立的锁全部释放
                第二,当一个描述符关闭时,该进程通过这一描述符引用的文件上的任何一把锁都会释放

            b.  由fork产生的子进程不继承父进程所设置的锁
                这意味着若一个进程得到了一把锁,然后调用fork,那么对于父进程获得的锁而言,子进程被视为另一个进程。
                对于通过fork从父进程处继承过来的描述符,子进程需要调用fcntl才能获得它自己的锁

            c.  在执行exec后,新程序可以继承原执行程序的锁
                注意,如果对一个文件描述符设置了执行时关闭标志,那么当作为exec的一部分关闭该文件描述符时,将释放
                相应文件的所有锁

    4、 I/O多路转接
        4.1、 select 和 pselect 函数
            传给select的参数告诉内核:
                a.  我们所关心的描述符
                b.  对于每个描述符我们所关心的条件(是否想从一个给定的描述符读,是否想写一个给定的描述符,
                    是否关心一个给定描述符的异常事件)
                c.  愿意等待多长时间(可以永远等待、等待一个固定的时间或者根本不等待)

            从select返回时,内核告诉我们:
                a.  已经准备好的描述符的总数量
                b.  对于读、写或异常这3个条件中的每一个,哪些描述符已准备好

            #include <sys/select.h>
            int select(int maxfdpl, fd_set *restrict readfds, fd_set *restrict writefds,
                        f_set *restrict exceptfds, struct timeval *restrict tvptr);

            返回值:
                准备就绪的描述符数目;
                若超时,返回0;
                出错,返回-1

            函数说明:
                tvptr   -   它指定愿意等待的时间长度,单位为秒和微秒,有一下3种情况:
                    tvptr == NULL
                        永远等待,如果捕捉到一个信号则中断此无限等待,此时select返回-1,errno设置为EINTR
                    tvptr->tv_sec == 0 && tvptr->tv_usec == 0
                        根本不等待,测试所有指定的描述符并立即返回,这是轮训系统找到多个描述符状态而不阻塞
                        select函数的方法
                    tvptr->tv_sec != 0 || tvptr->tv_usec != 0
                        等待指定时间,当指定的描述符之一已准备好,或超时时立即返回

                readfds\writefds\exceptfds  -   指向描述符集的指针
                    fd_set  -   通常认为它是一个很大的字节数组,它可以为每一个描述符保持一位

                maxfdpl -   最大文件描述符编号值加1

            select 函数返回值处理:
                a.  返回值-1表示出错
                b.  返回值0表示没有描述符准备好,此时所有的描述符集都会置0
                c.  一个正返回值说明了已经准备好的描述符数;该值是3个描述符集中已准备好的描述符数之和,
                    所以如果同一个描述符已准备好读和写,那么在返回值中会对其计两次数;在这种情况下,3个
                    描述符集中仍旧打开的位对应于已准备好的描述符.
                    对于"准备好"的含义进一步说明:
                        1)  若对读集(readfds)中的一个描述符进行的read操作不会阻塞,则认为此描述符是准备好的
                        2)  若写写集(writefds)中的一个描述符进行的write操作不会阻塞,则认为此描述符是准备好的
                        3)  若对异常条件集(exceptfds)中的一个描述符有一个未决异常条件,则认为此描述符是准备好的;
                            异常条件包括:在网络连接上到达带外的数据,或者在处于数据包模式的伪终端上发生了某些
                            条件
                        4)  对于读、写和异常条件,普通文件的文件描述符总是返回准备好
                
            对与fd_set数据类型,唯一可以进行的处理是: 分配一个这种类型的变量,将这种类型的变量赋值给同类型
            的另一个变量,或对这种类型的变量使用下列4个函数中的一个

            #include <sys/select.h>
            int FD_ISSET(int fd, fd_set *fdset);    若fd在描述符集中,返回非0值;否则返回0
            void FD_CLR(int fd, fd_set *fdset);
            void FD_SET(int fd, fd_set *fd_set *fdset);
            void FD_ZERO(fd_set *fdset);

            函数说明:
                FD_ZERO -   将一个fd_set变量所有位设置为0
                FD_SET  -   开启描述符集中的某一位
                FD_CLR  -   清除描述符集中的某一位
                FD_ISSET    -   测试描述符集中的一个指定位是否已打开

                使用示例:
                    fd_set  rset;
                    int     fd;
                    FD_ZERO(&rset);                 /* 将rset清空 */
                    FD_SET(fd, &rset);              /* 将fd添加到集合中 */
                    FD_SET(STDIN_FILENO, &rset);    /* 将STDIN_FILENO添加到集合中 */
                    FD_ISSET(fd, &rset);            /* 测试fd是否在rset中 */

            如果在一个描述符上碰到了文件尾端,则select会认为该描述符是可读的;然后调用read,它返回0,这是UNIX
            系统指示到达文件尾端的方法。

            POSIX.1也定义了一个select的变体,称为pselect

            #include <sys/select.h>
            int pselect(int maxfdpl, fd_set *restrict readfds, fd_set *restrict writefds, 
                        fd_set *restrict exceptfds, const struct timespec *restrict tsptr, 
                        const sigset_t *restrict sigmask);
            返回值:
                准备就绪的描述符数目;
                若超时,返回0;
                若出错,返回-1

            函数说明:
                除了下列几点外,pselect 和 select 相同:
                    a.  select的超时值用timeval结构指定,但pselect使用timespec结构
                    b.  pselect 的超时值被声明为const,这保证了调用pselect不会改变此值
                    c.  pselect 可使用可选信号屏蔽字;若sigmask为NULL,那么在与信号有关的方面,pselect 
                        的运行状况和select相同;否则,sigmask指向一信号屏蔽字,在调用pselect时,以原子操作的方式
                        安装该信号屏蔽字,在返回时,恢复以前的信号屏蔽字

        4.2、 函数poll
            
            #include <poll.h>
            int poll(struct pollfd fdarray[], nfds_t nfds, int timeout);

            返回值:
                准备就绪的描述符数目;
                若超时,返回0;
                若出错,返回-1;

            函数说明:
                与select不同,poll不是为每个条件(可读性、可写性和异常条件)构造一个描述符集,而是构造一个pollfd
                结构的数组,每个数组元素指定一个描述符编号以及我们对该描述符感兴趣的条件。
                    struct pollfd {
                        int     fd;         /* file descriptor to check, or < 0 to ignore */
                        short   events;     /* events of interest on fd */
                        short   revents;    /* events that occurred on fd */
                    };

                fdarray数组中的元素由nfds指定
                events 值告诉内核我们关心的是每个描述符的哪些事件;
                返回时,revents成员由内核设置,用于说明每个描述符发生了哪些事件
                
                events 和 revents标志:
                POLLIN      -   可以不阻塞的读高优先级数据以外的数据,等效于 POLLRDNORM|POLLRDBAND
                POLLRDNORM  -   可以不阻塞的读普通数据
                POLLRDBAND  -   可以不阻塞的读优先级数据
                POLLPRI     -   可以不阻塞的读优先级数据

                POLLOUT     -   可以不阻塞的写普通数据
                POLLWRNORM  -   与POLLOUT相同
                POLLWRBAND  -   可以不阻塞的写优先级数据

                POLLERR     -   已出错
                POLLHUP     -   已挂断
                POLLNVAL    -   描述符没有引用一个打开文件

                前4行测试的是可读性,接下来3行测试的是可写性,最后3行测试的是异常条件
                最后3行是由内核在返回时设置的,即使在events字段中没有指定这3个值,如果相应条件发生,在
                revents中也会返回它们

                当一个描述符被挂断(POLLHUP)后,就不能再写该描述符,但是有可能仍然可以从该描述符读到数据
        
                poll最后一个参数指定等待时长,3种情形:
                    timeout == -1
                        永远等待(某些系统在<stropts.h>中定义了常量INFTIM,其值是-1)
                    timeout == 0
                        不等待
                    timeout > 0
                        等待timeout毫秒

        5、 异步I/O
            
            5.1、 System V 异步I/O
                在System V中,异步I/O是STREAMS系统的一部分,它只对STREAMS设备和STREAMS管道起作用.
                System V的异步I/O信号是SIGPOLL

                为了对一个STREAMS设备启动异步I/O,需要调用ioctl,将它的第二个参数(request)设置成I_SETSIG,
                第3个参数设置为下列一个或多个常量构成的整形值:
                    S_INPUT     -   可以不阻塞的读取数据
                    S_RDNORM    -   可以不阻塞的读取普通数据
                    S_RDBAND    -   可以不阻塞的读取优先级数据
                    S_BANDURG   -   若此常量和S_RDBAND一起指定,当我们可以不阻塞的读取优先数据时,产生SIGURG
                                    信号而非SIGPOLL
                    S_HIPRI     -   可以不阻塞的读取高优先级数据

                    S_OUTPUT    -   可以不阻塞的写普通数据
                    S_WRNORM    -   与S_OUTPUT相同
                    S_WRBAND    -   可以不阻塞的写优先级数据

                    S_MSG       -   包含SIGPOLL信号的消息已经到达流头部
                    S_ERROR     -   流有错误
                    S_HANGUP    -   流已挂起

                除了调用ioctl指定产生SIGPOLL信号的条件以外,还应为该信号建立信号处理程序,对于SIGPOLL的默认
                动作是终止该进程,所以应当在调用ioctl之前建立信号处理程序

            5.2、 BSD异步I/O
                在BSD派生的系统中,异步I/O是信号SIGIO和SIGURG的组合,SIGIO是通用异步I/O信号,SIGURG则只用来通知
                进程网络连接上的带外数据已经到达
                为了接收SIGIO信号,需执行以下3步:
                    1)  调用signal或sigaction为SIGIO信号建立信号处理程序
                    2)  以命令F_SETOWN调用fcntl来设置进程ID或进程组ID,用于接收对于该描述符的信号
                    3)  以命令F_SETFL调用fcntl设置O_ASYNC文件状态标志,使在该描述符上可以进行异步I/O

                第3步仅能对指向终端或网络的描述符执行

            5.3、 POSIX异步I/O
                这些异步I/O接口使用AIO控制块来描述I/O操作,aiocb结构定义了AIO控制块.
                该结构至少包括下面这些字段:
                    struct aiocb {
                        int             aio_fildes;     /* file descriptor */
                        off_t           aio_offset;     /* file offset for I/O */
                        volatile void   *aio_buf;       /* buffer for I/O */
                        size_t          aio_nbytes;     /* number of bytes to transfer */
                        int             aio_reqprio;    /* priority */
                        struct sigevent aio_sigevent;   /* signal information */
                        int             aio_lio_opcode; /* operation for list I/O */
                    }
                aio_filelds字段表示被打开用来读或写的文件描述符,读或写操作从aio_offset指定的偏移量开始;
                对于读操作,数据会复制到缓冲区中,该缓冲区从aio_buf指定的地址开始;
                对于写操作,数据会从这个缓冲区中复制出来;
                
                注意,异步I/O操作必须显式的指定偏移量。异步I/O接口并不影响由操作系统维护的文件偏移量,只要不再
                同一个进程里把异步I/O函数和传统I/O函数混在一起用在同一个文件上,就不会导致什么问题。
                使用异步I/O接口向一个以追加模式(O_APPEND)打开的文件中写入数据,AIO控制块中的aio_offset字段会被
                系统忽略。

                其他字段和传统I/O函数中的不一致,应用程序使用aio_reqprio字段为异步I/O请求提示顺序;然而,系统对
                于该顺序只有有限的控制能力,因此不一定能遵循该提示。
                aio_lio_opcode字段只能用于基于列表的异步I/O
                aio_sigevent字段控制,在I/O事件完成后,如何通知应用程序,这个字段通过sigevent结构来描述:
                    struct sigevent {
                        int             sigev_notify;       /* notify type */ 
                        int             sigev_signo;        /* signal number */
                        union sigval    sigev_value;        /* notify argument */
                        void (*sigev_notify_function)(union sigval);    /* notify function */
                        pthread_attr_t *sigev_notify_attributes;        /* notify attrs */
                    }
                sigev_notify字段控制通知的类型,取下列值:
                    1)  SIGEV_NONE      -   异步I/O请求完成后,不通知进程
                    2)  SIGEV_SIGNAL    -   异步I/O请求完成后,长生由sigev_signo字段指定的信号,如果应用程序
                                            已选择捕捉信号,且在建立信号处理程序的时候指定了SA_SIGINFO标志,
                                            那么该信号将被入队(如果支持排队信号);信号处理程序会传送给一个
                                            siginfo结构,该结构的si_value字段被设置为sigev_value
                    3)  SIGEV_THREAD    -   当异步I/O请求完成时,由sigev_notify_function 字段指定的函数被调用。
                                            sigev_value字段被传入作为它的唯一参数;除非sigev_notify_attributes
                                            字段被设定为pthread属性结构的地址,且该结构指定了一个另外的线程属性,
                                            否则该函数将在分离状态下的一个单独的线程执行

                在进行异步I/O之前需要先初始化AIO控制块,调用aio_read函数来进行异步读操作,或者调用aio_write
                函数来进行异步写操作

                #include <aio.h>
                int aio_read(struct aiocb *aiocb);
                int aio_write(struct aiocb *aiocb);

                返回值:
                    成功,返回0
                    出错,返回-1

                函数说明:
                    当这些函数返回成功时,异步I/O请求便已经被操作系统放入等待处理的队列中了;
                    这些返回值与实际I/O操作的结果没有任何关系;

                要想强制所有等待中的异步操作不等待而写入持久化的存储中,可以设立一个AIO控制块并调用aio_fsync函数

                #include <aio.h>
                int aio_fsync(int op, struct aiocb *aiocb);

                返回值:
                    成功,返回0
                    出错,返回-1

                函数说明:
                    AIO控制块中的aio_fildes字段指定了其异步写操作被同步的文件;如果op参数设定为O_DSYNC,
                    那么操作执行起来就会像调用了fdatasync一样,如果op参数设定为O_SYNC,那么操作执行起来就会像调用
                    了fsync一样。

                    像aio_read和aio_write函数一样,在安排了同步时,aio_fsync操作返回;
                    在异步同步操作完成之前,数据不会被持久化,AIO控制块控制我们如何被通知

                为了获知一个异步读、写或者同步操作的完成状态,需要调用aio_error函数

                #include <aio.h>
                int aio_error(const struct aiocb *aiocb);

                返回值:
                    0       -   异步操作成功完成,需要调用aio_return函数获取返回值
                    -1      -   对aio_err的调用失败,这种情况下,errno会告诉我们为什么
                    EINPROGRESS     -   异步读、写或同步操作仍在等待
                    其他情况        -   其他任何返回值是相关异步操作失败返回的错误码

                如果异步操作成功,可以调用aio_return函数来获取异步操作的返回值
                #include <aio.h>
                ssize_t aio_return(const struct aiocb *aiocb);

                返回值:
                    失败,返回-1并设置errno
                    其他情况,返回异步操作的结果

                函数说明:
                    每个异步操作只调用一次aio_return, 一旦调用了该函数,操作系统就可以释放掉包含了I/O操作返回值
                    的记录

                执行I/O操作时,如果还有其他事务要处理而不想被I/O操作阻塞,就可以使用异步I/O;
                然而,如果在完成了所有事务时,还有异步操作未完成时,可以调用aio_suspend函数来阻塞进程,直到操作
                完成。
                #include <aio.h>
                int aio_suspend(const struct aiocb *const list[], int nent, const struct timespec *timeout);

                返回值:
                    成功,返回0
                    出错,返回-1

                函数说明:
                    aio_suspend可能会返回三种情况中的一种:
                        被一个信号中断,返回-1,并将errno设置为EINTR;
                        如果在没有任何I/O操纵完成的情况下,阻塞的时间超过了函数在可选的timeout参数所指定的时间
                        限制,那么aio_suspend将返回-1,并将errno设置为EAGAIN;
                        如果有任何I/O操作完成,aio_suspend将返回0

                    list参数是一个指向AIO控制块数组的指针,nent参数表明了数组中的条目数;
                    数组中的空指针会被跳过,其他条目都必须指向已用于初始化异步I/O操作的AIO控制块

                当还有我们不想再完成的等待中的异步I/O操作时,可以尝试使用aio_cancel函数来取消它们
                #include <aio.h>
                int aio_cancel(int fd, struct aiocb *aiocb);

                返回值:
                    AIO_ALLDONE     -   所以操作在尝试取消它们之前已经完成
                    AIO_CANCELED    -   所以要求的操作已被取消
                    AIO_NOTCANCELED -   至少有一个要求的操作没有被取消
                    -1              -   对aio_cancel的调用失败,错误码将被存储在errno中

                函数说明:
                    fd参数指定了那个未完成的异步I/O操作的文件描述符;
                    如果aiocb参数为NULL,系统将会尝试取消所有该文件上未完成的异步I/O操作
                    其他情况,系统将尝试取消由AIO控制块描述符的单个异步I/O操作

                    如果异步I/O操作被成功取消,对相应的AIO控制块调用aio_error函数会返回错误ECANCELED
                    如果操作不能被取消,那么相应的AIO控制块不会因为对aio_cancel的调用而被修改

                
                #include <aio.h>
                int lio_listio(int mode, struct aiocb *restrict const list[restrict], int nent,
                                struct sigevent *restrict sigv);

                返回值:
                    成功,返回0
                    出错,返回-1

                函数说明:
                    该函数提交一系列由一个AIO控制块列表描述的I/O请求
                    mode参数决定了I/O是否真的是异步的,如果该参数被设定为LIO_WAIT,lio_listio函数将在所有由
                    列表指定的I/O操作完成后返回,在这种情况下,sigev参数将被忽略。
                    如果mode参数被设定为LIO_NOWAIT,lio_listio函数将在I/O请求入队后立即返回。
                    进程将在所有I/O操作完成后,按照sigev参数指定的,被异步的通知;如果不想被通知,可以把sigev设定
                    为NULL
                    在每个AIO控制块中,aio_lio_opcode字段指定了该操作是一个读操作(LIO_READ)、写操作(LIO_WRITE),
                    还是将被忽略的空操作(LIO_NOP).读操作会按照对应的AIO控制块被传给了aio_read函数来处理,类似的
                    写操作会被传给aio_write函数来处理

        6、 readv 和 writev 函数

        #include <sys/uio.h>
        ssize_t readv(int fd, const struct iovec *iov, int iovcnt);
        ssize_t writev(int fd, const struct iovec *iov, int iovcnt);

        返回值:
            已读或已写的字节数
            出错,返回-1

        函数说明:
            readv 和 writev函数用于在一次函数调用中读、写多个非连续缓冲区,有时也将这两个函数称为散布读(scatter
            read)和聚集写(gather write).

            这两个函数的第二个参数指向iovec结构数组的一个指针:
                struct iovec {
                    void    *iov_base;      /* starting address of buffer */
                    size_t  iov_len;        /* size of buffer */
                };
            iov数组中的元素数由iovcnt指定,其最大值受限于IOV_MAX
            writev函数从缓冲区中聚集输出数据的顺序是:iov[0]、iov[1]直至iov[iovcnt-1];
            writev返回输出的字节总数,通常应等于所有缓冲区长度之和

        7、 readn 和 writen 函数
            管道、FIFO以及某些设备(特别是终端和网络)有下列两种性质:
            1)  一次read操作所返回的数据可能少于所要求的数据,即使还没有达到文件尾端;这不是一个错误,应当
                继续读该设备
            2)  一次write操作的返回值也可能少于指定输出的字节数,这可能是某个因素造成的,例如,内核输出缓冲区
                变满。这也不是错误,应当继续写余下的数据

            通常在读、写一个管道、网络设备或终端时,需要考虑这些特性。readn和writen的功能分别是读、写指定的
            N字节数据,并处理返回值可能小于要求值的情况,这两个函数只是按需多次调用read和write直至读、写了N字节
            数据。

            #include "apue.h"
            ssize_t readn(int fd, void *buf, size_t nbytes);
            ssize_t writen(int fd, void *buf, size_t nbytes);

            返回值:
                读、写的字节数
                出错,返回-1

        8、 存储映射I/O(memory-mapped I/O)
            存储映射I/O能将一个磁盘文件映射到存储空间中的一个缓冲区上,于是,当从缓冲区中取数据时,就相当于
            读文件中的相应字节。与此类似,将数据存入缓冲区时,相应字节就自动写入文件。
            这样就可以在不使用read和write的情况下执行I/O

            #include <sys/mman.h>
            void *mmap(void *addr, size_t len, int prot, int flag, int fd, off_t off);

            返回值:
                成功,返回映射区的起始地址
                出错,返回MAP_FAILED

            函数说明:
                告诉内核将一个给定的文件映射到一个存储区域中
                addr参数用于指定映射存储区的起始地址,通常将其设置为0,这表示由系统选择该映射区的起始地址,
                此函数的返回值是该映射区的起始地址。
                fd参数是指定要被映射文件的描述符,在文件映射到地址空间之前,必须先打开该文件。
                len参数是映射的字节数。
                off是要被映射字节在文件中的起始偏移量。
                prot参数指定了映射存储区的保护要求,如下:
                    PROT_READ   -   映射区可读
                    PROT_WRITE  -   映射区可写
                    PROT_EXEC   -   映射区可执行
                    PROT_NONE   -   映射区不可访问
                可将port参数指定为PROT_NONE,也可指定为PROT_READ、PROT_WRITE和PROT_EXEC的任意组合的按位或
                对指定映射存储区的保护要求不能超过文件open模式访问权限
                
                映射存储区位于堆和栈之间
                flag参数影响映射存储的多种属性:
                    MAP_FIXED       -   返回值必须等于addr.
                    MAP_SHARED      -   描述了本进程对映射区所进行的存储操作的配置
                    MAP_PRIVATE     -   本标志说明对映射区的存储操作导致创建该映射文件的一个私有副本;
                                        所有后来对该映射区的引用都是引用该副本

                off的值和addr的值(如果指定了MAP_FIXD)通常被要求是系统虚拟存储页长度的倍数;虚拟存储页长可用带
                参数_SC_PAGESIZE或_SC_PAGE_SIZE的sysconf函数得到

            与映射区相关的信号有SIGSEGV和SIGBUS:
            信号SIGSEGV通常用于指示进程试图访问对它不可用的存储区,如果映射存储区被mmap指定成了只读的,那么
            进程试图将数据存入这个映射存储区时,也会产生此信号;
            如果映射区的风某个部分在访问时已不存在,则产生SIGBUS信号

            子进程能通过fork继承存储映射区(因为子进程复制父进程地址空间,而存储映射区是该地址空间的一部分),
            但是由于同样的原因,新程序则不能通过exec继承映射存储区

            #include <sys/mman.h>
            int mprotect(void *addr, size_t len, int prot);

            返回值:
                成功,返回0
                出错,返回-1

            函数说明:
                调用mprotect可以更改一个现有映射的权限
                地址参数addr的值必须是系统页的整数倍

            如果修改的页是通过MAP_SHARED标志映射到地址空间的,那么修改并不会立即写回到文件中;相反,何时写回脏
            页由内核的守护进程决定,决定的依据是系统负载和用来限制在系统失败事件中的数据损失的配置参数。
            因此,如果只修改了一页中的一个字节,当修改被写回到文件中时,整个页都会被写回

            #include <sys/mman.h>
            int msync(void *addr, size_t len, int flags);

            返回值:
                成功,返回0
                出错,返回-1

            函数说明:
                如果共享映射中的页已修改,那么可以调用msync将该页冲洗到被映射的文件中
                flags参数使我们对如何冲洗存储区有某种程度的控制,可以指定MS_ASYNC标志来简单的调试要写的页;
                如果希望在返回之前等待写操作完成,则可指定MS_SYNC标志。
                一定要指定MS_ASYNC和MS_SYNC中的一个
                MS_INVALIDATE是一个可选标志,允许我们通知操作系统丢弃那些与底层存储器没有同步的页

            #include <sys/mman.h>
            int munmap(void *addr, size_t len);

            返回值:
                成功,返回0
                出错,返回-1

            函数说明:
                当进程终止时,会自动解除存储映射区的映射,或者直接调用munmap函数也可以解除映射区;
                关闭映射存储区时使用的文件描述符并不解除映射区

            见Chapter_14/mmap.c

            复制文件时,使用mmap\memcpy 和 read\write的区别:
                a.  使用mmap\memcpy减少了系统时间,花费相对多的用户时间
                b.  与mmap\memcpy相比,read\write执行了更多的系统调用,并做了更多的复制
                    read\write将数据从内核缓冲区中复制到应用缓冲区(read),然后再把数据从应用缓冲区复制到内核
                    缓冲区(write)。
                    而mmap\memcpy直接把数据从映射到地址空间的一个内核缓冲区复制到另一个内核缓冲区

第15章、 进程间通信
    1、 引言
    
        进程间通信(InterProcess Communication, IPC)
        种类(类型):
            半双工管道
            FIFO
            全双工管道
            命名全双工管道
            XSI消息队列
            XSI信号量
            XSI共享存储
            消息队列(实时)
            信号量
            共享存储(实时)
            套接字
            STREAMS

    2、 管道
        管道是UNIX系统最古老的形式,管道有以下两种局限性:
            1)  历史上,它们是半双工的(数据只能在一个方向流动);现在,某些系统提供全双工管道,
                但是为了最佳的可移植性,我们决不能预先假定系统支持全双工管道
            2)  管道只能在具有公共祖先的两个进程之间使用,通常一个管道由一个进程创建,在进程调用fork之后,
                这个管道就能在父进程和子进程之间使用了

            每当在管道中键入一个命令序列,让shell执行时,shell都会为每一条命令单独创建一个进程,然后用管道将
            前一条命令进程的标准输出与后一条命令的标准输入相连接

            管道是通过调用pipe函数创建的
            #include <unistd.h>
            int pipe(int fd[2]);

            返回值:
                成功,返回0
                出错,返回-1

            函数说明:
                创建一个管道,经由参数fd返回的两个文件描述符:
                fd[0]为读打开,fd[1]为写打开
                fd[1]的输出是fd[0]的输入

            fstat函数对管道的每一端都返回一个FIFO类型的文件描述符,可以用S_ISFIFO宏来测试管道

            当管道的一端被关闭后,下列两条规则起作用:
                1)  当读(read)一个写端已被关闭的管道时,在所有数据都被读取后,read返回0,表示文件结束。
                2)  如果写(write)一个读端已被关闭的管道.则产生信号SIGPIPE,如果忽略该信号或者捕捉该信号并
                    从其处理程序返回,则write返回-1,errno设置为EPIPE

            在写管道(或FIFO)时,常量PIPE_BUF规定了内核的管道缓冲区大小;如果对管道调用write,而且要求写的字节数
            小于等于PIPE_BUF,则此操作不会与其他进程对同一管道的write操作交叉进行;
            但是,若有多个进程同时写一个管道(或FIFO),而且我们要求写入的字节数超过PIPE_BUF,那么我们所写的数据
            可能会与其他进程所写的数据相互交叉。
            用pathconf或fpathconf函数可以确定PIPE_BUF的值

            见Chapter_15/pipe.c 父子进程使用管道通信

    3、 popen 和 pclose 函数
        
        #include <stdio.h>
        FILE *popen(const char *cmdstring, const char *type);   成功,返回文件指针;出错,返回NULL
        int pclose(FILE *fp);       成功,返回cmdstring的终止状态;出错,返回-1

        函数说明:
            这两个函数实现的操作是:创建一个管道,frok一个子进程,关闭未使用的管道端,执行一个shell运行命令,
            然后等待命令终止。

            popen先执行fork,然后调用exec执行cmdstring,并且返回一个标准I/O文件指针,如果type是"r",则
            文件指针连接到cmdstring的标准输出,如果type是"w",则文件指针连接到cmdstring的标准输入

            pclose 关闭标准I/O流,等待命令终止,然后返回shell的终止状态;如果shell不能被执行,则pclose返回的终止
            状态与shell已执行exit(127)一样

            cmdstring 由 Bourne shell 以下列方式执行:
            sh -c cmdstring
            这表示shell将扩展cmdstring中的任何特殊字符,例如:
            fp = popen("ls *.c", "r");

        见Chapter_15/popen.c

    4、 协同进程
        UNIX系统过滤程序从标准输入读取数据,向标准输出写数据;几个过滤程序通常在shell管道中线性连接,当一个过滤
        程序既产生某个过滤程序的输入,又读取该过滤程序的输出时,它就变成了协同进程(coprocess).

        协同进程通常在shell的后台运行,其标准输入和标准输出通过管道连接到另一个程序。

    5、 FIFO
        FIFO有时被称为命名管道.未命名的管道只能在两个相关的进程之间使用,而且这两个相关的进程还要有一个共同的
        祖先进程。
        通过FIFO,不相关的进程也能交换数据

        创建FIFO类似于创建文件
        #include <sys/stat.h>
        int mkfifo(const char *path, mode_t mode);
        int mkfifoat(int fd, const char *path, mode_t mode);

        返回值:
            成功,返回0;
            出错,返回-1

        函数说明:
            创建FIFO
            mkfifo函数中mode参数的规格说明与open函数中的mode相同
            mkfifoat函数与mkfifo类似,但是mkfifoat函数可以用来在fd文件描述符表示的目录相关位置创建一个FIFO
            与其他*at函数一样,有3种情形:
                1)  path参数指定绝对路径名,则fd参数会被忽略掉,mkfifoat 函数的行为和mkfifo类似
                2)  path参数指定相对路径名,则fd参数是一个打开目录的有效文件描述符,路径名和目录有关
                3)  path参数指定相对路径名,并且fd参数有一个特殊值AT_FDCWD,则路径名从当前目录开始,mkfifoat
                    和 mkfifo类似。

            当用mkfifo或者mkfifoat创建FIFO时,要用open来打开它,当open一个FIFO时,非阻塞标志(O_NONBLOCK)会产生
            下列影响:
                a.  在一般情况下(没有指定O_NONBLOCK),只读open要阻塞到某个其他进程为写而打开这个FIFO为止;
                    同样,只写open要阻塞到某个进程为读而打开它为止
                b.  如果指定了O_NONBLOCK,则只读open立即返回;但是,如果没有进程为读而打开一个FIFO,那么只写open
                    将返回-1,并将error设置成ENXIO

            类似于管道,若write一个尚无进程为读而打开的FIFO,则产生信号SIGPIPE;
            若某个FIFO的最后一个写进程关闭了该FIFO,则将为该的读进程产生一个文件结束的标志

            一个给定的FIFO有多个写进程是常见的,这就意味着,如果不希望多个进程所写的数据交叉,则必须考虑原子写操作。
            和管道一样,常量PIPE_BUF说明了可被原子的写到FIFO的最大数据量

            FIFO有以下两种用途:
                1)  shell命令使用FIFO将数据从一条管道传送到另一条时,无需创建中间临时文件
                2)  客户进程-服务器进程应用程序中,FIFO用作汇聚点,在客户进程和服务器进程二者之间传递数据

    6、 XSI IPC
        有3种称作XSI IPC的IPC:  消息队列、信号量以及共享存储器。
        6.1、 标识符和键
            每个内核中的IPC结构(消息队列、信号量或共享存储段)都用一个非负整数的标识符(identifier)加以引用。
            例如,要向一个消息队列发送消息或者从一个消息队列取消息,只需要知道其队列标识符。
            与文件描述符不同,IPC标识符不是小的整数;当一个IPC结构被创建,然后又被删除时,与这种结构相关的标识符
            连续加1,直至达到一个整型数的最大正值,然后又回转到0.

            标示符是IPC对象的内部名,为使多个合作进程能够在同一IPC对象上汇聚,需要提供一个外部命名方案,为此,
            每个IPC对象都与一个键(key)相关联,将这个键作为该对象的外部名。

            无论何时创建IPC结构(通过调用msgget、semget或shmget创建),都应指定一个键。这个键的数据类型是基本系统
            数据类型key_t,通常在头文件<sys/types.h>中被定义为长整形,这个键由内核变换成标识符。

            有多种方法使客户进程和服务器进程在同一IPC结构上汇聚:
            1)  服务器进程可以指定键IPC_PRIVATE创建一个新IPC结构,将返回的标识符存放在某处(如一个文件)以便客户进程
                取用。键IPC_PRIVATE保证服务器进程创建一个新IPC结构,这种技术的缺点是:文件系统操作需要服务器进程将
                整形标识符写到文件中,此后客户进程又要读这个文件取得此标识符。
                IPC_PRIVATE键也可用于父子进程关系,父进程指定IPC_PRIVATE创建创建一个新IPC结构,所返回的标识符可供
                fork后的子进程使用,接着,子进程又可将此标识符作为exec函数的一个参数传给一个新程序。

            2)  可以在一个公共头文件中定义一个客户进程和服务器进程都认可的键,然后服务器进程指定此键创建一个新的
                IPC结构。这种方法的问题是该键可能已与一个IPC结构相结合,在此情况下,get函数(msgget、semget或shmget)
                出错返回。服务器进程必须处理这一错误,删除已存在的IPC结构,然后试着再创建它。

            3)  客户进程和服务器进程认同一个路径名和项目ID(项目ID是0～255之间的字符值),接着调用函数ftok将这两个
                值变换为一个键。然后在方法2)中使用此键

            #include <sys/ipc.h>
            key_t ftok(const char *path, int id);   成功,返回键;出错,返回(key_t)-1

            函数说明:
                ftok提供的唯一服务就是由一个路径名和项目ID产生一个键。
                path参数必须引用一个现有的文件,当产生键时,只使用id参数的低8位。
                ftok创建的键通常是用下列方式构成的:按给定的路径名取得其stat结构中的部分st_dev和st_ino字段,然后再
                将它们与项目ID组合起来。

            3个get函数(msgget、semget和shmget)都有两个类似的参数: 一个key和一个整型flag。在创建新的IPC结构(通常
            由服务器进程创建)时,如果key是IPC_PRIVATE或者当前某种类型的IPC结构无关,则需要指明flag的IPC_CREAT标志位
            为了引用一个现有队列(通常由客户进程创建),key必须等于队列创建时指定的key的值,并且IPC_CREAT必须不被指明

            注意,不能指定IPC_PRIVATE作为键来引用一个现有队列,因为这个特殊的键值总是用于创建一个新队列。

            如果希望创建一个新的IPC结构,而且要确保没有引用具有同一标识符的一个现有IPD结构,那么必须在flag中同时
            指定IPC_CREAT 和 IPC_EXCL位。这样做了以后,如果IPC结构已经存在就会造成出错,返回EEXIST。

        6.2、 权限结构
            XSI IPC为每一个IPC结构关联了一个ipc_perm结构,该结构规定了权限和所有者,它至少包括下列成员:
                struct ipc_perm {
                    uid_t   uid;        /* owner's effective user id */
                    gid_t   gid;        /* owner's effective group id */
                    uid_t   cuid;       /* creator's effective user id */
                    gid_t   cgid;       /* creator's effective group id */
                    mode_t  mode;       /* access modes */
                    .
                    .
                    .
                };
            在创建IPC结构时,对所有字段都赋初值,以后可以调用msgctl、semctl 或 shmctl修改uid、gid和mode字段。
            为了修改这些值,调用进程必须是IPC结构的创建者或超级用户。修改这些字段类似于对文件调用chown和chmod

            消息队列和共享存储使用术语"读"和"写",而信号量则用术语"读"和"更改"

        6.3、 结构限制
            所以3种形式的XSI IPC都有内置限制,大多数限制可以通过重新配置内核来改变。
            Linux\MacOS X\FreeBS  提供了sysctl命令来观察和修改内核配置参数;
            Linux中,可以运行ipcs -l 来显示IPC相关的限制

        6.4、 优点和缺点
            XSI IPC的一个基本问题是: IPC结构是在系统范围内起作用的,没有引用计数。例如,如果进程创建了一个消息队列,
            并且在该队列中放入了几则消息,然后进程终止,那么该消息队列及其内容不会被删除,它们会一直留在系统中直至
            发生下列动作为止:
                a.  由某个进程调用msgrcv或msgctl读消息或删除消息队列
                b.  或某个进程执行ipcrm(1)命令删除消息队列
                c.  或正在自举的系统删除消息队列
            将此与管道相比,当最后一个引用管道的进程终止时,管道就被完全的删除了
            对于FIFO而言,在最后一个引用FIFO的进程终止时,虽然FIFO的名字仍保留在系统中,直至被显式删除,但是留在FIFO
            中的数据已经被删除了。

            XSI IPC的另一个问题时: 这些IPC结构在文件系统中没有名字,使用这些IPC对象,内核中增加了十几个全新的系统
            调用(msgget、semop、shmat等)
            ipcs    -   查看IPC对象
            ipcrm   -   删除IPC对象

            因为这些形式的IPC不使用文件描述符,所以不能对它们使用多路转接I/O函数

            优点:
                可靠、流控制(如果系统资源短缺,发送进程会休眠等待)、面向记录

    7、 消息队列
        消息队列是消息的链接表,存储在内核中,由消息队列标识符标识
        
        msgget用于创建一个新队列或打开一个现有队列,msgsnd将新消息添加到队列尾端,每个消息包含一个正的长整型
        类型的字段、一个非负的消息长度和实际数据字节数;所以这些都在将消息添加到队列时,传递给msgsnd。
        msgrcv用于从队列中取消息,并不一定要以先进先出次序取消息,也可以按消息的类型字段取消息
        每个队列都有一个msqid_ds结构与其向关联:
            struct msqid_ds {
                struct ipc_perm     msg_perm;
                msgqnum_t           msg_qnum;       /* # of messages on queue */
                msglen_t            msg_qbytes;     /* max # of bytes on queue */
                pid_t               msg_lspid;      /* pid of last msgend() */
                pid_t               msg_lrpid;      /* pid of last msgrcv() */
                time_t              msg_stime;      /* last-msgsnd() time */
                time_t              msg_rtime;      /* last-msgrcv() time */
                time_t              msg_ctime;      /* last-change time */
                ...
            };
        此结构定义了队列的当前状态

        #include <sys/msg.h>
        int msgget(key_t key, int flag);

        返回值:
            成功,返回消息队列ID
            出错,返回-1

        函数说明:
            创建一个新的队列或打开一个现有队列
            创建新队列时,要初始化msqid_ds结构的下列成员:
                ipc_perm    -   该结构中的mode成员按flag中的相应权限位设置
                msg_qnum、msg_lspid、msg_lrpid、msg_stime和msg_rtime都设置为0
                msg_ctime   -   设置为当前时间
                msg_qbytes  -   设置为系统限制值

        msgctl函数对队列执行多种操作,它和另外两个与信号量及共享存储有关的函数(semctl 和 shmctl)都是XSI IPC的
        类似于ioctl的函数(亦即垃圾桶函数)
        #include <sys/msg.h>
        int msgctl(int msqid, int cmd, struct msqid_ds *buf);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            cmd参数指定对msqid指定的队列要执行的命令:
                IPC_STAT    -   取此队列的msqid_ds结构,并将它存放在buf指向的结构中
                IPC_SET     -   将字段msg_perm.uid、msg_perm.gid、msg_perm.mode和msg_qbytes从buf指向的结构
                                复制到与这个队列相关的msqid_ds结构中;此命令只能由下列两种进程执行:一种是其
                                有效用户ID等于msg_perm.cuid 或 msg_perm.uid;另一种是具有超级用户权限的进程,
                                且只有超级用户才能增加msg_qbytes的值
                IPC_RMID    -   从系统中删除该消息队列以及仍在该队列中的所有数据。这种删除立即生效,仍在使用
                                这一消息队列的其他进程在它们下一次试图对此队列进行操作时,将得到EIDRM错误。

            这3条命令(IPC_STAT、IPC_SET、IPC_RMID)也可用于信号量和共享存储。

        调用msgsnd将数据放到消息队列中
        #include <sys/msg.h>
        int msgsnd(int msqid, const void *ptr, size_t nbytes, int flag);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            每个消息都由3部分组成: 一个正的长整型类型字段、一个void *指针、数据字节数、flag
            ptr参数指向一个长整型数,它包含了正的整型消息类型,其后紧接着的是消息数据(若nbytes是0,则无消息数据)
            若发送的最长消息是512字节,则可定义:
            struct mymesg {
                long mtype;
                char mtext[512];
            };
            参数flag的值可以指定为IPC_NOWAIT,这类似于文件I/O的非阻塞I/O标志,若消息队列已满(或者是队列中的消息
            总数等于系统限制值,或队列中的字节总数等于系统限制值),则指定IPC_NOWAIT使得msgsnd立即出错返回EAGAIN。
            如果没有指定IPC_NOWAIT,则进程会一直阻塞到:队列中有空间容纳要发送的消息、或从系统中删除了此队列、或
            捕捉到一个信号,并从信号处理程序中返回

            当msgsnd返回成功时,消息队列相关的msqid_ds结构会随之更新,表明调用的进程ID(msg_lspid)、调用的时间(
            msg_stime)、队列中新增的消息(msg_qnum)

            msgrcv从队列中取消息
            #include <sys/msg.h>
            ssize_t msgrcv(int msqid, void *ptr, size_t nbytes, long type, int flag);

            返回值:
                成功,返回消息数据部分的长度
                出错,返回-1

            函数说明:
                ptr参数指向一个长整型(其中存储的是返回的消息类型,其后跟随的是存储实际消息数据的缓冲区)
                nbytes指定数据缓冲区的长度
                若返回的消息长度大于nbytes,而且在flag中设置了MSG_NOERROR位,则该消息会被截断,被截断的部分丢弃;
                若没有设置这一标志,而消息又太长,则出错返回E2BIG(消息仍留在队列中);

                参数type可以指定想要哪一种消息:
                    type == 0   返回队列中的第一个消息
                    type >  0   返回队列中消息类型为type的第一个消息
                    type <  0   返回队列中消息类型值小于等于type绝对值的消息,如果这种消息有若干个,则取
                                类型值最小的消息
                type值非0用于以非先进先出次序读消息,若应用程序对消息赋予优先权,那么type就可以是优先权值。
                如果一个消息队列由多个客户进程和一个服务器进程使用,那么type字段可以用来包含客户进程的进程ID

                可以将flag值指定为IPC_NOWAIT,使操作不阻塞,这样如果没有所指定类型的消息可用,则msgrcv返回-1,
                error设置为ENOMSG;
                如果没有指定IPC_NOWAIT,则进程会一直阻塞到有了指定类型的消息可用,或者从系统中删除了此队列(返回
                -1,errno设置为EIDRM),或者捕捉到一个信号并从信号处理程序中返回(这回导致msgrcv返回-1,errno设置
                为EINTR)

            msgrcv成功执行时,内核会更新与该消息队列相关联的msgid_ds结构,以指示调用者的进程ID(msg_lrpid)和调用
            时间(msg_rtime),并指示队列中的消息数减少一个(msg_qnum).

        8、 信号量
            信号量管道、FIFO以及消息队列不同,它是一个计数器,用于为多个进程提供对共享数据对象的访问。
            为了获得共享资源,进程需要执行下列操作:
                1)  测试控制该资源的信号量
                2)  若此信号量的值为正,则进程可以使用该资源,在这种情况下,进程会将信号量值减1,表示它使用了一个资源单位
                3)  否则,若此信号量的值为0,则进程进入休眠状态,直至信号量值大于0,进程被唤醒后,返回至步骤1

            当进程不再使用由一个信号量控制的共享资源时,该信号量值增1,如果有进程正在休眠等待此信号量,则唤醒它们。
            为了正确的实现信号量,信号量的测试及减1操作应当是原子操作,为此,信号量通常是在内核中实现的

            常用的信号量形式被称为二元信号量(binary semaphore).它控制单个资源,其初始值为1。但是一般而言,信号量的初
            值可以是任意一个正值,该值表明有多少个共享资源单位可供共享应用

            信号量的3个特性:
                a.  信号量并非是单个非负值,而必须定义为含有一个或多个信号量值的集合,当创建信号量时,要指定集合中信号
                    量值的数量。
                b.  信号量的创建(semget)是独立于它的初始化(semctl)的,这是一个致命的缺点,因为不能原子的创建一个信号量
                    集合,并且对该集合中的各个信号量值赋初值
                c.  即使没有进程正在使用各种形式的XSI IPC,它们仍然是存在的。有的程序终止时并没有释放已经分配给它的
                    信号量,所以我们不得不为这种程序担心,undo处理这种情况。

            内核为每个信号量集合维护着一个semid_ds结构:
                struct semid_ds {
                    struct ipc_perm     sem_perm;
                    unsigned short      sem_nsems;      /* # of semaphores in set */
                    time_t              sem_otime;      /* last-semop() time */
                    time_t              sem_ctime;      /* last-change time */
                    ...
                };
            每个信号量由一个无名结构表示,它至少包含下列成员:
                struct {
                    unsigned short  semval;     /* semaphore value, always >= 0 */ 
                    pid_t           sempid;     /* pid for last operation */
                    unsigned short  semncnt;    /* processes awaiting semval > curval */
                    unsigned short  semzcnt;    /* processes awaiting semval == 0 */
                };

        当要使用XSI信号量时,首先需要调用函数semget来获得一个信号量ID。
        #include <sys/sem.h>
        int semget(key_t key, int nsems, int flag);

        返回值:
            成功,返回信号量ID
            出错,返回-1

        函数说明:
            nsems参数是该集合中的信号量数,如果是创建新集合,则必须指定nsems;如果是引用现有集合,则将nsems指定为0

        semctl函数包含了多种信号量操作
        #include <sys/sem.h>
        int semctl(int semid, int semnum, int cmd, ... /* union semun arg */);

        函数说明:
            第4个参数是可选的,是否取决于所请求的命令,如果使用该参数,则其类型是semun,它是多个命令待定参数的联合(union):
            union semun {
                int                 val;        /* for SETVAL */
                struct semid_ds     *buf;       /* for IPC_STAT and IPC_SET */
                unsigned short      *array;     /* for GETALL and SETALL */
            };

            cmd 参数指定了下列10种命令中的一种,这些命令是运行在semid指定的信号量集合上的。其中有5种命令是针对一个特定
            的信号量值的,它们用semnum指定该信号量集合中的一个成员,semnum值在0和nsems-1之间,包括0和nsems-1.
                IPC_STAT    -   对此集合取semid_ds结构,并存储在由arg.buf指向的结构中
                IPC_SET     -   按arg.buf指向的结构中的值,设置与此集合相关的结构中的sem_perm.uid、sem_perm.gid和
                                sem_perm.mode字段。此命令只能由两种进程执行:创建进程和超级用户进程
                IPC_RMID    -   从系统中删除该信号量集合,这种删除是立即发生的。删除时仍在使用此信号量集合的其他进程,在
                                它们下次试图对此信号量集合进行操作时,将出错返回EIDRM
                GETVAL      -   返回成员semnum的semval值
                SETVAL      -   设置成员semnum的semval值,该值由arg.val指定
                GETPID      -   返回成员semnum的sempid值
                GETNCHT     -   返回成员semnum的semncnt值
                GETZCNT     -   返回成员semnum的semzcnt值
                GETALL      -   取该集合中所有的信号量值,这些值存储在arg.array指向的数组中
                SETALL      -   将该集合中所有的信号量值设置成arg.array指向的数组中的值

            对于除GETALL以外的所有GET命令,semctl函数都返回相应值,对于其他命令,若成功则返回值为0,若出错,则设置errno并
            返回-1.

        函数semop自动执行信号量集合上的操作数组
        #include <sys/sem.h>
        int semop(int semid, struct sembuf semoparray[], size_t nops);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            参数semoparray是一个指针,它指向一个由sembuf结构表示的信号量操作数组:
            struct sembuf {
                unsigned short      sem_num;    /* member # in set (0, 1, ..., nsems-1) */
                short               sem_op;     /* operation(negative, 0, or pasitive) */
                short               sem_flg;    /* IPC_NOWAIT , SEM_UNDO */
            };

            参数nops规定该数组中操作的数量(元素数)。
            对集合中每个成员的操作由相应的sem_op值规定,此值可以是负值、0或正值
                1)  最易于处理的情况是sem_op为正值,这对应于进程释放的占用的资源数。sem_op值会加到信号量的值上,如果
                    指定了undo标志,则也从该进程的此信号量调整值中减去sem_op
                2)  若sem_op为负值,则表示要获取由该信号量控制的资源

        exit时的信号量调整
            如果在进程终止时,它占用了经由信号量分配的资源,那么就会成为一个问题。无论何时只要为信号量操作指定了SEM_UNDO
            标志,然后分配资源(sem_op值小于0),那么内核就会记住对于该特定信号量,分配给调用进程多少资源(sem_op的绝对值)。
            当该进程终止时,不论自愿或者不自愿,内核都将检验该进程是否还要尚未处理的信号量调整值,如果有,则按调整值对相应
            信号量值进行处理。

            如果用带SETVAL或SETALL命令的semctl设置一个信号量的值,则在所有进程中,该信号量的调整值都将设置为0

    9、 共享存储    -   最快的IPC
        内核为每个共享存储段维护着一个结构,该结构至少要为每个共享存储段包含以下成员:
            struct shmid_ds {
                struct ipc_perm shm_perm;
                size_t          shm_segsz;      /* size of segment in bytes */
                pid_t           shm_lpid;       /* pid of last shmop() */
                pid_t           shm_cpid;       /* pid of creator */
                shmatt_t        shm_nattch;     /* number of current attaches */
                time_t          shm_atime;      /* last-attach time */
                time_t          shm_dtime;      /* last-detach time */
                time_t          shm_ctime;      /* last-change time */
                ...
            };
        shmatt_t类型定义为无符号整型,它至少与unsigned short一样大。

        调用的第一个函数通常是shmget,它获得一个共享存储标识符
        #include <sys/shm.h>
        int shmget(key_t key, size_t size, int flag);

        返回值:
            成功,返回共享存储ID
            出错,返回-1

        函数说明:
            参数size是该共享存储段的长度,以字节为单位。实现通常将其向上取为系统页长的整倍数。
            若指定的size值并非系统页长的整倍数,那么最后一页的余下部分是不可用的。
            创建新段,则必须指定size;引用现有的段,size指定为0

        shmctl函数对共享存储段执行多种操作
        #include <sys/shm.h>
        int shmctl(int shmid, int cmd, struct shmid_ds *buf);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            cmd参数指定下列5种命令中的一种,使其在shmid指定的段上执行
            IPC_STAT    -   取此段的shmid_ds结构,并将它存储在由buf指向的结构中
            IPC_SET     -   按buf指向的结构中的值设置与此共享存储段相关的shmid_ds结构中的下列3个字段:shm_perm.uid、
                            shm_perm.gid和shm_perm.mode
            IPC_RMID    -   从系统删除该共享存储段。因为每个共享存储段维护着一个连接计数(shmid_ds结构中的
                            shm_nattch字段),所以除非使用该段的最后一个进程终止或与该段分离,否则不会实际上删除该存储
                            段。不管此段是否仍在使用,该段标识符都会被立即删除,所以不能再使用shmat与该段连接
            SHM_LOCK    -   在内存中对共享存储段加锁,此命令只能由超级用户执行
            SHM_UNLOCK  -   解锁共享存储段,此命令只能由超级用户执行

        一旦创建了一个共享存储段,进程就可调用shmat将其连接到它的地址空间中
        #include <sys/shm.h>
        void *shmat(int shmid, const void *addr, int flag);

        返回值:
            成功,返回指向共享存储段的指针
            出错,返回-1

        函数说明:
            共享存储段连接到调用进程的哪个地址上与addr参数以及flag中是否指定SHM_RND位有关
                a.  如果addr为0,则此段连接到由内核选择的第一个可用地址上
                b.  如果addr非0,并且没有指定SHM_RND,则此段连接到addr所指定的地址上
                c.  如果addr非0,并且指定了SHM_RND,则此段连接到(addr-(addr mod SHMLBA))所表示的地址上。
                    SHM_RND命令的意思是"取整",SHMLBA的意思是"低边界地址倍数",它总是2的乘方,该算式是将地址向下取
                    最近1个SHMLBA的倍数

            flag指定SHM_RDONLY位,则以只读方式连接此段,否则以读写方式连接此段。
            shmat执行成功,那么内核将使与该共享存储段相关的shmid_ds结构中的shm_nattch计数器值加1

        #include <sys/shm.h>
        int shmdt(const void *addr);

        返回值:
            若成功,返回0
            出错,返回-1

        函数说明:
            addr参数是以前调用shmat时的返回值。如果成功,shmdt将使相关shmid_ds结构中的shm_nattch计数器值减1.

        注:
            共享存储段紧靠在栈区之下。

        mmap函数可将一个文件的若干部分映射至进程地址空间,这在概念上类似于用shmat XSI IPC函数连接一个共享存储段。
        两者之间的主要区别是,用mmap映射的存储段是与文件相关联的,而XSI共享存储段则并无这种关联。

        在读设备/dev/zero时,该设备是0字节的无限资源,它也接收写向它的任何数据,但又忽略这些数据。
        我们对此设备作为IPC的兴趣在于,当对其进行存储映射时,它具有一些特殊性质:
            a.  创建一个未命名的存储区,其长度是mmap的第二个参数,将其向上取整为系统的最近页长。
            b.  存储区都初始化为0
            c.  如果多个进程的共同祖先进程对mmap指定了MAP_SHARED标志,则这些进程可共享此存储区

        见Chapter_15/UseZero.c 在父子进程之间使用/dev/zero的存储映射I/O的IPC

    10、 POSIX信号量

        POSIX信号量接口意在解决XSI信号量接口的几个缺陷:
            a.  相比于XSI接口,POSIX信号量接口考虑到了更高性能的实现
            b.  POSIX信号量接口使用更简单:没有信号量集,在熟悉的文件系统调用操作后一些接口被模式化了。
            c.  POSIX信号量在删除时表现更完美。使用POSIX信号量时,操作能继续正常工作直到该信号量的最后
                一次引用被释放

        POSIX信号量有两种形式:命名的和未命名的。它们的差异在于创建和销毁的形式上,但其他工作都一样，
            未命名信号量只存在于内存中,并要求能使用信号量的进程必须可以访问内存,这意味着它们只能应用在同一进程的
            线程中,或者不同进程中已经映射相同内存内容到它们的地址空间中的线程。
            命名信号量可以通过名字访问,因此可以被任何已知它们名字的进程中的线程使用。

        我们可以调用sem_open函数来创建一个新的命名信号量或者使用一个现有信号量
        #include <semaphore.h>
        sem_t *sem_open(const char *name, int oflag, ... /* mode_t mode, unsigned int value */);

        返回值:
            成功,返回指向信号量的指针;
            出错,返回SEM_FAILED

        函数说明:
            当使用一个现有的命名信号量时,我们仅仅指定两个参数:信号量的名字和oflag参数的0值,当这个oflag参数
            有O_CREAT标志集时,如果命名信号量不存在,则创建一个新的;如果已经存在,则会被使用。
            我们指定O_CREAT标志时,需要提供两个额外参数,mode参数指定谁可以访问信号量。
            mode的取值和打开文件的权限位相同:用户读、用户写、用户执行、组读、组写、组执行、其他读、其他写
            和其他执行。
            在创建信号量时,value参数用来指定信号量的初始值,它的取值是0~SEM_VALUE_MAX
            如果我们想确保是创建信号量,可以设置oflag参数为 O_CREAT|O_EXCL,如果信号量已经存在,会导致sem_open失败

        如果想在信号量上进行操作,sem_open函数会为我们返回一个信号量指针,用于传递到其他信号量函数上.当完成
        信号量操作时,可以调用sem_close函数来释放任何信号量相关的资源。
        #include <semaphore.h>
        int sem_close(sem_t *sem);

        返回值:
            若成功,返回0
            出错,返回-1
        
        函数说明:
            如果进程没有首先调用sem_close而退出,那么内核将自动关闭任何打开的信号量。
            这不会影响信号量值的状态----如果已经对它进行了增1操作,这并不会仅因为退出而改变

        #include <semphore.h>
        int sem_unlink(const char *name);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            sem_unlink 来销毁一个命名信号量
            sem_unlink函数删除信号量的名字,如果没有打开的信号量引用,则该信号量会被销毁;否则,销毁将
            延迟到最后一个打开的引用关闭

        可以使用sem_wait或者sem_trywait函数来实现信号量的减1操作
        #include <semaphore.h>
        int sem_trywait(sem_t *sem);
        int sem_wait(sem_t *sem);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            使用sem_wait函数时,如果信号量计数是0就会发生阻塞。直到成功使信号量减1或者被信号中断才会返回。
            可以使用sem_trywait函数来避免阻塞,调用sem_trywait时,如果信号量是0,直接返回-1并且将errno设置为EAGIN

        #include <semaphore.h>
        #include <time.h>
        int sem_timedwait(sem_t *restrict sem, const struct timespec *restrict tsptr);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            指定阻塞等待的时间
            如果超时并且信号量计数没能减1,sem_timedwait将返回-1且将errno设置为ETIMEDOUT

        可以调用sem_post函数使信号量值增1,这和解锁一个二进制信号量或者释放一个计数信号量相关的资源过程是类似的
        #include <semaphore.h>
        int sem_post(sem_t *sem);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            调用sem_post时,如果在调用sem_wait(或者sem_timedwait)中发生进程阻塞,那么进程会被唤醒并且被
            sem_post增1的信号量计数会再次被sem_wait(或者sem_timedwait)减1.
    
        当在单个进程使用POSIX信号量时,使用未命名信号量,sem_init函数用来创建一个未命名信号量
        #include <semaphore.h>
        int sem_init(sem_t *sem, int pshared, unsigned int value);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            pshared参数表明是否在多个进程中使用信号量,如果是,将其设置为一个非0值
            value参数指定了信号量的初始值
            需要声明一个sem_t类型的变量并把地址传递给sem_init来实现初始化

            如果要在两个进程之间使用信号量,需要确保sem参数指向两个进程之间共享的内存范围

        对未命名信号量的使用已经完成时,可以调用sem_destroy函数丢弃它
        #include <semaphore.h>
        int sem_destroy(sem_t *sem);

        返回值:
            成功,返回0
            出错,返回-1

        sem_getvalue函数可以用来检索信号量值
        #include <semaphore.h>
        int sem_getvalue(sem_t *restrict sem, int *restrict valp);

        返回值:
            若成功,返回0
            出错,返回-1

        函数说明:
            成功后,valp指向的整数值将包含信号量值。但是,可能使用该值时,信号量的值已经改变了。
            用来调试。

    11、 客户进程-服务器进程属性

第16章、 网络IPC: 套接字
    1、 套接字描述符
        套接字描述符在UNIX系统中被当作是一种文件描述符
        创建套接字,调用socket函数
        #include <sys/socket.h>
        int socket(int domain, int type, int protocol);

        返回值:
            成功,返回文件描述符(套接字)
            出错,返回-1

        函数说明:
            参数domain(域)确定通信的特性,包括地址格式。取值如下:
                AF_INET     -   IPv4因特网域
                AF_INET6    -   IPv6因特网域
                AF_UNIX     -   UNIX域
                AF_UPSPEC   -   未指定
            各个域都有自己表示地址的格式,而表示各个域的常数都是以AF_开头,意指地址族(address family).

            参数type确定套接字的类型,进一步确定通信特征。取值如下:
                SOCK_DGRAM      -   固定长度的、无连接的、不可靠的报文传递
                SOCK_RAW        -   IP协议的数据报接口
                SOCK_SEQPACKET  -   固定长度的、有序的、可靠的、面向连接的报文传递
                SOCK_STREAM     -   有序的、可靠的、双向的、面向连接的字节流

            参数protocol通常是0,表示为给定的域和套接字类型选择默认协议。当对同一域和套接字类型支持多个协议时,
            可以使用protocol选择一个特定协议.
            在AF_INET通信域中,套接字类型SOCK_STREAM的默认协议是传输控制协议(Transmission Control Protocol, TCP).
            在AF_INET通信域中,套接字类型SOCK_DGRAM默认协议是UDP
            protocol的取值如下:
                IPPROTO_IP      -   IPv4网际协议
                IPPROTO_IPV6    -   IPv6网际协议
                IPPROTO_ICMP    -   因特网控制报文协议(Internet Control Message Protocol)
                IPPROTO_RAW     -   原始IP数据包协议
                IPPROTO_TCP     -   传输控制协议
                IPPROTO_UDP     -   用户数据报协议(User Datagram Protocol)

        数据报(SOCK_DGRAM)接口,两个对等进程之间通信时不需要逻辑连接,只需要向对等进程所使用的套接字送出一个报文
        SOCK_STREAM套接字提供字节流服务,应用程序需要通过多次调用才能得到完整数据
        SOCK_SEQPACKET套接字和SOCK_STREAM套接字很类似,只是从该套接字得到的是基于报文的服务而不是字节流
        SOCK_RAM套接字提供一个数据报接口,用于直接访问下面的网络层(即因特网域中的IP层),使用这个接口时,应用程序
            负责构造自己的协议头部,这是因为传输协议(TCP/UDP)被绕过了。当创建一个原始套接字时,需要有超级用户特权,
            这样可以防止恶意应用程序绕过安全机制来创建报文。

        套接字通信是双向的。可以采用shutdown函数来禁止一个套接字的I/O
        #include <sys/socket.h>
        int shutdown(int sockfd, int how);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            如果how是SHUT_RD(关闭读端),那么无法从套接字读取数据;如果how是SHUT_WR(关闭写端),那么无法使用套接字
            发送数据。
            如果how是SHUT_RDWR,则既无法读也无法写。

            使用shutdown而不使用close的理由:
                只有最后一个活动引用关闭时,close才释放网络端点,这意味着如果复制一个套接字(如采用dup),要直到
                关闭了最后一个引用它的文件描述符才会释放这个套接字。
                而shutdown允许使一个套接字处于不活动状态,和引用它的文件描述符数目无关。
                其次,可以很方便的关闭套接字双向传输中的一个方向。

    2、 寻址
        2.1、 字节序
            
            字节序是一个处理器架构特性,用于指示像整数这样的大数据类型内部的字节如何排序.
            网络协议指定了字节序,因此异构计算机系统能够交换协议信息而不会被字节序所混淆;
            TCP/IP协议栈使用大端字节序。
            
            对于TCP/IP应用程序,有4个用来在处理器字节序和网络字节序之间实施转换的函数。
            #include <arpa/inet.h>
            uint32_t htonl(uint32_t hostint32);
                        返回值: 以网络字节序表示的32位整数
            uint16_t htons(uint16_t hostint16);
                        返回值: 以网络字节序表示的16位整数
            uint32_t ntohl(uint32_t netint32);
                        返回值: 以主机字节序表示的32位整数
            uint16_t ntohs(uint16_t netint16);
                        返回值: 以主机字节序表示的16位整数

            函数说明:
                h表示"主机"字节序,n表示"网络"字节序。
                l表示"长"整数,即4字节;s表示"短"整数,即2字节整数。

        2.2、 地址格式
            一个地址标识一个特定通信域的套接字端点,地址格式与这个特定的通信域相关。为使不同格式地址能够
            传入到套接字函数,地址会被强制转换成一个通用的地址结构sockaddr:
                struct sockaddr {
                    sa_family_t     sa_family;      /* address family */
                    cahr            sa_data[];      /* variable-length address */
                };
            套接字实现可以自由的添加额外的成员并且定义sa_data成员的大小。

            用于二进制地址格式与点分十进制格式的转换函数,同时支持IPv4地址和IPv6地址:
            #include <arpa/inet.h>
            const char *inet_ntop(int domain, const void *restrict addr, char *restrict str, socklen_t size);
                    返回值: 成功,返回地址字符串指针;出错,返回NULL
            int inet_pton(int domain, const char *restrict str, void *restrict addr);
                    返回值: 成功,返回1;格式无效,返回0;出错,返回-1

            函数说明:
                inet_ntop   -   将网络字节序的二进制地址转换成文本字符串格式。
                inet_pton   -   将文本字符串转换成网络字节序的二进制地址。

                参数domain仅支持两个值: AF_INET 和 AF_INET6

                对于inet_ntop,参数size指定了保存文本字符串的缓冲区(str)大小。
                两个常数用于简化工作:
                    INET_ADDRSTRLEN 定义了足够大的空间来存放一个表示IPv4地址的文本字符串
                    INET6_ADDRSTRLEN 定义了足够大的空间来存放一个表示IPv6地址的文本字符串

                对于inet_pton,如果domain是AF_INET,则缓冲区addr需要足够大的来存放一个32位地址;
                如果domain是AF_INET6,则需要足够大的空间来存放一个128位地址

        2.3、 地址查询
            这些函数返回的网络配置信息被存放在许多地方,这个信息可以存放在静态文件(如/etc/hosts和/etc/services)中,
            也可以由名字服务管理,如域名系统(Domain Name System, DNS)或者网络信息服务(Network Information Service,
            NIS).

            通过调用gethostent,可以找到给定计算机系统的主机信息。
            #include <netdb.h>
            struct hostent *gethostent(void);
                    返回值: 成功,返回指针;出错,返回NULL
            void sethostent(int stayopen);
            void endhostent(void);

            函数说明:
                如果主机数据库文件没有打开,gethost会打开它。函数gethostent返回文件中的下一个条目。
                函数sethostent会打开文件,如果文件已经被打开,那么将其回绕。
                    当stayopen参数设置成非0值时,调用gethostent之后,文件将依然是打开的。
                函数endhostent可以关闭文件。

                当gethostent返回时,会得到一个指向hostent结构的指针,该结构可能包含一个静态的数据缓冲区,
                每次调用gethostent,缓冲区都会被覆盖。hostent结构至少包含以下成员:
                    struct hostent {
                        char    *h_name;        /* name of host */
                        char    **h_aliases;    /* pointer to alternate host name array */
                        int     h_addrtype;     /* address type */
                        char    **h_addr_list;  /* pointer to array of network addresses */
                        ...
                    };
                返回的地址采用网络字节序。

            用来获得网络名字和网络编号的函数
            #include <netdb.h>
            struct netent *getnetbyaddr(uint32_t net, int type);
            struct netent *getnetbyname(const char *name);
            struct netent *getnetent(void);

                    3个函数的返回值:
                        成功,返回指针
                        出错,返回NULL

            void setnetent(int stayopen);
            void endnetent(void);

            函数说明:
                netent结构至少包含以下字段:
                    struct netent {
                        char        *n_name;        /* network name */
                        char        **n_aliases;    /* alternate network name array pointer */
                        int         n_addrtype;     /* address type */
                        uint32_t    n_net;          /* network number */
                        ...
                    };
                网络编号按照网络字节序返回,地址类型是地址族常亮之一(如AF_INET).

            我们可以用以下函数在协议名字和协议编号之间进行映射。
            #include <netdb.h>
            struct protoent *getprotobyname(const char *name);
            struct protoent *getprotobynumber(int proto);
            struct protoent *getprotoent(void);
                        3个函数返回值:  成功,返回指针;  出错,返回NULL。

            void setprotoent(int stayopen);
            void endprotoent(void);

            函数说明:
                POSIX.1 定义的protoent结构至少包含以下成员:
                    struct protoent {
                        char    *p_name;        /* protocol name */
                        char    **p_aliases;    /* pointer to altername protocol name array */
                        int     p_proto;        /* protocol number */
                        ...
                    };

            服务是由地址的端口号部分表示的,每个服务由一个唯一的众所周知的端口号来支持。
            可以使用函数getservbyname将一个服务名映射到一个端口号,使用函数getservbyport将一个端口号映射到
            一个服务名,使用函数getservent顺序扫描服务数据库。
            #include <netdb.h>
            struct servent *getservbyname(const char *name, const char *proto);
            struct servent *getservnyport(int port, const char *proto);
            struct servent *getservent(void);
                    3个函数返回值: 成功,返回指针; 出错,返回NULL
            void setservent(int stayopen);
            void endservent(void);

            函数说明:
                servent结构至少包含以下成员:
                    struct servent {
                        char    *s_name;        /* service name */
                        char    **s_aliases;    /* pointer to alternate service name array */
                        int     s_port;         /* port number */
                        char    *s_proto;       /* name of protocol */
                        ...
                    };

            POSIX.1定义了若干新的函数,允许一个应用程序将一个主机名和一个服务名映射到一个地址,或者反之。
            这些函数代替了较老的函数gethostbyname 和 gethostbyaddr.

            #include <sys/socket.h>
            int getaddrinfo(const char *restrict host, const char *restrict service,
                            const struct addrinfo *restrict hint, struct addrinfo **restrict res);
                        返回值: 成功,返回0; 出错,返回非0错误码。
            void freeaddrinfo(struct addrinfo *ai);

            函数说明:
                getaddrinfo -   允许将一个主机名和一个服务名映射到一个地址
                需要提供主机名、服务名,或者两者都提供。如果仅仅提供一个名字,另外一个必须是一个空指针。
                主机名可以是一个节点名或点分十进制格式的主机地址。

                getaddrinfo函数返回一个链表结构addrinfo.可以用freeaddrinfo来释放一个或多个这种结构,这
                取决于用ai_next字段链接起来的结构有多少。
                addrinfo 结构的定义至少包含以下成员:
                struct addrinfo {
                    int             ai_flags;       /* customize behavior */
                    int             ai_family;      /* address family */
                    int             ai_socktype;    /* socket type */
                    int             ai_protocol;    /* protocol */
                    socklen_t       ai_addrlen;     /* length in bytes of address */
                    struct sockaddr *ai_addr;       /* address */
                    char            *ai_canonname;  /* canonical name of host */
                    struct addrinfo *ai_next;       /* next in list */
                    ...
                };

                可以提供一个可选的hint来选择符合特定条件的地址,hint是一个用于过滤地址的模版,包括ai_family、
                ai_flags、ai_protocol 和 ai_socktype字段。剩余的整数字段必须设置为0,指针字段必须为空。

                ai_flags字段中的标志,可以用这些标志来自定义如何处理地址和名字:
                    AI_ADDRCONFIG   -   查询配置的地址类型(IPv4 或 IPv6)
                    AI_ALL          -   查找IPv4 和 IPv6地址(仅用于AI_V4MAPPED)
                    AI_CANONNAME    -   需要一个规范的名字(与别名相对)
                    AI_NUMERICHOST  -   以数字格式指定主机地址,不翻译
                    AI_NUMERICSERV  -   将服务指定为数字端口号,不翻译
                    AI_PASSIVE      -   套接字地址用于监听绑定
                    AI_V4MAPPED     -   如果没有找到IPv6地址,返回映射到IPv6格式的IPv4地址

            如果getaddrinfo失败,不能使用perror或strerror来生成错误消息,而是要调用gai_strerror将返回的错误码
            转换成错误消息
            #include <netdb.h>
            const char *gai_strerror(int error);

            返回值:
                指向描述错误的字符串的指针

            getnameinfo函数将一个地址转换成一个主机名和一个服务名
            #include <sys/socket.h>
            #include <netdb.h>
            int getnameinfo(const struct sockaddr *restrict addr, socklen_t alen,
                            char *restrict host, socklen_t hostlen,
                            char *restrict service, socklen_t servlen, int flags);

            返回值:
                成功,返回0
                出错,返回非0值

            函数说明:
                套接字地址(addr)被翻译成一个主机名和一个服务名。
                如果host非空,则指向一个长度为hostlen字节的缓冲区用于存放返回的主机名。
                同样,如果service非空,则指向一个长度为servlen字节的缓冲区用于存放返回的主机名。

                flags参数提供了一些控制翻译的方式。
                    NI_DGRAM        -   服务基于数据报而非基于流
                    NI_NAMEREQD     -   如果找不到主机名,将其作为一个错误对待
                    NI_NOFQDN       -   对于本地主机,仅返回全限定域名的节点名部分
                    NI_NUMERICHOST  -   返回主机地址的数字形式,而非主机名
                    NI_NUMERICSCOPE -   对于IPv6,返回范围ID的数字形式,而非名字
                    NI_NUMERICSERV  -   返回服务地址的数字形式(即端口号),而非名字

            见Chapter_16/getAddrInfo.c  示例getaddrinfo函数的使用方法

        2.4、 将套接字与地址关联
            对于服务器,需要给一个接收客户端请求的服务器套接字关联上一个众所周知的地址。

            使用bind函数来关联地址和套接字
            #include <sys/socket.h>
            int bind(int sockfd, const struct sockaddr *addr, socklen_t len);

            返回值:
                成功,返回0
                出错,返回-1

            函数说明:
                对于使用的地址有以下限制:
                    1)  在进程正在运行的计算机上,指定的地址必须有效;不能指定一个其他机器的地址
                    2)  地址必须和创建套接字时的地址族所支持的格式相匹配
                    3)  地址中的端口号必须不小于1024,除非该进程具有相应的特权(即超级用户)
                    4)  一般只能将一个套接字端点绑定到一个给定地址上,尽管有些协议允许多重绑定

                对于因特网域,如果指定IP地址为INADDR_ANY(<netinet/in.h>中定义的),套接字端点可以被绑定到所有的
                系统网络接口上。这就意味着可以接收这个系统所安装的任何一个网卡的数据包

            可以调用getsockname函数来发现绑定到套接字上的地址:
            #include <sys/socket.h>
            int getsockname(int sockfd, struct sockaddr *restrict addr, socklen_t *restrict alenp);

            返回值:
                成功,返回0
                出错,返回-1

            函数说明:
                调用getsockname之前,将alenp设置为一个指向整数的指针,该整数指定缓冲区addr的长度。
                返回时,该整数会被设置成返回地址的大小。
                如果地址和提供的缓冲区长度不匹配,地址会被自动截断而不报错。
                如果当前没有地址绑定到该套接字,则其结果是未定义的。

            如果套接字已经和对方连接,可以调用getpeername函数来找到对方的地址。
            #include <sys/scoket.h>
            int getpeername(int sockfd, struct sockaddr *restrict addr, socklen_t *restrict alenp);

            返回值:
                成功,返回0
                出错,返回-1

            函数说明:
                除了返回对方的地址之外,函数getpeername 和 getsockname一样。

    3、 建立连接
        如果要处理一个面向连接的网络服务(SOCK_STREAM 或 SOCK_SEQPACKET),那么在开始交换数据以前,需要在请求服务
        的进程套接字(客户端)和提供服务的进程套接字(服务器)之间建立一个连接。使用connect函数来建立连接
        #include <sys/socket.h>
        int connect(int sockfd, const struct sockaddr *addr, socklen_t len);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            在connect中指定的地址是我们想与之通信的服务器地址。
            如果sockfd没有绑定到一个地址,connect会给调用者绑定一个默认地址。

        如果套接字描述符处于非阻塞模式,那么在连接不能马上建立时,connect将会返回-1并且将errno设置为特殊的错误码
        EINPROGRESS。应用程序可以使用poll或者select来判断文件描述符何时可写,如果可写,连接完成。

        connect函数还可以用于无连接的网络服务(SOCK_DGRAM),如果用SOCK_DGRAM套接字调用connect,传送的报文的目标地址
        会设置成connect调用中所指定的地址,这样每次传送报文时就不需要再提供地址。另外,仅能接收来自指定地址的报文。

        服务器调用listen函数来宣告它愿意接受连接请求
        #include <sys/socket.h>
        int listen(int sockfd, int backlog);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            参数backlog提供了一个提示,提示系统该进程所要入队的未完成连接请求数量。其实际值由系统决定,但上限由
            <sys/socket.h>中的SOMAXCONN指定。

            一旦队列满了,系统就会拒绝多余的连接请求,所以backlog的值应该基于服务器期望负载和处理量来选择,其中处理量
            是指接受连接请求与启动服务的数量。

        一旦服务器调用了listen,所用的套接字就能就收连接请求。使用accept函数来获得连接请求并建立连接。
        #include <sys/socket.h>
        int accept(int sockfd, struct sockaddr *restrict addr, socklen_t *restrict len);

        返回值:
            成功,返回文件(套接字)描述符;
            出错,返回-1。

        函数说明:
            函数accept所返回的文件描述符是套接字描述符,该描述符连接到调用connect的客户端。
            这个新的套接字描述符和原始套接字(sockfd)具有相同的套接字类型和地址族。
            传给accept的原始套接字(sockfd)没有关联到这个连接,而是继续保持可用状态并接收其他连接请求。

            如果不关心客户端标识,可以将参数addr和len设置为NULL。否则accept会填充addr客户端地址信息

            如果没有连接请求在等待,accept会阻塞直到一个请求到来。如果sockfd处于非阻塞模式,accept会返回-1,
            并将errno设置为EAGAIN 或 EWOULDBLOCK.

            服务器可以使用poll或select来等待一个请求的到来,在这种情况下,一个带有等待连接请求的套接字会以可读的
            方式出现。

            见Chapter_16/initSer.c  分配和初始化套接字供服务器进程使用
    
    4、 数据传输
        一个套接字端点表示为一个文件描述符,那么只要建立连接,就可以使用read和write来通过套接字通信。
        如果想指定选项,从多个客户端接收数据报,或者发送带外数据,就需要使用6个为数据传递而设计的套接字函数中的一个。
        3个函数用来发送数据,3个函数用于接收数据。

        #include <sys/socket.h>
        ssize_t send(int sockfd, const void *buf, size_t nbytes, int flags);

        返回值:
            成功,返回发送的字节数
            出错,返回-1

        函数说明:
            类似write,使用send时套接字必须已经连接。
            参数buf 和 nbytes的含义与write中的一致。

            参数flags,Linux所支持的标志如下:
                MSG_CONFIRM     -   提供链路层反馈以保持地址映射有效
                MSG_DONTROUTE   -   勿将数据包路由出本地网络
                MSG_DONTWAIT    -   允许非阻塞操作(等价于使用O_NONBLOCK)
                MSG_EOR         -   如果协议支持,标记记录结束
                MSG_MORE        -   延迟发送数据报允许写更多数据
                MSG_NOSIGNAL    -   在写无连接的套接字时不产生SIGPIPE信号
                MSG_OOB         -   如果协议支持,发送带外数据

            即使send成功返回,也不表示连接另一端的进程就一定接受了数据,我们能保证的只是当send成功返回时,数据
            已经被无错误的发送到了网络驱动程序上。

            对于支持报文边界的协议,如果尝试发送的单个报文的长度超过协议所支持的最大长度,那么send会失败,并将
            errno设为EMSGSIZE.
            对于字节流协议,send会阻塞直到整个数据传输完成。
            
        函数sendto和send很类似,区别在于sendto可以在无连接的套接字上指定一个目标地址。
        #include <sys/socket.h>
        ssize_t sendto(int sockfd, const void *buf, size_t nbytes, int flags, 
                        const struct sockaddr *destaddr, socklen_t destlen);

        返回值:
            成功,返回发送的字节数
            出错,返回-1

        函数说明:
            对于面向连接的套接字,目标地址是被忽略的,因为连接中隐含了目标地址。
            对于无连接的套接字,除非先调用connect设置了目标地址,否则不能使用send。
            sendto提供了发送报文的另一种方式。

        通过套接字发送数据时,还有另一种选择。可以调用带有msghdr结构的sendmsg来指定多重缓冲区传输数据,
        这和writev函数很类似
        #include <sys/socket.h>
        ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);

        返回值:
            成功,返回发送的字节数
            出错,返回-1

        函数说明:
            POSIX.1 定义了msghdr结构,它至少有以下成员:
                struct msghdr {
                    void            *msg_name;      /* optional address */ 
                    socklen_t       msg_namelen;    /* address size in bytes */
                    struct iovec    *msg_iov;       /* array of I/O buffers */
                    int             msg_iovlen;     /* number of elements in array */
                    void            *msg_control;   /* ancillary data  */
                    socklen_t       msg_controllen; /* number of ancillary bytes */
                    int             msg_flags;      /* flags for received message */
                    ...
                };

        函数recv和read相似,但是recv可以指定标志来控制如何接收数据
        #include <sys/socket.h>
        ssize_t recv(int sockfd, void *buf, size_t nbytes, int flags);

        返回值:
            返回数据的字节长度:若无可用数据或对方已经按序结束,返回0
            出错,返回-1

        函数说明:
            参数flags在Linux上可用的值:
                MSG_CMSG_CLOEXEC    -   为UNIX域套接字上接收的文件描述符设置执行时关闭标志
                MSG_DONTWAIT        -   启用非阻塞操作(相当于使用O_NONBLOCK)
                MSG_ERRQUEUE        -   接收错误信息作为辅助数据
                MSG_OOB             -   如果协议支持,获取带外数据
                MSG_PEEK            -   返回数据包内容而不真正取走数据包
                MSG_TRUNC           -   即使数据包被截断,也返回数据包的实际长度
                MSG_WAITALL         -   等待直到所有的数据可用(仅SOCK_STREAM)

            当指定MSG_PEEK标志时,可以查看下一个要读取的数据但不真正取走它,当再次调用read或其中一个recv函数时,
            会返回刚才查看的数据。

            对于SOCK_STREAM套接字,接收的数据可以比预期的少,MSG_WAITALL标志会阻止这种行为,知道所请求的数据全部返回,
            recv函数才会返回。
            对于SOCK_DGRAM 和 SOCK_SEQPACKET套接字,MSG_WAITALL标志没有改变什么行为,因为这些基于报文的套接字一次读取
            就返回整个报文。

            如果发送者已经调用shutdown来结束传输,或者网络协议支持按默认的顺序关闭并且发送端已经关闭,那么当所有的
            数据接收完毕后,recv会返回0。

        如果有兴趣定位发送者,可以使用recvfrom来得到数据发送者的源地址
        #include <sys/socket.h>
        ssize_t recvfrom(int sockfd, void *restrict buf, size_t len, size_t len, int flags,
                        struct sockaddr *restrict addr, socklen_t *restrict addrlen);

        返回值:
            返回数据的字节长度: 若无可用数据或对方已经按序结束,返回0
            出错,返回-1

        函数说明:
            如果addr非空,它将包含数据发送者的套接字端点地址。
            当调用recvfrom时,需要设置addrlen参数指向一个整数,该整数包含addr所指向的套接字缓冲区的字节长度
            返回时,该整数设为该地址的实际字节长度。

            因为可以获得发送者的地址,recvfrom通常用于无连接的套接字。否则,recvfrom等同于recv

        为乐将接收到的数据送入多个缓冲区,类似于readv,或者想接收辅助数据,可以使用recvmsg
        #include <sys/socket.h>
        ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);

        返回值:
            返回数据的字节长度:若无可用数据或对方已经按序结束,返回0
            出错,返回-1

        函数说明:
            recvmsg用msghdr结构指定接收数据的输入缓冲区。
            可以设置参数flags来改变recvmsg的默认行为。
            返回时,msghdr结构中的msg_flags字段被设为所接受数据的各种特征。(进入recvmsg时msg_flags被忽略)
            recvmsg中返回的各种可能值如下(Linux):
                MSG_CTRUNC      -   控制数据被截断
                MSG_EOR         -   接收记录结束符
                MSG_ERRQUEUE    -   接受错误信息作为辅助数据
                MSG_OOB         -   接受带外数据
                MSG_TRUNC       -   一般数据被截断

        见Chapter_16/ruptime_TCP_C.c  实现一个面向连接的客户端,与服务器通信的客户端从系统的uptime命令获得输出


    5、 套接字选项
        套接字记之提供了两个套接字选项接口来控制套接字行为。一个接口用来设置选项,另一个接口可以查询选项的状态。
        可以获取或设置以下3种选项
            1)  通用选项,工作在所有套接字类型上
            2)  在套接字层次管理的选项,但是依赖于下层协议的支持
            3)  特定于某协议的选项,每个协议独有的

        可以使用setsockopt函数来设置套接字选项
        #include <sys/socket.h>
        int setsockopt(int sockfd, int level, int option, const void *val, socklen_t len);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            参数level标识了选项应用的协议。如果选项是通用的套接字层次选项,则level设置成SOL_SOCKET。
            否则,level设置成控制这个选项的协议编号。
            对于TCP选项,level是IPPROTO_TCP,
            对于IP,level是IPPROTO_IP.
            通用套接字层次选项如下(level选项、参数val类型、描述):
                SO_ACCEPTCONN       int             返回信息指示该套接字是否能被监听(仅getsockopt)
                SO_BROADCAST        int             如果*val非0,广播数据报
                SO_DEBUG            int             如果*val非0,启用网络驱动调试功能
                SO_DONTROUTE        int             如果*val非0,绕过通常路由
                SO_ERROR            int             返回挂起的套接字错误并清除(仅getsockopt)
                SO_KEEPALIVE        int             如果*val非0,启用周期性keep-alive报文
                SO_LINGER           struct linger   当还有未发报文而套接字已关闭时,延迟时间
                SO_OOBINLINE        int             如果*val非0,将带外数据放在普通数据中
                SO_RCVBUF           int             接收缓冲区的字节长度
                SO_RCVLOWAT         int             接收调用中返回的最小数据字节数
                SO_RCVTIMEO         struct timeval  套接字接受调用的超时值
                SO_REUSEADDR        int             如果*val非0,重用bind中的地址
                SO_SNDBUF           int             发送缓冲区的字节长度
                SO_SNDLOWAT         int             发送调用中传送的最小数据字节数
                SO_SNDTIMEO         struct timeval  套接字发送调用的超时值
                SO_TYPE             int             标识套接字类型(仅getsockopt)

            参数val根据选项的不同指向一个数据结构或者一个整数。一些选项是on/off开关,如果整数非0,则
            启用选项;如果整数为0,则禁止选项。
            参数len指定了val指向的对象的大小

        可以使用getsockopt函数来查看选项的当前值
        #include <sys/socket.h>
        int getsockopt(int sockfd, int level, int option, void *restrict val, socklen_t *restrict lenp);

        返回值:
            成功,返回0
            出错,返回-1

        函数说明:
            参数lenp是一个指向整数的指针。在调用getsockopt之前,设置该整数为复制选项缓冲区的长度。
            如果选项的实际长度大于此值,则选项会被截断;如果实际长度小于此值,那么返回时将此值更新为实际长度。

        实例见Chapter_16/initSer.c

    6、 带外数据
        带外数据(out-of-band data)是一些通信协议所支持的可选功能,与普通数据相比,它允许更高优先级的数据传输。
        带外数据先行传输,即使传输队列已经有数据.
        TCP支持带外数据,但是UDP不支持。

        TCP将带外数据称为紧急数据(urgent data)。TCP仅支持一个字节的紧急数据,但是允许紧急数据在普通数据传递
        机制数据流之外传输。
        为了产生紧急数据,可以在3个send函数中的任意一个里指定MSG_OOB标志,如果带MSG_OOB标志发送的字节数超过
        一个时,最后一个字节将被视为紧急数据字节。

        如果通过套接字安排了信号的产生,那么紧急数据被接收时,会发送SIGURG信号。
        在fcntl中使用F_SETOWN命令来设置一个套接字的所有权。如果fcntl中的第三个参数为正值,那么它指定的就是进程ID。
        如果为非-1的负值,那么它代表的就是进程组ID。
        因此,可以通过调用以下函数安排进程接收套接字的信号:
            fcntl(sockfd, F_SETOWN, pid);
        F_GETOWN命令可以用来获得当前套接字所有权。对于F_SETOWN命令,负值代表进程组ID,正值代表进程ID。
        因此,调用
            owner = fcntl(sockfd, F_GETOWN, 0);
        将返回owner,如果owner为正值,则等于配置为接收套接字信号的进程ID;负值,则其绝对值为进程组ID

        TCP支持紧急标志(urgent mark)的概念,即在普通数据流中紧急数据所在的位置。
        如果采用套接字选项SO_OOBINLINE,那么可以在普通数据中接收紧急数据,为帮助判断是否已经到达紧急标记,
        可以使用函数sockatmark

        #include <sys/socket.h>
        int sockatmark(int sockfd);

        返回值:
            若在标记处,返回1
            若不在标记处,返回0
            出错,返回-1

        函数说明:
            当下一个要读取的字节在紧急标志处时,sockatmark返回1
            
        当带外数据出现在套接字读取队列时,select函数会返回一个文件描述符并且有一个待处理的异常条件。
        可以在普通数据流上接收紧急数据,也可以在其中一个recv函数中采用MSG_OOB标志在其他队列数据之前接收紧急数据。
        TCP队列仅用一个字节的紧急数据,如果在接收当前的紧急数据字节之前又有新的紧急数据到来,那么已有的字节会被丢弃。

    7、 非阻塞和异步I/O
        在套接字非阻塞模式下,recv 和 send 不会阻塞而是会调用失败,将errno设置为EWOULDBLOCK 或者 EAGAIN。
        使用poll或者select来判断是否接收或传输数据。

        在基于套接字的异步I/O中,当从套接字中读取数据时,或者当套接字写队列中空间变得可用时,可以安排要发送的
        信号SIGIO.
        启用异步I/O是一个两步骤的过程:
            1)  建立套接字所有权,这样信号可以被传递到合适的进程
            2)  通知套接字当I/O操作不会阻塞时发送信号。

        可以使用3种方式来完成第一个步骤:
            a.  在fcntl中使用F_SETOWN命令
            b.  在ioctl中使用FIOSETOWN命令
            c.  在ioctl中使用SIOCSPGRP命令

        要完成第二个步骤,有两种选择:
            a.  在fcntl中使用F_SETFL命令并且启用文件标志O_ASYNC
            b.  在ioctl中使用FIOASYNC命令

        以下是LINUX平台所支持的选项:
            fcntl(fd, F_SETOWN, pid);
            ioctl(fd, FIOSETOWN, pid);
            ioctl(fd, SIOCSPGRP, pid);
            fcntl(fd, F_SETFL, flags|O_ASYNC);
            ioctl(fd, FIOASYNC, &n);
